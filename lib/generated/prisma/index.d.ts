
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientAddress
 * 
 */
export type ClientAddress = $Result.DefaultSelection<Prisma.$ClientAddressPayload>
/**
 * Model EmploymentDetail
 * 
 */
export type EmploymentDetail = $Result.DefaultSelection<Prisma.$EmploymentDetailPayload>
/**
 * Model Referee
 * 
 */
export type Referee = $Result.DefaultSelection<Prisma.$RefereePayload>
/**
 * Model BankDetail
 * 
 */
export type BankDetail = $Result.DefaultSelection<Prisma.$BankDetailPayload>
/**
 * Model LoanApplication
 * 
 */
export type LoanApplication = $Result.DefaultSelection<Prisma.$LoanApplicationPayload>
/**
 * Model LoanQualification
 * 
 */
export type LoanQualification = $Result.DefaultSelection<Prisma.$LoanQualificationPayload>
/**
 * Model LoanSecurity
 * 
 */
export type LoanSecurity = $Result.DefaultSelection<Prisma.$LoanSecurityPayload>
/**
 * Model VehicleSecurity
 * 
 */
export type VehicleSecurity = $Result.DefaultSelection<Prisma.$VehicleSecurityPayload>
/**
 * Model Guarantor
 * 
 */
export type Guarantor = $Result.DefaultSelection<Prisma.$GuarantorPayload>
/**
 * Model LoanDisbursement
 * 
 */
export type LoanDisbursement = $Result.DefaultSelection<Prisma.$LoanDisbursementPayload>
/**
 * Model LoanFinancial
 * 
 */
export type LoanFinancial = $Result.DefaultSelection<Prisma.$LoanFinancialPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model InvoicePayment
 * 
 */
export type InvoicePayment = $Result.DefaultSelection<Prisma.$InvoicePaymentPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Repayment
 * 
 */
export type Repayment = $Result.DefaultSelection<Prisma.$RepaymentPayload>
/**
 * Model NonPerformingLoan
 * 
 */
export type NonPerformingLoan = $Result.DefaultSelection<Prisma.$NonPerformingLoanPayload>
/**
 * Model RecoveryAgent
 * 
 */
export type RecoveryAgent = $Result.DefaultSelection<Prisma.$RecoveryAgentPayload>
/**
 * Model RecoveryRecord
 * 
 */
export type RecoveryRecord = $Result.DefaultSelection<Prisma.$RecoveryRecordPayload>
/**
 * Model Investor
 * 
 */
export type Investor = $Result.DefaultSelection<Prisma.$InvestorPayload>
/**
 * Model InvestorAllocation
 * 
 */
export type InvestorAllocation = $Result.DefaultSelection<Prisma.$InvestorAllocationPayload>
/**
 * Model InvestorPayout
 * 
 */
export type InvestorPayout = $Result.DefaultSelection<Prisma.$InvestorPayoutPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model SmsLog
 * 
 */
export type SmsLog = $Result.DefaultSelection<Prisma.$SmsLogPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ChartOfAccount
 * 
 */
export type ChartOfAccount = $Result.DefaultSelection<Prisma.$ChartOfAccountPayload>
/**
 * Model TransactionMatrix
 * 
 */
export type TransactionMatrix = $Result.DefaultSelection<Prisma.$TransactionMatrixPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Title: {
  Mr: 'Mr',
  Mrs: 'Mrs',
  Miss: 'Miss',
  Ms: 'Ms'
};

export type Title = (typeof Title)[keyof typeof Title]


export const MaritalStatus: {
  Single: 'Single',
  Married: 'Married',
  Divorced: 'Divorced',
  Widowed: 'Widowed'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const ClientStatus: {
  Active: 'Active',
  Inactive: 'Inactive'
};

export type ClientStatus = (typeof ClientStatus)[keyof typeof ClientStatus]


export const EmploymentType: {
  FullTime: 'FullTime',
  PartTime: 'PartTime',
  Contract: 'Contract'
};

export type EmploymentType = (typeof EmploymentType)[keyof typeof EmploymentType]


export const LoanApplicationStatus: {
  Pending: 'Pending',
  Approved: 'Approved',
  Rejected: 'Rejected',
  Disbursed: 'Disbursed',
  Active: 'Active',
  NPL: 'NPL',
  Closed: 'Closed'
};

export type LoanApplicationStatus = (typeof LoanApplicationStatus)[keyof typeof LoanApplicationStatus]


export const QualificationType: {
  SalaryBased: 'SalaryBased',
  StatementBased: 'StatementBased'
};

export type QualificationType = (typeof QualificationType)[keyof typeof QualificationType]


export const GuarantorStatus: {
  Pending: 'Pending',
  Confirmed: 'Confirmed',
  Declined: 'Declined'
};

export type GuarantorStatus = (typeof GuarantorStatus)[keyof typeof GuarantorStatus]


export const DisbursementMethod: {
  Bank: 'Bank',
  Mpesa: 'Mpesa'
};

export type DisbursementMethod = (typeof DisbursementMethod)[keyof typeof DisbursementMethod]


export const RepaymentCategory: {
  Employment: 'Employment',
  Business: 'Business',
  Repeat: 'Repeat'
};

export type RepaymentCategory = (typeof RepaymentCategory)[keyof typeof RepaymentCategory]


export const PaymentMethod: {
  Cash: 'Cash',
  Bank: 'Bank',
  Mpesa: 'Mpesa'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const InvoiceType: {
  Disbursement: 'Disbursement',
  Repayment: 'Repayment',
  Penalty: 'Penalty',
  Fee: 'Fee'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const InvoiceStatus: {
  Draft: 'Draft',
  Issued: 'Issued',
  PartiallyPaid: 'PartiallyPaid',
  Paid: 'Paid',
  Overdue: 'Overdue'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const ChargeType: {
  Principal: 'Principal',
  Interest: 'Interest',
  Penalty: 'Penalty',
  ProcessingFee: 'ProcessingFee',
  LegalFee: 'LegalFee'
};

export type ChargeType = (typeof ChargeType)[keyof typeof ChargeType]


export const TransactionType: {
  Disbursement: 'Disbursement',
  Repayment: 'Repayment',
  Fee: 'Fee',
  Penalty: 'Penalty',
  Expense: 'Expense',
  Recovery: 'Recovery'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const ReferenceType: {
  Loan: 'Loan',
  Client: 'Client',
  Investor: 'Investor',
  Expense: 'Expense'
};

export type ReferenceType = (typeof ReferenceType)[keyof typeof ReferenceType]


export const TransactionStatus: {
  Pending: 'Pending',
  Completed: 'Completed',
  Reversed: 'Reversed'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const DocumentType: {
  ID: 'ID',
  Payslip: 'Payslip',
  Statement: 'Statement',
  PassportPhoto: 'PassportPhoto',
  AppointmentLetter: 'AppointmentLetter',
  BankStatement: 'BankStatement',
  KRACertificate: 'KRACertificate',
  Other: 'Other'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const SmsPurpose: {
  Reminder: 'Reminder',
  Guarantor: 'Guarantor',
  Recovery: 'Recovery',
  Notification: 'Notification'
};

export type SmsPurpose = (typeof SmsPurpose)[keyof typeof SmsPurpose]


export const ExpenseType: {
  Ops: 'Ops',
  Recovery: 'Recovery',
  Legal: 'Legal'
};

export type ExpenseType = (typeof ExpenseType)[keyof typeof ExpenseType]


export const AccountType: {
  Asset: 'Asset',
  Liability: 'Liability',
  Equity: 'Equity',
  Income: 'Income',
  Expense: 'Expense'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const NormalBalance: {
  Debit: 'Debit',
  Credit: 'Credit'
};

export type NormalBalance = (typeof NormalBalance)[keyof typeof NormalBalance]


export const UserRole: {
  LoanOfficer: 'LoanOfficer',
  Admin: 'Admin',
  Investor: 'Investor',
  RecoveryAgent: 'RecoveryAgent',
  Client: 'Client'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type Title = $Enums.Title

export const Title: typeof $Enums.Title

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type ClientStatus = $Enums.ClientStatus

export const ClientStatus: typeof $Enums.ClientStatus

export type EmploymentType = $Enums.EmploymentType

export const EmploymentType: typeof $Enums.EmploymentType

export type LoanApplicationStatus = $Enums.LoanApplicationStatus

export const LoanApplicationStatus: typeof $Enums.LoanApplicationStatus

export type QualificationType = $Enums.QualificationType

export const QualificationType: typeof $Enums.QualificationType

export type GuarantorStatus = $Enums.GuarantorStatus

export const GuarantorStatus: typeof $Enums.GuarantorStatus

export type DisbursementMethod = $Enums.DisbursementMethod

export const DisbursementMethod: typeof $Enums.DisbursementMethod

export type RepaymentCategory = $Enums.RepaymentCategory

export const RepaymentCategory: typeof $Enums.RepaymentCategory

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type ChargeType = $Enums.ChargeType

export const ChargeType: typeof $Enums.ChargeType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type ReferenceType = $Enums.ReferenceType

export const ReferenceType: typeof $Enums.ReferenceType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type SmsPurpose = $Enums.SmsPurpose

export const SmsPurpose: typeof $Enums.SmsPurpose

export type ExpenseType = $Enums.ExpenseType

export const ExpenseType: typeof $Enums.ExpenseType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type NormalBalance = $Enums.NormalBalance

export const NormalBalance: typeof $Enums.NormalBalance

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientAddress`: Exposes CRUD operations for the **ClientAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientAddresses
    * const clientAddresses = await prisma.clientAddress.findMany()
    * ```
    */
  get clientAddress(): Prisma.ClientAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employmentDetail`: Exposes CRUD operations for the **EmploymentDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmploymentDetails
    * const employmentDetails = await prisma.employmentDetail.findMany()
    * ```
    */
  get employmentDetail(): Prisma.EmploymentDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referee`: Exposes CRUD operations for the **Referee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referees
    * const referees = await prisma.referee.findMany()
    * ```
    */
  get referee(): Prisma.RefereeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankDetail`: Exposes CRUD operations for the **BankDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankDetails
    * const bankDetails = await prisma.bankDetail.findMany()
    * ```
    */
  get bankDetail(): Prisma.BankDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loanApplication`: Exposes CRUD operations for the **LoanApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanApplications
    * const loanApplications = await prisma.loanApplication.findMany()
    * ```
    */
  get loanApplication(): Prisma.LoanApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loanQualification`: Exposes CRUD operations for the **LoanQualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanQualifications
    * const loanQualifications = await prisma.loanQualification.findMany()
    * ```
    */
  get loanQualification(): Prisma.LoanQualificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loanSecurity`: Exposes CRUD operations for the **LoanSecurity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanSecurities
    * const loanSecurities = await prisma.loanSecurity.findMany()
    * ```
    */
  get loanSecurity(): Prisma.LoanSecurityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleSecurity`: Exposes CRUD operations for the **VehicleSecurity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleSecurities
    * const vehicleSecurities = await prisma.vehicleSecurity.findMany()
    * ```
    */
  get vehicleSecurity(): Prisma.VehicleSecurityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guarantor`: Exposes CRUD operations for the **Guarantor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guarantors
    * const guarantors = await prisma.guarantor.findMany()
    * ```
    */
  get guarantor(): Prisma.GuarantorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loanDisbursement`: Exposes CRUD operations for the **LoanDisbursement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanDisbursements
    * const loanDisbursements = await prisma.loanDisbursement.findMany()
    * ```
    */
  get loanDisbursement(): Prisma.LoanDisbursementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loanFinancial`: Exposes CRUD operations for the **LoanFinancial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanFinancials
    * const loanFinancials = await prisma.loanFinancial.findMany()
    * ```
    */
  get loanFinancial(): Prisma.LoanFinancialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoicePayment`: Exposes CRUD operations for the **InvoicePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoicePayments
    * const invoicePayments = await prisma.invoicePayment.findMany()
    * ```
    */
  get invoicePayment(): Prisma.InvoicePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.repayment`: Exposes CRUD operations for the **Repayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repayments
    * const repayments = await prisma.repayment.findMany()
    * ```
    */
  get repayment(): Prisma.RepaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nonPerformingLoan`: Exposes CRUD operations for the **NonPerformingLoan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NonPerformingLoans
    * const nonPerformingLoans = await prisma.nonPerformingLoan.findMany()
    * ```
    */
  get nonPerformingLoan(): Prisma.NonPerformingLoanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recoveryAgent`: Exposes CRUD operations for the **RecoveryAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryAgents
    * const recoveryAgents = await prisma.recoveryAgent.findMany()
    * ```
    */
  get recoveryAgent(): Prisma.RecoveryAgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recoveryRecord`: Exposes CRUD operations for the **RecoveryRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryRecords
    * const recoveryRecords = await prisma.recoveryRecord.findMany()
    * ```
    */
  get recoveryRecord(): Prisma.RecoveryRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **Investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.InvestorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investorAllocation`: Exposes CRUD operations for the **InvestorAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestorAllocations
    * const investorAllocations = await prisma.investorAllocation.findMany()
    * ```
    */
  get investorAllocation(): Prisma.InvestorAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investorPayout`: Exposes CRUD operations for the **InvestorPayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestorPayouts
    * const investorPayouts = await prisma.investorPayout.findMany()
    * ```
    */
  get investorPayout(): Prisma.InvestorPayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.smsLog`: Exposes CRUD operations for the **SmsLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmsLogs
    * const smsLogs = await prisma.smsLog.findMany()
    * ```
    */
  get smsLog(): Prisma.SmsLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chartOfAccount`: Exposes CRUD operations for the **ChartOfAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartOfAccounts
    * const chartOfAccounts = await prisma.chartOfAccount.findMany()
    * ```
    */
  get chartOfAccount(): Prisma.ChartOfAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionMatrix`: Exposes CRUD operations for the **TransactionMatrix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionMatrices
    * const transactionMatrices = await prisma.transactionMatrix.findMany()
    * ```
    */
  get transactionMatrix(): Prisma.TransactionMatrixDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    ClientAddress: 'ClientAddress',
    EmploymentDetail: 'EmploymentDetail',
    Referee: 'Referee',
    BankDetail: 'BankDetail',
    LoanApplication: 'LoanApplication',
    LoanQualification: 'LoanQualification',
    LoanSecurity: 'LoanSecurity',
    VehicleSecurity: 'VehicleSecurity',
    Guarantor: 'Guarantor',
    LoanDisbursement: 'LoanDisbursement',
    LoanFinancial: 'LoanFinancial',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    InvoicePayment: 'InvoicePayment',
    Transaction: 'Transaction',
    Repayment: 'Repayment',
    NonPerformingLoan: 'NonPerformingLoan',
    RecoveryAgent: 'RecoveryAgent',
    RecoveryRecord: 'RecoveryRecord',
    Investor: 'Investor',
    InvestorAllocation: 'InvestorAllocation',
    InvestorPayout: 'InvestorPayout',
    Document: 'Document',
    Expense: 'Expense',
    SmsLog: 'SmsLog',
    AuditLog: 'AuditLog',
    ChartOfAccount: 'ChartOfAccount',
    TransactionMatrix: 'TransactionMatrix',
    SystemConfig: 'SystemConfig',
    Session: 'Session',
    Account: 'Account',
    VerificationToken: 'VerificationToken',
    Verification: 'Verification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "client" | "clientAddress" | "employmentDetail" | "referee" | "bankDetail" | "loanApplication" | "loanQualification" | "loanSecurity" | "vehicleSecurity" | "guarantor" | "loanDisbursement" | "loanFinancial" | "invoice" | "invoiceItem" | "invoicePayment" | "transaction" | "repayment" | "nonPerformingLoan" | "recoveryAgent" | "recoveryRecord" | "investor" | "investorAllocation" | "investorPayout" | "document" | "expense" | "smsLog" | "auditLog" | "chartOfAccount" | "transactionMatrix" | "systemConfig" | "session" | "account" | "verificationToken" | "verification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientAddress: {
        payload: Prisma.$ClientAddressPayload<ExtArgs>
        fields: Prisma.ClientAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          findFirst: {
            args: Prisma.ClientAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          findMany: {
            args: Prisma.ClientAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>[]
          }
          create: {
            args: Prisma.ClientAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          createMany: {
            args: Prisma.ClientAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>[]
          }
          delete: {
            args: Prisma.ClientAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          update: {
            args: Prisma.ClientAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          deleteMany: {
            args: Prisma.ClientAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>[]
          }
          upsert: {
            args: Prisma.ClientAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          aggregate: {
            args: Prisma.ClientAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientAddress>
          }
          groupBy: {
            args: Prisma.ClientAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientAddressCountArgs<ExtArgs>
            result: $Utils.Optional<ClientAddressCountAggregateOutputType> | number
          }
        }
      }
      EmploymentDetail: {
        payload: Prisma.$EmploymentDetailPayload<ExtArgs>
        fields: Prisma.EmploymentDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmploymentDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmploymentDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>
          }
          findFirst: {
            args: Prisma.EmploymentDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmploymentDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>
          }
          findMany: {
            args: Prisma.EmploymentDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>[]
          }
          create: {
            args: Prisma.EmploymentDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>
          }
          createMany: {
            args: Prisma.EmploymentDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmploymentDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>[]
          }
          delete: {
            args: Prisma.EmploymentDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>
          }
          update: {
            args: Prisma.EmploymentDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>
          }
          deleteMany: {
            args: Prisma.EmploymentDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmploymentDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmploymentDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>[]
          }
          upsert: {
            args: Prisma.EmploymentDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailPayload>
          }
          aggregate: {
            args: Prisma.EmploymentDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploymentDetail>
          }
          groupBy: {
            args: Prisma.EmploymentDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmploymentDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmploymentDetailCountArgs<ExtArgs>
            result: $Utils.Optional<EmploymentDetailCountAggregateOutputType> | number
          }
        }
      }
      Referee: {
        payload: Prisma.$RefereePayload<ExtArgs>
        fields: Prisma.RefereeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefereeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefereeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>
          }
          findFirst: {
            args: Prisma.RefereeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefereeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>
          }
          findMany: {
            args: Prisma.RefereeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>[]
          }
          create: {
            args: Prisma.RefereeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>
          }
          createMany: {
            args: Prisma.RefereeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefereeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>[]
          }
          delete: {
            args: Prisma.RefereeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>
          }
          update: {
            args: Prisma.RefereeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>
          }
          deleteMany: {
            args: Prisma.RefereeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefereeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefereeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>[]
          }
          upsert: {
            args: Prisma.RefereeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefereePayload>
          }
          aggregate: {
            args: Prisma.RefereeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferee>
          }
          groupBy: {
            args: Prisma.RefereeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefereeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefereeCountArgs<ExtArgs>
            result: $Utils.Optional<RefereeCountAggregateOutputType> | number
          }
        }
      }
      BankDetail: {
        payload: Prisma.$BankDetailPayload<ExtArgs>
        fields: Prisma.BankDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findFirst: {
            args: Prisma.BankDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findMany: {
            args: Prisma.BankDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          create: {
            args: Prisma.BankDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          createMany: {
            args: Prisma.BankDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          delete: {
            args: Prisma.BankDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          update: {
            args: Prisma.BankDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          deleteMany: {
            args: Prisma.BankDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          upsert: {
            args: Prisma.BankDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          aggregate: {
            args: Prisma.BankDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankDetail>
          }
          groupBy: {
            args: Prisma.BankDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BankDetailCountAggregateOutputType> | number
          }
        }
      }
      LoanApplication: {
        payload: Prisma.$LoanApplicationPayload<ExtArgs>
        fields: Prisma.LoanApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          findFirst: {
            args: Prisma.LoanApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          findMany: {
            args: Prisma.LoanApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>[]
          }
          create: {
            args: Prisma.LoanApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          createMany: {
            args: Prisma.LoanApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>[]
          }
          delete: {
            args: Prisma.LoanApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          update: {
            args: Prisma.LoanApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          deleteMany: {
            args: Prisma.LoanApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>[]
          }
          upsert: {
            args: Prisma.LoanApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          aggregate: {
            args: Prisma.LoanApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanApplication>
          }
          groupBy: {
            args: Prisma.LoanApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<LoanApplicationCountAggregateOutputType> | number
          }
        }
      }
      LoanQualification: {
        payload: Prisma.$LoanQualificationPayload<ExtArgs>
        fields: Prisma.LoanQualificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanQualificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanQualificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>
          }
          findFirst: {
            args: Prisma.LoanQualificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanQualificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>
          }
          findMany: {
            args: Prisma.LoanQualificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>[]
          }
          create: {
            args: Prisma.LoanQualificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>
          }
          createMany: {
            args: Prisma.LoanQualificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanQualificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>[]
          }
          delete: {
            args: Prisma.LoanQualificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>
          }
          update: {
            args: Prisma.LoanQualificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>
          }
          deleteMany: {
            args: Prisma.LoanQualificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanQualificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanQualificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>[]
          }
          upsert: {
            args: Prisma.LoanQualificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanQualificationPayload>
          }
          aggregate: {
            args: Prisma.LoanQualificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanQualification>
          }
          groupBy: {
            args: Prisma.LoanQualificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanQualificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanQualificationCountArgs<ExtArgs>
            result: $Utils.Optional<LoanQualificationCountAggregateOutputType> | number
          }
        }
      }
      LoanSecurity: {
        payload: Prisma.$LoanSecurityPayload<ExtArgs>
        fields: Prisma.LoanSecurityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanSecurityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanSecurityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>
          }
          findFirst: {
            args: Prisma.LoanSecurityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanSecurityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>
          }
          findMany: {
            args: Prisma.LoanSecurityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>[]
          }
          create: {
            args: Prisma.LoanSecurityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>
          }
          createMany: {
            args: Prisma.LoanSecurityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanSecurityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>[]
          }
          delete: {
            args: Prisma.LoanSecurityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>
          }
          update: {
            args: Prisma.LoanSecurityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>
          }
          deleteMany: {
            args: Prisma.LoanSecurityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanSecurityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanSecurityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>[]
          }
          upsert: {
            args: Prisma.LoanSecurityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanSecurityPayload>
          }
          aggregate: {
            args: Prisma.LoanSecurityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanSecurity>
          }
          groupBy: {
            args: Prisma.LoanSecurityGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanSecurityGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanSecurityCountArgs<ExtArgs>
            result: $Utils.Optional<LoanSecurityCountAggregateOutputType> | number
          }
        }
      }
      VehicleSecurity: {
        payload: Prisma.$VehicleSecurityPayload<ExtArgs>
        fields: Prisma.VehicleSecurityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleSecurityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleSecurityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>
          }
          findFirst: {
            args: Prisma.VehicleSecurityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleSecurityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>
          }
          findMany: {
            args: Prisma.VehicleSecurityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>[]
          }
          create: {
            args: Prisma.VehicleSecurityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>
          }
          createMany: {
            args: Prisma.VehicleSecurityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleSecurityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>[]
          }
          delete: {
            args: Prisma.VehicleSecurityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>
          }
          update: {
            args: Prisma.VehicleSecurityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>
          }
          deleteMany: {
            args: Prisma.VehicleSecurityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleSecurityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleSecurityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>[]
          }
          upsert: {
            args: Prisma.VehicleSecurityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleSecurityPayload>
          }
          aggregate: {
            args: Prisma.VehicleSecurityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleSecurity>
          }
          groupBy: {
            args: Prisma.VehicleSecurityGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleSecurityGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleSecurityCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleSecurityCountAggregateOutputType> | number
          }
        }
      }
      Guarantor: {
        payload: Prisma.$GuarantorPayload<ExtArgs>
        fields: Prisma.GuarantorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuarantorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuarantorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>
          }
          findFirst: {
            args: Prisma.GuarantorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuarantorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>
          }
          findMany: {
            args: Prisma.GuarantorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>[]
          }
          create: {
            args: Prisma.GuarantorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>
          }
          createMany: {
            args: Prisma.GuarantorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuarantorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>[]
          }
          delete: {
            args: Prisma.GuarantorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>
          }
          update: {
            args: Prisma.GuarantorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>
          }
          deleteMany: {
            args: Prisma.GuarantorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuarantorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuarantorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>[]
          }
          upsert: {
            args: Prisma.GuarantorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuarantorPayload>
          }
          aggregate: {
            args: Prisma.GuarantorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuarantor>
          }
          groupBy: {
            args: Prisma.GuarantorGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuarantorGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuarantorCountArgs<ExtArgs>
            result: $Utils.Optional<GuarantorCountAggregateOutputType> | number
          }
        }
      }
      LoanDisbursement: {
        payload: Prisma.$LoanDisbursementPayload<ExtArgs>
        fields: Prisma.LoanDisbursementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanDisbursementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanDisbursementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>
          }
          findFirst: {
            args: Prisma.LoanDisbursementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanDisbursementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>
          }
          findMany: {
            args: Prisma.LoanDisbursementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>[]
          }
          create: {
            args: Prisma.LoanDisbursementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>
          }
          createMany: {
            args: Prisma.LoanDisbursementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanDisbursementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>[]
          }
          delete: {
            args: Prisma.LoanDisbursementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>
          }
          update: {
            args: Prisma.LoanDisbursementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>
          }
          deleteMany: {
            args: Prisma.LoanDisbursementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanDisbursementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanDisbursementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>[]
          }
          upsert: {
            args: Prisma.LoanDisbursementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanDisbursementPayload>
          }
          aggregate: {
            args: Prisma.LoanDisbursementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanDisbursement>
          }
          groupBy: {
            args: Prisma.LoanDisbursementGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanDisbursementGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanDisbursementCountArgs<ExtArgs>
            result: $Utils.Optional<LoanDisbursementCountAggregateOutputType> | number
          }
        }
      }
      LoanFinancial: {
        payload: Prisma.$LoanFinancialPayload<ExtArgs>
        fields: Prisma.LoanFinancialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanFinancialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanFinancialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>
          }
          findFirst: {
            args: Prisma.LoanFinancialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanFinancialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>
          }
          findMany: {
            args: Prisma.LoanFinancialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>[]
          }
          create: {
            args: Prisma.LoanFinancialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>
          }
          createMany: {
            args: Prisma.LoanFinancialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanFinancialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>[]
          }
          delete: {
            args: Prisma.LoanFinancialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>
          }
          update: {
            args: Prisma.LoanFinancialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>
          }
          deleteMany: {
            args: Prisma.LoanFinancialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanFinancialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanFinancialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>[]
          }
          upsert: {
            args: Prisma.LoanFinancialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanFinancialPayload>
          }
          aggregate: {
            args: Prisma.LoanFinancialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanFinancial>
          }
          groupBy: {
            args: Prisma.LoanFinancialGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanFinancialGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanFinancialCountArgs<ExtArgs>
            result: $Utils.Optional<LoanFinancialCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      InvoicePayment: {
        payload: Prisma.$InvoicePaymentPayload<ExtArgs>
        fields: Prisma.InvoicePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoicePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoicePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          findFirst: {
            args: Prisma.InvoicePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoicePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          findMany: {
            args: Prisma.InvoicePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          create: {
            args: Prisma.InvoicePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          createMany: {
            args: Prisma.InvoicePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoicePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          delete: {
            args: Prisma.InvoicePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          update: {
            args: Prisma.InvoicePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          deleteMany: {
            args: Prisma.InvoicePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoicePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoicePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          upsert: {
            args: Prisma.InvoicePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          aggregate: {
            args: Prisma.InvoicePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoicePayment>
          }
          groupBy: {
            args: Prisma.InvoicePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoicePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicePaymentCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Repayment: {
        payload: Prisma.$RepaymentPayload<ExtArgs>
        fields: Prisma.RepaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>
          }
          findFirst: {
            args: Prisma.RepaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>
          }
          findMany: {
            args: Prisma.RepaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>[]
          }
          create: {
            args: Prisma.RepaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>
          }
          createMany: {
            args: Prisma.RepaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>[]
          }
          delete: {
            args: Prisma.RepaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>
          }
          update: {
            args: Prisma.RepaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>
          }
          deleteMany: {
            args: Prisma.RepaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RepaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>[]
          }
          upsert: {
            args: Prisma.RepaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepaymentPayload>
          }
          aggregate: {
            args: Prisma.RepaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepayment>
          }
          groupBy: {
            args: Prisma.RepaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepaymentCountArgs<ExtArgs>
            result: $Utils.Optional<RepaymentCountAggregateOutputType> | number
          }
        }
      }
      NonPerformingLoan: {
        payload: Prisma.$NonPerformingLoanPayload<ExtArgs>
        fields: Prisma.NonPerformingLoanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NonPerformingLoanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NonPerformingLoanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>
          }
          findFirst: {
            args: Prisma.NonPerformingLoanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NonPerformingLoanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>
          }
          findMany: {
            args: Prisma.NonPerformingLoanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>[]
          }
          create: {
            args: Prisma.NonPerformingLoanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>
          }
          createMany: {
            args: Prisma.NonPerformingLoanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NonPerformingLoanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>[]
          }
          delete: {
            args: Prisma.NonPerformingLoanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>
          }
          update: {
            args: Prisma.NonPerformingLoanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>
          }
          deleteMany: {
            args: Prisma.NonPerformingLoanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NonPerformingLoanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NonPerformingLoanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>[]
          }
          upsert: {
            args: Prisma.NonPerformingLoanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonPerformingLoanPayload>
          }
          aggregate: {
            args: Prisma.NonPerformingLoanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNonPerformingLoan>
          }
          groupBy: {
            args: Prisma.NonPerformingLoanGroupByArgs<ExtArgs>
            result: $Utils.Optional<NonPerformingLoanGroupByOutputType>[]
          }
          count: {
            args: Prisma.NonPerformingLoanCountArgs<ExtArgs>
            result: $Utils.Optional<NonPerformingLoanCountAggregateOutputType> | number
          }
        }
      }
      RecoveryAgent: {
        payload: Prisma.$RecoveryAgentPayload<ExtArgs>
        fields: Prisma.RecoveryAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryAgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryAgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>
          }
          findFirst: {
            args: Prisma.RecoveryAgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryAgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>
          }
          findMany: {
            args: Prisma.RecoveryAgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>[]
          }
          create: {
            args: Prisma.RecoveryAgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>
          }
          createMany: {
            args: Prisma.RecoveryAgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecoveryAgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>[]
          }
          delete: {
            args: Prisma.RecoveryAgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>
          }
          update: {
            args: Prisma.RecoveryAgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>
          }
          deleteMany: {
            args: Prisma.RecoveryAgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryAgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecoveryAgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>[]
          }
          upsert: {
            args: Prisma.RecoveryAgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryAgentPayload>
          }
          aggregate: {
            args: Prisma.RecoveryAgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryAgent>
          }
          groupBy: {
            args: Prisma.RecoveryAgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryAgentCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryAgentCountAggregateOutputType> | number
          }
        }
      }
      RecoveryRecord: {
        payload: Prisma.$RecoveryRecordPayload<ExtArgs>
        fields: Prisma.RecoveryRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>
          }
          findFirst: {
            args: Prisma.RecoveryRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>
          }
          findMany: {
            args: Prisma.RecoveryRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>[]
          }
          create: {
            args: Prisma.RecoveryRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>
          }
          createMany: {
            args: Prisma.RecoveryRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecoveryRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>[]
          }
          delete: {
            args: Prisma.RecoveryRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>
          }
          update: {
            args: Prisma.RecoveryRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>
          }
          deleteMany: {
            args: Prisma.RecoveryRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecoveryRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>[]
          }
          upsert: {
            args: Prisma.RecoveryRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRecordPayload>
          }
          aggregate: {
            args: Prisma.RecoveryRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryRecord>
          }
          groupBy: {
            args: Prisma.RecoveryRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryRecordCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryRecordCountAggregateOutputType> | number
          }
        }
      }
      Investor: {
        payload: Prisma.$InvestorPayload<ExtArgs>
        fields: Prisma.InvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findFirst: {
            args: Prisma.InvestorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findMany: {
            args: Prisma.InvestorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          create: {
            args: Prisma.InvestorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          createMany: {
            args: Prisma.InvestorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          delete: {
            args: Prisma.InvestorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          update: {
            args: Prisma.InvestorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          deleteMany: {
            args: Prisma.InvestorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          upsert: {
            args: Prisma.InvestorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.InvestorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      InvestorAllocation: {
        payload: Prisma.$InvestorAllocationPayload<ExtArgs>
        fields: Prisma.InvestorAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>
          }
          findFirst: {
            args: Prisma.InvestorAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>
          }
          findMany: {
            args: Prisma.InvestorAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>[]
          }
          create: {
            args: Prisma.InvestorAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>
          }
          createMany: {
            args: Prisma.InvestorAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>[]
          }
          delete: {
            args: Prisma.InvestorAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>
          }
          update: {
            args: Prisma.InvestorAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>
          }
          deleteMany: {
            args: Prisma.InvestorAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestorAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>[]
          }
          upsert: {
            args: Prisma.InvestorAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorAllocationPayload>
          }
          aggregate: {
            args: Prisma.InvestorAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestorAllocation>
          }
          groupBy: {
            args: Prisma.InvestorAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorAllocationCountAggregateOutputType> | number
          }
        }
      }
      InvestorPayout: {
        payload: Prisma.$InvestorPayoutPayload<ExtArgs>
        fields: Prisma.InvestorPayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorPayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorPayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>
          }
          findFirst: {
            args: Prisma.InvestorPayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorPayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>
          }
          findMany: {
            args: Prisma.InvestorPayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>[]
          }
          create: {
            args: Prisma.InvestorPayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>
          }
          createMany: {
            args: Prisma.InvestorPayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorPayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>[]
          }
          delete: {
            args: Prisma.InvestorPayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>
          }
          update: {
            args: Prisma.InvestorPayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>
          }
          deleteMany: {
            args: Prisma.InvestorPayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorPayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestorPayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>[]
          }
          upsert: {
            args: Prisma.InvestorPayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayoutPayload>
          }
          aggregate: {
            args: Prisma.InvestorPayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestorPayout>
          }
          groupBy: {
            args: Prisma.InvestorPayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorPayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorPayoutCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorPayoutCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      SmsLog: {
        payload: Prisma.$SmsLogPayload<ExtArgs>
        fields: Prisma.SmsLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SmsLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SmsLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>
          }
          findFirst: {
            args: Prisma.SmsLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SmsLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>
          }
          findMany: {
            args: Prisma.SmsLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>[]
          }
          create: {
            args: Prisma.SmsLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>
          }
          createMany: {
            args: Prisma.SmsLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SmsLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>[]
          }
          delete: {
            args: Prisma.SmsLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>
          }
          update: {
            args: Prisma.SmsLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>
          }
          deleteMany: {
            args: Prisma.SmsLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SmsLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SmsLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>[]
          }
          upsert: {
            args: Prisma.SmsLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmsLogPayload>
          }
          aggregate: {
            args: Prisma.SmsLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSmsLog>
          }
          groupBy: {
            args: Prisma.SmsLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SmsLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SmsLogCountArgs<ExtArgs>
            result: $Utils.Optional<SmsLogCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ChartOfAccount: {
        payload: Prisma.$ChartOfAccountPayload<ExtArgs>
        fields: Prisma.ChartOfAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartOfAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartOfAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          findFirst: {
            args: Prisma.ChartOfAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartOfAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          findMany: {
            args: Prisma.ChartOfAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>[]
          }
          create: {
            args: Prisma.ChartOfAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          createMany: {
            args: Prisma.ChartOfAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartOfAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>[]
          }
          delete: {
            args: Prisma.ChartOfAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          update: {
            args: Prisma.ChartOfAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          deleteMany: {
            args: Prisma.ChartOfAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartOfAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChartOfAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>[]
          }
          upsert: {
            args: Prisma.ChartOfAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          aggregate: {
            args: Prisma.ChartOfAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartOfAccount>
          }
          groupBy: {
            args: Prisma.ChartOfAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartOfAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartOfAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ChartOfAccountCountAggregateOutputType> | number
          }
        }
      }
      TransactionMatrix: {
        payload: Prisma.$TransactionMatrixPayload<ExtArgs>
        fields: Prisma.TransactionMatrixFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionMatrixFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionMatrixFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>
          }
          findFirst: {
            args: Prisma.TransactionMatrixFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionMatrixFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>
          }
          findMany: {
            args: Prisma.TransactionMatrixFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>[]
          }
          create: {
            args: Prisma.TransactionMatrixCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>
          }
          createMany: {
            args: Prisma.TransactionMatrixCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionMatrixCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>[]
          }
          delete: {
            args: Prisma.TransactionMatrixDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>
          }
          update: {
            args: Prisma.TransactionMatrixUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>
          }
          deleteMany: {
            args: Prisma.TransactionMatrixDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionMatrixUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionMatrixUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>[]
          }
          upsert: {
            args: Prisma.TransactionMatrixUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMatrixPayload>
          }
          aggregate: {
            args: Prisma.TransactionMatrixAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionMatrix>
          }
          groupBy: {
            args: Prisma.TransactionMatrixGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionMatrixGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionMatrixCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionMatrixCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    client?: ClientOmit
    clientAddress?: ClientAddressOmit
    employmentDetail?: EmploymentDetailOmit
    referee?: RefereeOmit
    bankDetail?: BankDetailOmit
    loanApplication?: LoanApplicationOmit
    loanQualification?: LoanQualificationOmit
    loanSecurity?: LoanSecurityOmit
    vehicleSecurity?: VehicleSecurityOmit
    guarantor?: GuarantorOmit
    loanDisbursement?: LoanDisbursementOmit
    loanFinancial?: LoanFinancialOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    invoicePayment?: InvoicePaymentOmit
    transaction?: TransactionOmit
    repayment?: RepaymentOmit
    nonPerformingLoan?: NonPerformingLoanOmit
    recoveryAgent?: RecoveryAgentOmit
    recoveryRecord?: RecoveryRecordOmit
    investor?: InvestorOmit
    investorAllocation?: InvestorAllocationOmit
    investorPayout?: InvestorPayoutOmit
    document?: DocumentOmit
    expense?: ExpenseOmit
    smsLog?: SmsLogOmit
    auditLog?: AuditLogOmit
    chartOfAccount?: ChartOfAccountOmit
    transactionMatrix?: TransactionMatrixOmit
    systemConfig?: SystemConfigOmit
    session?: SessionOmit
    account?: AccountOmit
    verificationToken?: VerificationTokenOmit
    verification?: VerificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    auditLogs: number
    approvedLoans: number
    reviewedLoans: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    approvedLoans?: boolean | UserCountOutputTypeCountApprovedLoansArgs
    reviewedLoans?: boolean | UserCountOutputTypeCountReviewedLoansArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    bankDetails: number
    addresses: number
    documents: number
    employmentDetails: number
    invoices: number
    loanApplications: number
    referees: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankDetails?: boolean | ClientCountOutputTypeCountBankDetailsArgs
    addresses?: boolean | ClientCountOutputTypeCountAddressesArgs
    documents?: boolean | ClientCountOutputTypeCountDocumentsArgs
    employmentDetails?: boolean | ClientCountOutputTypeCountEmploymentDetailsArgs
    invoices?: boolean | ClientCountOutputTypeCountInvoicesArgs
    loanApplications?: boolean | ClientCountOutputTypeCountLoanApplicationsArgs
    referees?: boolean | ClientCountOutputTypeCountRefereesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountBankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankDetailWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAddressWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountEmploymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentDetailWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountLoanApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountRefereesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefereeWhereInput
  }


  /**
   * Count Type LoanApplicationCountOutputType
   */

  export type LoanApplicationCountOutputType = {
    documents: number
    guarantors: number
    investorAllocations: number
    invoices: number
    recoveryRecords: number
    repayments: number
  }

  export type LoanApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | LoanApplicationCountOutputTypeCountDocumentsArgs
    guarantors?: boolean | LoanApplicationCountOutputTypeCountGuarantorsArgs
    investorAllocations?: boolean | LoanApplicationCountOutputTypeCountInvestorAllocationsArgs
    invoices?: boolean | LoanApplicationCountOutputTypeCountInvoicesArgs
    recoveryRecords?: boolean | LoanApplicationCountOutputTypeCountRecoveryRecordsArgs
    repayments?: boolean | LoanApplicationCountOutputTypeCountRepaymentsArgs
  }

  // Custom InputTypes
  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplicationCountOutputType
     */
    select?: LoanApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeCountGuarantorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuarantorWhereInput
  }

  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeCountInvestorAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorAllocationWhereInput
  }

  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeCountRecoveryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryRecordWhereInput
  }

  /**
   * LoanApplicationCountOutputType without action
   */
  export type LoanApplicationCountOutputTypeCountRepaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepaymentWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    invoicePayments: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoicePayments?: boolean | TransactionCountOutputTypeCountInvoicePaymentsArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountInvoicePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
  }


  /**
   * Count Type RecoveryAgentCountOutputType
   */

  export type RecoveryAgentCountOutputType = {
    records: number
  }

  export type RecoveryAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | RecoveryAgentCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * RecoveryAgentCountOutputType without action
   */
  export type RecoveryAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgentCountOutputType
     */
    select?: RecoveryAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecoveryAgentCountOutputType without action
   */
  export type RecoveryAgentCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryRecordWhereInput
  }


  /**
   * Count Type InvestorCountOutputType
   */

  export type InvestorCountOutputType = {
    allocations: number
    payouts: number
  }

  export type InvestorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | InvestorCountOutputTypeCountAllocationsArgs
    payouts?: boolean | InvestorCountOutputTypeCountPayoutsArgs
  }

  // Custom InputTypes
  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorCountOutputType
     */
    select?: InvestorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorAllocationWhereInput
  }

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorPayoutWhereInput
  }


  /**
   * Count Type ChartOfAccountCountOutputType
   */

  export type ChartOfAccountCountOutputType = {
    childAccounts: number
  }

  export type ChartOfAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childAccounts?: boolean | ChartOfAccountCountOutputTypeCountChildAccountsArgs
  }

  // Custom InputTypes
  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccountCountOutputType
     */
    select?: ChartOfAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountChildAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartOfAccountWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.UserRole | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    image: string | null
    emailVerified: boolean | null
    name: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.UserRole | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    image: string | null
    emailVerified: boolean | null
    name: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    role: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    image: number
    emailVerified: number
    name: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    image?: true
    emailVerified?: true
    name?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    image?: true
    emailVerified?: true
    name?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    role?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    image?: true
    emailVerified?: true
    name?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    role: $Enums.UserRole
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    image: string | null
    emailVerified: boolean | null
    name: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean
    emailVerified?: boolean
    name?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    approvedLoans?: boolean | User$approvedLoansArgs<ExtArgs>
    reviewedLoans?: boolean | User$reviewedLoansArgs<ExtArgs>
    recoveryAgent?: boolean | User$recoveryAgentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean
    emailVerified?: boolean
    name?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean
    emailVerified?: boolean
    name?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    role?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean
    emailVerified?: boolean
    name?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "role" | "phone" | "isActive" | "createdAt" | "updatedAt" | "image" | "emailVerified" | "name", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    approvedLoans?: boolean | User$approvedLoansArgs<ExtArgs>
    reviewedLoans?: boolean | User$reviewedLoansArgs<ExtArgs>
    recoveryAgent?: boolean | User$recoveryAgentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs> | null
      investor: Prisma.$InvestorPayload<ExtArgs> | null
      approvedLoans: Prisma.$LoanApplicationPayload<ExtArgs>[]
      reviewedLoans: Prisma.$LoanApplicationPayload<ExtArgs>[]
      recoveryAgent: Prisma.$RecoveryAgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      role: $Enums.UserRole
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      image: string | null
      emailVerified: boolean | null
      name: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    investor<T extends User$investorArgs<ExtArgs> = {}>(args?: Subset<T, User$investorArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedLoans<T extends User$approvedLoansArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedLoansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedLoans<T extends User$reviewedLoansArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedLoansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recoveryAgent<T extends User$recoveryAgentArgs<ExtArgs> = {}>(args?: Subset<T, User$recoveryAgentArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly name: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.investor
   */
  export type User$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
  }

  /**
   * User.approvedLoans
   */
  export type User$approvedLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * User.reviewedLoans
   */
  export type User$reviewedLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * User.recoveryAgent
   */
  export type User$recoveryAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    where?: RecoveryAgentWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    dependents: number | null
  }

  export type ClientSumAggregateOutputType = {
    dependents: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: $Enums.Title | null
    surname: string | null
    otherNames: string | null
    dateOfBirth: Date | null
    maritalStatus: $Enums.MaritalStatus | null
    nationality: string | null
    dependents: number | null
    idPassportNo: string | null
    kraPin: string | null
    phoneWork: string | null
    phoneMobile: string | null
    phoneAlternative: string | null
    emailPersonal: string | null
    emailOfficial: string | null
    status: $Enums.ClientStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: $Enums.Title | null
    surname: string | null
    otherNames: string | null
    dateOfBirth: Date | null
    maritalStatus: $Enums.MaritalStatus | null
    nationality: string | null
    dependents: number | null
    idPassportNo: string | null
    kraPin: string | null
    phoneWork: string | null
    phoneMobile: string | null
    phoneAlternative: string | null
    emailPersonal: string | null
    emailOfficial: string | null
    status: $Enums.ClientStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    surname: number
    otherNames: number
    dateOfBirth: number
    maritalStatus: number
    nationality: number
    dependents: number
    idPassportNo: number
    kraPin: number
    phoneWork: number
    phoneMobile: number
    phoneAlternative: number
    emailPersonal: number
    emailOfficial: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    dependents?: true
  }

  export type ClientSumAggregateInputType = {
    dependents?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    surname?: true
    otherNames?: true
    dateOfBirth?: true
    maritalStatus?: true
    nationality?: true
    dependents?: true
    idPassportNo?: true
    kraPin?: true
    phoneWork?: true
    phoneMobile?: true
    phoneAlternative?: true
    emailPersonal?: true
    emailOfficial?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    surname?: true
    otherNames?: true
    dateOfBirth?: true
    maritalStatus?: true
    nationality?: true
    dependents?: true
    idPassportNo?: true
    kraPin?: true
    phoneWork?: true
    phoneMobile?: true
    phoneAlternative?: true
    emailPersonal?: true
    emailOfficial?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    surname?: true
    otherNames?: true
    dateOfBirth?: true
    maritalStatus?: true
    nationality?: true
    dependents?: true
    idPassportNo?: true
    kraPin?: true
    phoneWork?: true
    phoneMobile?: true
    phoneAlternative?: true
    emailPersonal?: true
    emailOfficial?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    userId: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents: number
    idPassportNo: string
    kraPin: string | null
    phoneWork: string | null
    phoneMobile: string
    phoneAlternative: string | null
    emailPersonal: string | null
    emailOfficial: string | null
    status: $Enums.ClientStatus
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    surname?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    dependents?: boolean
    idPassportNo?: boolean
    kraPin?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    phoneAlternative?: boolean
    emailPersonal?: boolean
    emailOfficial?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankDetails?: boolean | Client$bankDetailsArgs<ExtArgs>
    addresses?: boolean | Client$addressesArgs<ExtArgs>
    user?: boolean | Client$userArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    employmentDetails?: boolean | Client$employmentDetailsArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    loanApplications?: boolean | Client$loanApplicationsArgs<ExtArgs>
    referees?: boolean | Client$refereesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    surname?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    dependents?: boolean
    idPassportNo?: boolean
    kraPin?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    phoneAlternative?: boolean
    emailPersonal?: boolean
    emailOfficial?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Client$userArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    surname?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    dependents?: boolean
    idPassportNo?: boolean
    kraPin?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    phoneAlternative?: boolean
    emailPersonal?: boolean
    emailOfficial?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Client$userArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    surname?: boolean
    otherNames?: boolean
    dateOfBirth?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    dependents?: boolean
    idPassportNo?: boolean
    kraPin?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    phoneAlternative?: boolean
    emailPersonal?: boolean
    emailOfficial?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "surname" | "otherNames" | "dateOfBirth" | "maritalStatus" | "nationality" | "dependents" | "idPassportNo" | "kraPin" | "phoneWork" | "phoneMobile" | "phoneAlternative" | "emailPersonal" | "emailOfficial" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankDetails?: boolean | Client$bankDetailsArgs<ExtArgs>
    addresses?: boolean | Client$addressesArgs<ExtArgs>
    user?: boolean | Client$userArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    employmentDetails?: boolean | Client$employmentDetailsArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    loanApplications?: boolean | Client$loanApplicationsArgs<ExtArgs>
    referees?: boolean | Client$refereesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Client$userArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Client$userArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      bankDetails: Prisma.$BankDetailPayload<ExtArgs>[]
      addresses: Prisma.$ClientAddressPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      employmentDetails: Prisma.$EmploymentDetailPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      loanApplications: Prisma.$LoanApplicationPayload<ExtArgs>[]
      referees: Prisma.$RefereePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      title: $Enums.Title
      surname: string
      otherNames: string
      dateOfBirth: Date
      maritalStatus: $Enums.MaritalStatus
      nationality: string
      dependents: number
      idPassportNo: string
      kraPin: string | null
      phoneWork: string | null
      phoneMobile: string
      phoneAlternative: string | null
      emailPersonal: string | null
      emailOfficial: string | null
      status: $Enums.ClientStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bankDetails<T extends Client$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Client$bankDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends Client$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Client$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Client$userArgs<ExtArgs> = {}>(args?: Subset<T, Client$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Client$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employmentDetails<T extends Client$employmentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Client$employmentDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Client$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Client$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loanApplications<T extends Client$loanApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Client$loanApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referees<T extends Client$refereesArgs<ExtArgs> = {}>(args?: Subset<T, Client$refereesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly userId: FieldRef<"Client", 'String'>
    readonly title: FieldRef<"Client", 'Title'>
    readonly surname: FieldRef<"Client", 'String'>
    readonly otherNames: FieldRef<"Client", 'String'>
    readonly dateOfBirth: FieldRef<"Client", 'DateTime'>
    readonly maritalStatus: FieldRef<"Client", 'MaritalStatus'>
    readonly nationality: FieldRef<"Client", 'String'>
    readonly dependents: FieldRef<"Client", 'Int'>
    readonly idPassportNo: FieldRef<"Client", 'String'>
    readonly kraPin: FieldRef<"Client", 'String'>
    readonly phoneWork: FieldRef<"Client", 'String'>
    readonly phoneMobile: FieldRef<"Client", 'String'>
    readonly phoneAlternative: FieldRef<"Client", 'String'>
    readonly emailPersonal: FieldRef<"Client", 'String'>
    readonly emailOfficial: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'ClientStatus'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.bankDetails
   */
  export type Client$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    where?: BankDetailWhereInput
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    cursor?: BankDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * Client.addresses
   */
  export type Client$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    where?: ClientAddressWhereInput
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    cursor?: ClientAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * Client.user
   */
  export type Client$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Client.documents
   */
  export type Client$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Client.employmentDetails
   */
  export type Client$employmentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    where?: EmploymentDetailWhereInput
    orderBy?: EmploymentDetailOrderByWithRelationInput | EmploymentDetailOrderByWithRelationInput[]
    cursor?: EmploymentDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentDetailScalarFieldEnum | EmploymentDetailScalarFieldEnum[]
  }

  /**
   * Client.invoices
   */
  export type Client$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Client.loanApplications
   */
  export type Client$loanApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * Client.referees
   */
  export type Client$refereesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    where?: RefereeWhereInput
    orderBy?: RefereeOrderByWithRelationInput | RefereeOrderByWithRelationInput[]
    cursor?: RefereeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefereeScalarFieldEnum | RefereeScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientAddress
   */

  export type AggregateClientAddress = {
    _count: ClientAddressCountAggregateOutputType | null
    _min: ClientAddressMinAggregateOutputType | null
    _max: ClientAddressMaxAggregateOutputType | null
  }

  export type ClientAddressMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    postalAddress: string | null
    postalCode: string | null
    townCity: string | null
    residentialAddress: string | null
    location: string | null
    estate: string | null
    building: string | null
    houseNumber: string | null
    landmark: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientAddressMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    postalAddress: string | null
    postalCode: string | null
    townCity: string | null
    residentialAddress: string | null
    location: string | null
    estate: string | null
    building: string | null
    houseNumber: string | null
    landmark: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientAddressCountAggregateOutputType = {
    id: number
    clientId: number
    postalAddress: number
    postalCode: number
    townCity: number
    residentialAddress: number
    location: number
    estate: number
    building: number
    houseNumber: number
    landmark: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAddressMinAggregateInputType = {
    id?: true
    clientId?: true
    postalAddress?: true
    postalCode?: true
    townCity?: true
    residentialAddress?: true
    location?: true
    estate?: true
    building?: true
    houseNumber?: true
    landmark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientAddressMaxAggregateInputType = {
    id?: true
    clientId?: true
    postalAddress?: true
    postalCode?: true
    townCity?: true
    residentialAddress?: true
    location?: true
    estate?: true
    building?: true
    houseNumber?: true
    landmark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientAddressCountAggregateInputType = {
    id?: true
    clientId?: true
    postalAddress?: true
    postalCode?: true
    townCity?: true
    residentialAddress?: true
    location?: true
    estate?: true
    building?: true
    houseNumber?: true
    landmark?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAddress to aggregate.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientAddresses
    **/
    _count?: true | ClientAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientAddressMaxAggregateInputType
  }

  export type GetClientAddressAggregateType<T extends ClientAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateClientAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientAddress[P]>
      : GetScalarType<T[P], AggregateClientAddress[P]>
  }




  export type ClientAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAddressWhereInput
    orderBy?: ClientAddressOrderByWithAggregationInput | ClientAddressOrderByWithAggregationInput[]
    by: ClientAddressScalarFieldEnum[] | ClientAddressScalarFieldEnum
    having?: ClientAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientAddressCountAggregateInputType | true
    _min?: ClientAddressMinAggregateInputType
    _max?: ClientAddressMaxAggregateInputType
  }

  export type ClientAddressGroupByOutputType = {
    id: string
    clientId: string
    postalAddress: string | null
    postalCode: string | null
    townCity: string | null
    residentialAddress: string | null
    location: string | null
    estate: string | null
    building: string | null
    houseNumber: string | null
    landmark: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientAddressCountAggregateOutputType | null
    _min: ClientAddressMinAggregateOutputType | null
    _max: ClientAddressMaxAggregateOutputType | null
  }

  type GetClientAddressGroupByPayload<T extends ClientAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientAddressGroupByOutputType[P]>
            : GetScalarType<T[P], ClientAddressGroupByOutputType[P]>
        }
      >
    >


  export type ClientAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    townCity?: boolean
    residentialAddress?: boolean
    location?: boolean
    estate?: boolean
    building?: boolean
    houseNumber?: boolean
    landmark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAddress"]>

  export type ClientAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    townCity?: boolean
    residentialAddress?: boolean
    location?: boolean
    estate?: boolean
    building?: boolean
    houseNumber?: boolean
    landmark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAddress"]>

  export type ClientAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    townCity?: boolean
    residentialAddress?: boolean
    location?: boolean
    estate?: boolean
    building?: boolean
    houseNumber?: boolean
    landmark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAddress"]>

  export type ClientAddressSelectScalar = {
    id?: boolean
    clientId?: boolean
    postalAddress?: boolean
    postalCode?: boolean
    townCity?: boolean
    residentialAddress?: boolean
    location?: boolean
    estate?: boolean
    building?: boolean
    houseNumber?: boolean
    landmark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "postalAddress" | "postalCode" | "townCity" | "residentialAddress" | "location" | "estate" | "building" | "houseNumber" | "landmark" | "createdAt" | "updatedAt", ExtArgs["result"]["clientAddress"]>
  export type ClientAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientAddress"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      postalAddress: string | null
      postalCode: string | null
      townCity: string | null
      residentialAddress: string | null
      location: string | null
      estate: string | null
      building: string | null
      houseNumber: string | null
      landmark: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientAddress"]>
    composites: {}
  }

  type ClientAddressGetPayload<S extends boolean | null | undefined | ClientAddressDefaultArgs> = $Result.GetResult<Prisma.$ClientAddressPayload, S>

  type ClientAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientAddressCountAggregateInputType | true
    }

  export interface ClientAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientAddress'], meta: { name: 'ClientAddress' } }
    /**
     * Find zero or one ClientAddress that matches the filter.
     * @param {ClientAddressFindUniqueArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientAddressFindUniqueArgs>(args: SelectSubset<T, ClientAddressFindUniqueArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientAddressFindUniqueOrThrowArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressFindFirstArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientAddressFindFirstArgs>(args?: SelectSubset<T, ClientAddressFindFirstArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressFindFirstOrThrowArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientAddresses
     * const clientAddresses = await prisma.clientAddress.findMany()
     * 
     * // Get first 10 ClientAddresses
     * const clientAddresses = await prisma.clientAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientAddressWithIdOnly = await prisma.clientAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientAddressFindManyArgs>(args?: SelectSubset<T, ClientAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientAddress.
     * @param {ClientAddressCreateArgs} args - Arguments to create a ClientAddress.
     * @example
     * // Create one ClientAddress
     * const ClientAddress = await prisma.clientAddress.create({
     *   data: {
     *     // ... data to create a ClientAddress
     *   }
     * })
     * 
     */
    create<T extends ClientAddressCreateArgs>(args: SelectSubset<T, ClientAddressCreateArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientAddresses.
     * @param {ClientAddressCreateManyArgs} args - Arguments to create many ClientAddresses.
     * @example
     * // Create many ClientAddresses
     * const clientAddress = await prisma.clientAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientAddressCreateManyArgs>(args?: SelectSubset<T, ClientAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientAddresses and returns the data saved in the database.
     * @param {ClientAddressCreateManyAndReturnArgs} args - Arguments to create many ClientAddresses.
     * @example
     * // Create many ClientAddresses
     * const clientAddress = await prisma.clientAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientAddresses and only return the `id`
     * const clientAddressWithIdOnly = await prisma.clientAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientAddress.
     * @param {ClientAddressDeleteArgs} args - Arguments to delete one ClientAddress.
     * @example
     * // Delete one ClientAddress
     * const ClientAddress = await prisma.clientAddress.delete({
     *   where: {
     *     // ... filter to delete one ClientAddress
     *   }
     * })
     * 
     */
    delete<T extends ClientAddressDeleteArgs>(args: SelectSubset<T, ClientAddressDeleteArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientAddress.
     * @param {ClientAddressUpdateArgs} args - Arguments to update one ClientAddress.
     * @example
     * // Update one ClientAddress
     * const clientAddress = await prisma.clientAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientAddressUpdateArgs>(args: SelectSubset<T, ClientAddressUpdateArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientAddresses.
     * @param {ClientAddressDeleteManyArgs} args - Arguments to filter ClientAddresses to delete.
     * @example
     * // Delete a few ClientAddresses
     * const { count } = await prisma.clientAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientAddressDeleteManyArgs>(args?: SelectSubset<T, ClientAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientAddresses
     * const clientAddress = await prisma.clientAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientAddressUpdateManyArgs>(args: SelectSubset<T, ClientAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAddresses and returns the data updated in the database.
     * @param {ClientAddressUpdateManyAndReturnArgs} args - Arguments to update many ClientAddresses.
     * @example
     * // Update many ClientAddresses
     * const clientAddress = await prisma.clientAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientAddresses and only return the `id`
     * const clientAddressWithIdOnly = await prisma.clientAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientAddress.
     * @param {ClientAddressUpsertArgs} args - Arguments to update or create a ClientAddress.
     * @example
     * // Update or create a ClientAddress
     * const clientAddress = await prisma.clientAddress.upsert({
     *   create: {
     *     // ... data to create a ClientAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientAddress we want to update
     *   }
     * })
     */
    upsert<T extends ClientAddressUpsertArgs>(args: SelectSubset<T, ClientAddressUpsertArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressCountArgs} args - Arguments to filter ClientAddresses to count.
     * @example
     * // Count the number of ClientAddresses
     * const count = await prisma.clientAddress.count({
     *   where: {
     *     // ... the filter for the ClientAddresses we want to count
     *   }
     * })
    **/
    count<T extends ClientAddressCountArgs>(
      args?: Subset<T, ClientAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAddressAggregateArgs>(args: Subset<T, ClientAddressAggregateArgs>): Prisma.PrismaPromise<GetClientAddressAggregateType<T>>

    /**
     * Group by ClientAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientAddressGroupByArgs['orderBy'] }
        : { orderBy?: ClientAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientAddress model
   */
  readonly fields: ClientAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientAddress model
   */
  interface ClientAddressFieldRefs {
    readonly id: FieldRef<"ClientAddress", 'String'>
    readonly clientId: FieldRef<"ClientAddress", 'String'>
    readonly postalAddress: FieldRef<"ClientAddress", 'String'>
    readonly postalCode: FieldRef<"ClientAddress", 'String'>
    readonly townCity: FieldRef<"ClientAddress", 'String'>
    readonly residentialAddress: FieldRef<"ClientAddress", 'String'>
    readonly location: FieldRef<"ClientAddress", 'String'>
    readonly estate: FieldRef<"ClientAddress", 'String'>
    readonly building: FieldRef<"ClientAddress", 'String'>
    readonly houseNumber: FieldRef<"ClientAddress", 'String'>
    readonly landmark: FieldRef<"ClientAddress", 'String'>
    readonly createdAt: FieldRef<"ClientAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientAddress findUnique
   */
  export type ClientAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress findUniqueOrThrow
   */
  export type ClientAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress findFirst
   */
  export type ClientAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAddresses.
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAddresses.
     */
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * ClientAddress findFirstOrThrow
   */
  export type ClientAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAddresses.
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAddresses.
     */
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * ClientAddress findMany
   */
  export type ClientAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddresses to fetch.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientAddresses.
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * ClientAddress create
   */
  export type ClientAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientAddress.
     */
    data: XOR<ClientAddressCreateInput, ClientAddressUncheckedCreateInput>
  }

  /**
   * ClientAddress createMany
   */
  export type ClientAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientAddresses.
     */
    data: ClientAddressCreateManyInput | ClientAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientAddress createManyAndReturn
   */
  export type ClientAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * The data used to create many ClientAddresses.
     */
    data: ClientAddressCreateManyInput | ClientAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientAddress update
   */
  export type ClientAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientAddress.
     */
    data: XOR<ClientAddressUpdateInput, ClientAddressUncheckedUpdateInput>
    /**
     * Choose, which ClientAddress to update.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress updateMany
   */
  export type ClientAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientAddresses.
     */
    data: XOR<ClientAddressUpdateManyMutationInput, ClientAddressUncheckedUpdateManyInput>
    /**
     * Filter which ClientAddresses to update
     */
    where?: ClientAddressWhereInput
    /**
     * Limit how many ClientAddresses to update.
     */
    limit?: number
  }

  /**
   * ClientAddress updateManyAndReturn
   */
  export type ClientAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * The data used to update ClientAddresses.
     */
    data: XOR<ClientAddressUpdateManyMutationInput, ClientAddressUncheckedUpdateManyInput>
    /**
     * Filter which ClientAddresses to update
     */
    where?: ClientAddressWhereInput
    /**
     * Limit how many ClientAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientAddress upsert
   */
  export type ClientAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientAddress to update in case it exists.
     */
    where: ClientAddressWhereUniqueInput
    /**
     * In case the ClientAddress found by the `where` argument doesn't exist, create a new ClientAddress with this data.
     */
    create: XOR<ClientAddressCreateInput, ClientAddressUncheckedCreateInput>
    /**
     * In case the ClientAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientAddressUpdateInput, ClientAddressUncheckedUpdateInput>
  }

  /**
   * ClientAddress delete
   */
  export type ClientAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter which ClientAddress to delete.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress deleteMany
   */
  export type ClientAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAddresses to delete
     */
    where?: ClientAddressWhereInput
    /**
     * Limit how many ClientAddresses to delete.
     */
    limit?: number
  }

  /**
   * ClientAddress without action
   */
  export type ClientAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
  }


  /**
   * Model EmploymentDetail
   */

  export type AggregateEmploymentDetail = {
    _count: EmploymentDetailCountAggregateOutputType | null
    _avg: EmploymentDetailAvgAggregateOutputType | null
    _sum: EmploymentDetailSumAggregateOutputType | null
    _min: EmploymentDetailMinAggregateOutputType | null
    _max: EmploymentDetailMaxAggregateOutputType | null
  }

  export type EmploymentDetailAvgAggregateOutputType = {
    netSalary: Decimal | null
  }

  export type EmploymentDetailSumAggregateOutputType = {
    netSalary: Decimal | null
  }

  export type EmploymentDetailMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    employerName: string | null
    jobTitle: string | null
    department: string | null
    dateJoined: Date | null
    periodWorked: string | null
    employmentType: $Enums.EmploymentType | null
    contractExpiry: Date | null
    onNotice: boolean | null
    netSalary: Decimal | null
    branchLocation: string | null
    roadStreet: string | null
    building: string | null
    floorOffice: string | null
    telephone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmploymentDetailMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    employerName: string | null
    jobTitle: string | null
    department: string | null
    dateJoined: Date | null
    periodWorked: string | null
    employmentType: $Enums.EmploymentType | null
    contractExpiry: Date | null
    onNotice: boolean | null
    netSalary: Decimal | null
    branchLocation: string | null
    roadStreet: string | null
    building: string | null
    floorOffice: string | null
    telephone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmploymentDetailCountAggregateOutputType = {
    id: number
    clientId: number
    employerName: number
    jobTitle: number
    department: number
    dateJoined: number
    periodWorked: number
    employmentType: number
    contractExpiry: number
    onNotice: number
    netSalary: number
    branchLocation: number
    roadStreet: number
    building: number
    floorOffice: number
    telephone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmploymentDetailAvgAggregateInputType = {
    netSalary?: true
  }

  export type EmploymentDetailSumAggregateInputType = {
    netSalary?: true
  }

  export type EmploymentDetailMinAggregateInputType = {
    id?: true
    clientId?: true
    employerName?: true
    jobTitle?: true
    department?: true
    dateJoined?: true
    periodWorked?: true
    employmentType?: true
    contractExpiry?: true
    onNotice?: true
    netSalary?: true
    branchLocation?: true
    roadStreet?: true
    building?: true
    floorOffice?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmploymentDetailMaxAggregateInputType = {
    id?: true
    clientId?: true
    employerName?: true
    jobTitle?: true
    department?: true
    dateJoined?: true
    periodWorked?: true
    employmentType?: true
    contractExpiry?: true
    onNotice?: true
    netSalary?: true
    branchLocation?: true
    roadStreet?: true
    building?: true
    floorOffice?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmploymentDetailCountAggregateInputType = {
    id?: true
    clientId?: true
    employerName?: true
    jobTitle?: true
    department?: true
    dateJoined?: true
    periodWorked?: true
    employmentType?: true
    contractExpiry?: true
    onNotice?: true
    netSalary?: true
    branchLocation?: true
    roadStreet?: true
    building?: true
    floorOffice?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmploymentDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentDetail to aggregate.
     */
    where?: EmploymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailOrderByWithRelationInput | EmploymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmploymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmploymentDetails
    **/
    _count?: true | EmploymentDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploymentDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploymentDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymentDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymentDetailMaxAggregateInputType
  }

  export type GetEmploymentDetailAggregateType<T extends EmploymentDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploymentDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploymentDetail[P]>
      : GetScalarType<T[P], AggregateEmploymentDetail[P]>
  }




  export type EmploymentDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentDetailWhereInput
    orderBy?: EmploymentDetailOrderByWithAggregationInput | EmploymentDetailOrderByWithAggregationInput[]
    by: EmploymentDetailScalarFieldEnum[] | EmploymentDetailScalarFieldEnum
    having?: EmploymentDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymentDetailCountAggregateInputType | true
    _avg?: EmploymentDetailAvgAggregateInputType
    _sum?: EmploymentDetailSumAggregateInputType
    _min?: EmploymentDetailMinAggregateInputType
    _max?: EmploymentDetailMaxAggregateInputType
  }

  export type EmploymentDetailGroupByOutputType = {
    id: string
    clientId: string
    employerName: string
    jobTitle: string
    department: string | null
    dateJoined: Date | null
    periodWorked: string | null
    employmentType: $Enums.EmploymentType
    contractExpiry: Date | null
    onNotice: boolean
    netSalary: Decimal
    branchLocation: string | null
    roadStreet: string | null
    building: string | null
    floorOffice: string | null
    telephone: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmploymentDetailCountAggregateOutputType | null
    _avg: EmploymentDetailAvgAggregateOutputType | null
    _sum: EmploymentDetailSumAggregateOutputType | null
    _min: EmploymentDetailMinAggregateOutputType | null
    _max: EmploymentDetailMaxAggregateOutputType | null
  }

  type GetEmploymentDetailGroupByPayload<T extends EmploymentDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymentDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymentDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymentDetailGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymentDetailGroupByOutputType[P]>
        }
      >
    >


  export type EmploymentDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    employerName?: boolean
    jobTitle?: boolean
    department?: boolean
    dateJoined?: boolean
    periodWorked?: boolean
    employmentType?: boolean
    contractExpiry?: boolean
    onNotice?: boolean
    netSalary?: boolean
    branchLocation?: boolean
    roadStreet?: boolean
    building?: boolean
    floorOffice?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentDetail"]>

  export type EmploymentDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    employerName?: boolean
    jobTitle?: boolean
    department?: boolean
    dateJoined?: boolean
    periodWorked?: boolean
    employmentType?: boolean
    contractExpiry?: boolean
    onNotice?: boolean
    netSalary?: boolean
    branchLocation?: boolean
    roadStreet?: boolean
    building?: boolean
    floorOffice?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentDetail"]>

  export type EmploymentDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    employerName?: boolean
    jobTitle?: boolean
    department?: boolean
    dateJoined?: boolean
    periodWorked?: boolean
    employmentType?: boolean
    contractExpiry?: boolean
    onNotice?: boolean
    netSalary?: boolean
    branchLocation?: boolean
    roadStreet?: boolean
    building?: boolean
    floorOffice?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentDetail"]>

  export type EmploymentDetailSelectScalar = {
    id?: boolean
    clientId?: boolean
    employerName?: boolean
    jobTitle?: boolean
    department?: boolean
    dateJoined?: boolean
    periodWorked?: boolean
    employmentType?: boolean
    contractExpiry?: boolean
    onNotice?: boolean
    netSalary?: boolean
    branchLocation?: boolean
    roadStreet?: boolean
    building?: boolean
    floorOffice?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmploymentDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "employerName" | "jobTitle" | "department" | "dateJoined" | "periodWorked" | "employmentType" | "contractExpiry" | "onNotice" | "netSalary" | "branchLocation" | "roadStreet" | "building" | "floorOffice" | "telephone" | "createdAt" | "updatedAt", ExtArgs["result"]["employmentDetail"]>
  export type EmploymentDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type EmploymentDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type EmploymentDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $EmploymentDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmploymentDetail"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      employerName: string
      jobTitle: string
      department: string | null
      dateJoined: Date | null
      periodWorked: string | null
      employmentType: $Enums.EmploymentType
      contractExpiry: Date | null
      onNotice: boolean
      netSalary: Prisma.Decimal
      branchLocation: string | null
      roadStreet: string | null
      building: string | null
      floorOffice: string | null
      telephone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employmentDetail"]>
    composites: {}
  }

  type EmploymentDetailGetPayload<S extends boolean | null | undefined | EmploymentDetailDefaultArgs> = $Result.GetResult<Prisma.$EmploymentDetailPayload, S>

  type EmploymentDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmploymentDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmploymentDetailCountAggregateInputType | true
    }

  export interface EmploymentDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmploymentDetail'], meta: { name: 'EmploymentDetail' } }
    /**
     * Find zero or one EmploymentDetail that matches the filter.
     * @param {EmploymentDetailFindUniqueArgs} args - Arguments to find a EmploymentDetail
     * @example
     * // Get one EmploymentDetail
     * const employmentDetail = await prisma.employmentDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmploymentDetailFindUniqueArgs>(args: SelectSubset<T, EmploymentDetailFindUniqueArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmploymentDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmploymentDetailFindUniqueOrThrowArgs} args - Arguments to find a EmploymentDetail
     * @example
     * // Get one EmploymentDetail
     * const employmentDetail = await prisma.employmentDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmploymentDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, EmploymentDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailFindFirstArgs} args - Arguments to find a EmploymentDetail
     * @example
     * // Get one EmploymentDetail
     * const employmentDetail = await prisma.employmentDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmploymentDetailFindFirstArgs>(args?: SelectSubset<T, EmploymentDetailFindFirstArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailFindFirstOrThrowArgs} args - Arguments to find a EmploymentDetail
     * @example
     * // Get one EmploymentDetail
     * const employmentDetail = await prisma.employmentDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmploymentDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, EmploymentDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmploymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmploymentDetails
     * const employmentDetails = await prisma.employmentDetail.findMany()
     * 
     * // Get first 10 EmploymentDetails
     * const employmentDetails = await prisma.employmentDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employmentDetailWithIdOnly = await prisma.employmentDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmploymentDetailFindManyArgs>(args?: SelectSubset<T, EmploymentDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmploymentDetail.
     * @param {EmploymentDetailCreateArgs} args - Arguments to create a EmploymentDetail.
     * @example
     * // Create one EmploymentDetail
     * const EmploymentDetail = await prisma.employmentDetail.create({
     *   data: {
     *     // ... data to create a EmploymentDetail
     *   }
     * })
     * 
     */
    create<T extends EmploymentDetailCreateArgs>(args: SelectSubset<T, EmploymentDetailCreateArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmploymentDetails.
     * @param {EmploymentDetailCreateManyArgs} args - Arguments to create many EmploymentDetails.
     * @example
     * // Create many EmploymentDetails
     * const employmentDetail = await prisma.employmentDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmploymentDetailCreateManyArgs>(args?: SelectSubset<T, EmploymentDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmploymentDetails and returns the data saved in the database.
     * @param {EmploymentDetailCreateManyAndReturnArgs} args - Arguments to create many EmploymentDetails.
     * @example
     * // Create many EmploymentDetails
     * const employmentDetail = await prisma.employmentDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmploymentDetails and only return the `id`
     * const employmentDetailWithIdOnly = await prisma.employmentDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmploymentDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, EmploymentDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmploymentDetail.
     * @param {EmploymentDetailDeleteArgs} args - Arguments to delete one EmploymentDetail.
     * @example
     * // Delete one EmploymentDetail
     * const EmploymentDetail = await prisma.employmentDetail.delete({
     *   where: {
     *     // ... filter to delete one EmploymentDetail
     *   }
     * })
     * 
     */
    delete<T extends EmploymentDetailDeleteArgs>(args: SelectSubset<T, EmploymentDetailDeleteArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmploymentDetail.
     * @param {EmploymentDetailUpdateArgs} args - Arguments to update one EmploymentDetail.
     * @example
     * // Update one EmploymentDetail
     * const employmentDetail = await prisma.employmentDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmploymentDetailUpdateArgs>(args: SelectSubset<T, EmploymentDetailUpdateArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmploymentDetails.
     * @param {EmploymentDetailDeleteManyArgs} args - Arguments to filter EmploymentDetails to delete.
     * @example
     * // Delete a few EmploymentDetails
     * const { count } = await prisma.employmentDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmploymentDetailDeleteManyArgs>(args?: SelectSubset<T, EmploymentDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmploymentDetails
     * const employmentDetail = await prisma.employmentDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmploymentDetailUpdateManyArgs>(args: SelectSubset<T, EmploymentDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentDetails and returns the data updated in the database.
     * @param {EmploymentDetailUpdateManyAndReturnArgs} args - Arguments to update many EmploymentDetails.
     * @example
     * // Update many EmploymentDetails
     * const employmentDetail = await prisma.employmentDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmploymentDetails and only return the `id`
     * const employmentDetailWithIdOnly = await prisma.employmentDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmploymentDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, EmploymentDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmploymentDetail.
     * @param {EmploymentDetailUpsertArgs} args - Arguments to update or create a EmploymentDetail.
     * @example
     * // Update or create a EmploymentDetail
     * const employmentDetail = await prisma.employmentDetail.upsert({
     *   create: {
     *     // ... data to create a EmploymentDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmploymentDetail we want to update
     *   }
     * })
     */
    upsert<T extends EmploymentDetailUpsertArgs>(args: SelectSubset<T, EmploymentDetailUpsertArgs<ExtArgs>>): Prisma__EmploymentDetailClient<$Result.GetResult<Prisma.$EmploymentDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailCountArgs} args - Arguments to filter EmploymentDetails to count.
     * @example
     * // Count the number of EmploymentDetails
     * const count = await prisma.employmentDetail.count({
     *   where: {
     *     // ... the filter for the EmploymentDetails we want to count
     *   }
     * })
    **/
    count<T extends EmploymentDetailCountArgs>(
      args?: Subset<T, EmploymentDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymentDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmploymentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymentDetailAggregateArgs>(args: Subset<T, EmploymentDetailAggregateArgs>): Prisma.PrismaPromise<GetEmploymentDetailAggregateType<T>>

    /**
     * Group by EmploymentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmploymentDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmploymentDetailGroupByArgs['orderBy'] }
        : { orderBy?: EmploymentDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmploymentDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymentDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmploymentDetail model
   */
  readonly fields: EmploymentDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmploymentDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmploymentDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmploymentDetail model
   */
  interface EmploymentDetailFieldRefs {
    readonly id: FieldRef<"EmploymentDetail", 'String'>
    readonly clientId: FieldRef<"EmploymentDetail", 'String'>
    readonly employerName: FieldRef<"EmploymentDetail", 'String'>
    readonly jobTitle: FieldRef<"EmploymentDetail", 'String'>
    readonly department: FieldRef<"EmploymentDetail", 'String'>
    readonly dateJoined: FieldRef<"EmploymentDetail", 'DateTime'>
    readonly periodWorked: FieldRef<"EmploymentDetail", 'String'>
    readonly employmentType: FieldRef<"EmploymentDetail", 'EmploymentType'>
    readonly contractExpiry: FieldRef<"EmploymentDetail", 'DateTime'>
    readonly onNotice: FieldRef<"EmploymentDetail", 'Boolean'>
    readonly netSalary: FieldRef<"EmploymentDetail", 'Decimal'>
    readonly branchLocation: FieldRef<"EmploymentDetail", 'String'>
    readonly roadStreet: FieldRef<"EmploymentDetail", 'String'>
    readonly building: FieldRef<"EmploymentDetail", 'String'>
    readonly floorOffice: FieldRef<"EmploymentDetail", 'String'>
    readonly telephone: FieldRef<"EmploymentDetail", 'String'>
    readonly createdAt: FieldRef<"EmploymentDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"EmploymentDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmploymentDetail findUnique
   */
  export type EmploymentDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetail to fetch.
     */
    where: EmploymentDetailWhereUniqueInput
  }

  /**
   * EmploymentDetail findUniqueOrThrow
   */
  export type EmploymentDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetail to fetch.
     */
    where: EmploymentDetailWhereUniqueInput
  }

  /**
   * EmploymentDetail findFirst
   */
  export type EmploymentDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetail to fetch.
     */
    where?: EmploymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailOrderByWithRelationInput | EmploymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentDetails.
     */
    cursor?: EmploymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentDetails.
     */
    distinct?: EmploymentDetailScalarFieldEnum | EmploymentDetailScalarFieldEnum[]
  }

  /**
   * EmploymentDetail findFirstOrThrow
   */
  export type EmploymentDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetail to fetch.
     */
    where?: EmploymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailOrderByWithRelationInput | EmploymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentDetails.
     */
    cursor?: EmploymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentDetails.
     */
    distinct?: EmploymentDetailScalarFieldEnum | EmploymentDetailScalarFieldEnum[]
  }

  /**
   * EmploymentDetail findMany
   */
  export type EmploymentDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where?: EmploymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailOrderByWithRelationInput | EmploymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmploymentDetails.
     */
    cursor?: EmploymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    distinct?: EmploymentDetailScalarFieldEnum | EmploymentDetailScalarFieldEnum[]
  }

  /**
   * EmploymentDetail create
   */
  export type EmploymentDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a EmploymentDetail.
     */
    data: XOR<EmploymentDetailCreateInput, EmploymentDetailUncheckedCreateInput>
  }

  /**
   * EmploymentDetail createMany
   */
  export type EmploymentDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmploymentDetails.
     */
    data: EmploymentDetailCreateManyInput | EmploymentDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmploymentDetail createManyAndReturn
   */
  export type EmploymentDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * The data used to create many EmploymentDetails.
     */
    data: EmploymentDetailCreateManyInput | EmploymentDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmploymentDetail update
   */
  export type EmploymentDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a EmploymentDetail.
     */
    data: XOR<EmploymentDetailUpdateInput, EmploymentDetailUncheckedUpdateInput>
    /**
     * Choose, which EmploymentDetail to update.
     */
    where: EmploymentDetailWhereUniqueInput
  }

  /**
   * EmploymentDetail updateMany
   */
  export type EmploymentDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmploymentDetails.
     */
    data: XOR<EmploymentDetailUpdateManyMutationInput, EmploymentDetailUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentDetails to update
     */
    where?: EmploymentDetailWhereInput
    /**
     * Limit how many EmploymentDetails to update.
     */
    limit?: number
  }

  /**
   * EmploymentDetail updateManyAndReturn
   */
  export type EmploymentDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * The data used to update EmploymentDetails.
     */
    data: XOR<EmploymentDetailUpdateManyMutationInput, EmploymentDetailUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentDetails to update
     */
    where?: EmploymentDetailWhereInput
    /**
     * Limit how many EmploymentDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmploymentDetail upsert
   */
  export type EmploymentDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the EmploymentDetail to update in case it exists.
     */
    where: EmploymentDetailWhereUniqueInput
    /**
     * In case the EmploymentDetail found by the `where` argument doesn't exist, create a new EmploymentDetail with this data.
     */
    create: XOR<EmploymentDetailCreateInput, EmploymentDetailUncheckedCreateInput>
    /**
     * In case the EmploymentDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmploymentDetailUpdateInput, EmploymentDetailUncheckedUpdateInput>
  }

  /**
   * EmploymentDetail delete
   */
  export type EmploymentDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
    /**
     * Filter which EmploymentDetail to delete.
     */
    where: EmploymentDetailWhereUniqueInput
  }

  /**
   * EmploymentDetail deleteMany
   */
  export type EmploymentDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentDetails to delete
     */
    where?: EmploymentDetailWhereInput
    /**
     * Limit how many EmploymentDetails to delete.
     */
    limit?: number
  }

  /**
   * EmploymentDetail without action
   */
  export type EmploymentDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetail
     */
    select?: EmploymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetail
     */
    omit?: EmploymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailInclude<ExtArgs> | null
  }


  /**
   * Model Referee
   */

  export type AggregateReferee = {
    _count: RefereeCountAggregateOutputType | null
    _min: RefereeMinAggregateOutputType | null
    _max: RefereeMaxAggregateOutputType | null
  }

  export type RefereeMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    surname: string | null
    otherNames: string | null
    relationship: string | null
    idPassportNo: string | null
    employerName: string | null
    locationStation: string | null
    phoneWork: string | null
    phoneMobile: string | null
    isRelative: boolean | null
    createdAt: Date | null
  }

  export type RefereeMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    surname: string | null
    otherNames: string | null
    relationship: string | null
    idPassportNo: string | null
    employerName: string | null
    locationStation: string | null
    phoneWork: string | null
    phoneMobile: string | null
    isRelative: boolean | null
    createdAt: Date | null
  }

  export type RefereeCountAggregateOutputType = {
    id: number
    clientId: number
    surname: number
    otherNames: number
    relationship: number
    idPassportNo: number
    employerName: number
    locationStation: number
    phoneWork: number
    phoneMobile: number
    isRelative: number
    createdAt: number
    _all: number
  }


  export type RefereeMinAggregateInputType = {
    id?: true
    clientId?: true
    surname?: true
    otherNames?: true
    relationship?: true
    idPassportNo?: true
    employerName?: true
    locationStation?: true
    phoneWork?: true
    phoneMobile?: true
    isRelative?: true
    createdAt?: true
  }

  export type RefereeMaxAggregateInputType = {
    id?: true
    clientId?: true
    surname?: true
    otherNames?: true
    relationship?: true
    idPassportNo?: true
    employerName?: true
    locationStation?: true
    phoneWork?: true
    phoneMobile?: true
    isRelative?: true
    createdAt?: true
  }

  export type RefereeCountAggregateInputType = {
    id?: true
    clientId?: true
    surname?: true
    otherNames?: true
    relationship?: true
    idPassportNo?: true
    employerName?: true
    locationStation?: true
    phoneWork?: true
    phoneMobile?: true
    isRelative?: true
    createdAt?: true
    _all?: true
  }

  export type RefereeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referee to aggregate.
     */
    where?: RefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referees to fetch.
     */
    orderBy?: RefereeOrderByWithRelationInput | RefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referees
    **/
    _count?: true | RefereeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefereeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefereeMaxAggregateInputType
  }

  export type GetRefereeAggregateType<T extends RefereeAggregateArgs> = {
        [P in keyof T & keyof AggregateReferee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferee[P]>
      : GetScalarType<T[P], AggregateReferee[P]>
  }




  export type RefereeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefereeWhereInput
    orderBy?: RefereeOrderByWithAggregationInput | RefereeOrderByWithAggregationInput[]
    by: RefereeScalarFieldEnum[] | RefereeScalarFieldEnum
    having?: RefereeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefereeCountAggregateInputType | true
    _min?: RefereeMinAggregateInputType
    _max?: RefereeMaxAggregateInputType
  }

  export type RefereeGroupByOutputType = {
    id: string
    clientId: string
    surname: string
    otherNames: string
    relationship: string
    idPassportNo: string | null
    employerName: string | null
    locationStation: string | null
    phoneWork: string | null
    phoneMobile: string
    isRelative: boolean
    createdAt: Date
    _count: RefereeCountAggregateOutputType | null
    _min: RefereeMinAggregateOutputType | null
    _max: RefereeMaxAggregateOutputType | null
  }

  type GetRefereeGroupByPayload<T extends RefereeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefereeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefereeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefereeGroupByOutputType[P]>
            : GetScalarType<T[P], RefereeGroupByOutputType[P]>
        }
      >
    >


  export type RefereeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    surname?: boolean
    otherNames?: boolean
    relationship?: boolean
    idPassportNo?: boolean
    employerName?: boolean
    locationStation?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    isRelative?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referee"]>

  export type RefereeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    surname?: boolean
    otherNames?: boolean
    relationship?: boolean
    idPassportNo?: boolean
    employerName?: boolean
    locationStation?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    isRelative?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referee"]>

  export type RefereeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    surname?: boolean
    otherNames?: boolean
    relationship?: boolean
    idPassportNo?: boolean
    employerName?: boolean
    locationStation?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    isRelative?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referee"]>

  export type RefereeSelectScalar = {
    id?: boolean
    clientId?: boolean
    surname?: boolean
    otherNames?: boolean
    relationship?: boolean
    idPassportNo?: boolean
    employerName?: boolean
    locationStation?: boolean
    phoneWork?: boolean
    phoneMobile?: boolean
    isRelative?: boolean
    createdAt?: boolean
  }

  export type RefereeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "surname" | "otherNames" | "relationship" | "idPassportNo" | "employerName" | "locationStation" | "phoneWork" | "phoneMobile" | "isRelative" | "createdAt", ExtArgs["result"]["referee"]>
  export type RefereeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type RefereeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type RefereeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $RefereePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referee"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      surname: string
      otherNames: string
      relationship: string
      idPassportNo: string | null
      employerName: string | null
      locationStation: string | null
      phoneWork: string | null
      phoneMobile: string
      isRelative: boolean
      createdAt: Date
    }, ExtArgs["result"]["referee"]>
    composites: {}
  }

  type RefereeGetPayload<S extends boolean | null | undefined | RefereeDefaultArgs> = $Result.GetResult<Prisma.$RefereePayload, S>

  type RefereeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefereeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefereeCountAggregateInputType | true
    }

  export interface RefereeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referee'], meta: { name: 'Referee' } }
    /**
     * Find zero or one Referee that matches the filter.
     * @param {RefereeFindUniqueArgs} args - Arguments to find a Referee
     * @example
     * // Get one Referee
     * const referee = await prisma.referee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefereeFindUniqueArgs>(args: SelectSubset<T, RefereeFindUniqueArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefereeFindUniqueOrThrowArgs} args - Arguments to find a Referee
     * @example
     * // Get one Referee
     * const referee = await prisma.referee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefereeFindUniqueOrThrowArgs>(args: SelectSubset<T, RefereeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefereeFindFirstArgs} args - Arguments to find a Referee
     * @example
     * // Get one Referee
     * const referee = await prisma.referee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefereeFindFirstArgs>(args?: SelectSubset<T, RefereeFindFirstArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefereeFindFirstOrThrowArgs} args - Arguments to find a Referee
     * @example
     * // Get one Referee
     * const referee = await prisma.referee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefereeFindFirstOrThrowArgs>(args?: SelectSubset<T, RefereeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefereeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referees
     * const referees = await prisma.referee.findMany()
     * 
     * // Get first 10 Referees
     * const referees = await prisma.referee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refereeWithIdOnly = await prisma.referee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefereeFindManyArgs>(args?: SelectSubset<T, RefereeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referee.
     * @param {RefereeCreateArgs} args - Arguments to create a Referee.
     * @example
     * // Create one Referee
     * const Referee = await prisma.referee.create({
     *   data: {
     *     // ... data to create a Referee
     *   }
     * })
     * 
     */
    create<T extends RefereeCreateArgs>(args: SelectSubset<T, RefereeCreateArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referees.
     * @param {RefereeCreateManyArgs} args - Arguments to create many Referees.
     * @example
     * // Create many Referees
     * const referee = await prisma.referee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefereeCreateManyArgs>(args?: SelectSubset<T, RefereeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referees and returns the data saved in the database.
     * @param {RefereeCreateManyAndReturnArgs} args - Arguments to create many Referees.
     * @example
     * // Create many Referees
     * const referee = await prisma.referee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referees and only return the `id`
     * const refereeWithIdOnly = await prisma.referee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefereeCreateManyAndReturnArgs>(args?: SelectSubset<T, RefereeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referee.
     * @param {RefereeDeleteArgs} args - Arguments to delete one Referee.
     * @example
     * // Delete one Referee
     * const Referee = await prisma.referee.delete({
     *   where: {
     *     // ... filter to delete one Referee
     *   }
     * })
     * 
     */
    delete<T extends RefereeDeleteArgs>(args: SelectSubset<T, RefereeDeleteArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referee.
     * @param {RefereeUpdateArgs} args - Arguments to update one Referee.
     * @example
     * // Update one Referee
     * const referee = await prisma.referee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefereeUpdateArgs>(args: SelectSubset<T, RefereeUpdateArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referees.
     * @param {RefereeDeleteManyArgs} args - Arguments to filter Referees to delete.
     * @example
     * // Delete a few Referees
     * const { count } = await prisma.referee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefereeDeleteManyArgs>(args?: SelectSubset<T, RefereeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefereeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referees
     * const referee = await prisma.referee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefereeUpdateManyArgs>(args: SelectSubset<T, RefereeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referees and returns the data updated in the database.
     * @param {RefereeUpdateManyAndReturnArgs} args - Arguments to update many Referees.
     * @example
     * // Update many Referees
     * const referee = await prisma.referee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referees and only return the `id`
     * const refereeWithIdOnly = await prisma.referee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefereeUpdateManyAndReturnArgs>(args: SelectSubset<T, RefereeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referee.
     * @param {RefereeUpsertArgs} args - Arguments to update or create a Referee.
     * @example
     * // Update or create a Referee
     * const referee = await prisma.referee.upsert({
     *   create: {
     *     // ... data to create a Referee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referee we want to update
     *   }
     * })
     */
    upsert<T extends RefereeUpsertArgs>(args: SelectSubset<T, RefereeUpsertArgs<ExtArgs>>): Prisma__RefereeClient<$Result.GetResult<Prisma.$RefereePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefereeCountArgs} args - Arguments to filter Referees to count.
     * @example
     * // Count the number of Referees
     * const count = await prisma.referee.count({
     *   where: {
     *     // ... the filter for the Referees we want to count
     *   }
     * })
    **/
    count<T extends RefereeCountArgs>(
      args?: Subset<T, RefereeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefereeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefereeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefereeAggregateArgs>(args: Subset<T, RefereeAggregateArgs>): Prisma.PrismaPromise<GetRefereeAggregateType<T>>

    /**
     * Group by Referee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefereeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefereeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefereeGroupByArgs['orderBy'] }
        : { orderBy?: RefereeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefereeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefereeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referee model
   */
  readonly fields: RefereeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefereeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referee model
   */
  interface RefereeFieldRefs {
    readonly id: FieldRef<"Referee", 'String'>
    readonly clientId: FieldRef<"Referee", 'String'>
    readonly surname: FieldRef<"Referee", 'String'>
    readonly otherNames: FieldRef<"Referee", 'String'>
    readonly relationship: FieldRef<"Referee", 'String'>
    readonly idPassportNo: FieldRef<"Referee", 'String'>
    readonly employerName: FieldRef<"Referee", 'String'>
    readonly locationStation: FieldRef<"Referee", 'String'>
    readonly phoneWork: FieldRef<"Referee", 'String'>
    readonly phoneMobile: FieldRef<"Referee", 'String'>
    readonly isRelative: FieldRef<"Referee", 'Boolean'>
    readonly createdAt: FieldRef<"Referee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referee findUnique
   */
  export type RefereeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * Filter, which Referee to fetch.
     */
    where: RefereeWhereUniqueInput
  }

  /**
   * Referee findUniqueOrThrow
   */
  export type RefereeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * Filter, which Referee to fetch.
     */
    where: RefereeWhereUniqueInput
  }

  /**
   * Referee findFirst
   */
  export type RefereeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * Filter, which Referee to fetch.
     */
    where?: RefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referees to fetch.
     */
    orderBy?: RefereeOrderByWithRelationInput | RefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referees.
     */
    cursor?: RefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referees.
     */
    distinct?: RefereeScalarFieldEnum | RefereeScalarFieldEnum[]
  }

  /**
   * Referee findFirstOrThrow
   */
  export type RefereeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * Filter, which Referee to fetch.
     */
    where?: RefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referees to fetch.
     */
    orderBy?: RefereeOrderByWithRelationInput | RefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referees.
     */
    cursor?: RefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referees.
     */
    distinct?: RefereeScalarFieldEnum | RefereeScalarFieldEnum[]
  }

  /**
   * Referee findMany
   */
  export type RefereeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * Filter, which Referees to fetch.
     */
    where?: RefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referees to fetch.
     */
    orderBy?: RefereeOrderByWithRelationInput | RefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referees.
     */
    cursor?: RefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referees.
     */
    skip?: number
    distinct?: RefereeScalarFieldEnum | RefereeScalarFieldEnum[]
  }

  /**
   * Referee create
   */
  export type RefereeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * The data needed to create a Referee.
     */
    data: XOR<RefereeCreateInput, RefereeUncheckedCreateInput>
  }

  /**
   * Referee createMany
   */
  export type RefereeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referees.
     */
    data: RefereeCreateManyInput | RefereeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referee createManyAndReturn
   */
  export type RefereeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * The data used to create many Referees.
     */
    data: RefereeCreateManyInput | RefereeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referee update
   */
  export type RefereeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * The data needed to update a Referee.
     */
    data: XOR<RefereeUpdateInput, RefereeUncheckedUpdateInput>
    /**
     * Choose, which Referee to update.
     */
    where: RefereeWhereUniqueInput
  }

  /**
   * Referee updateMany
   */
  export type RefereeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referees.
     */
    data: XOR<RefereeUpdateManyMutationInput, RefereeUncheckedUpdateManyInput>
    /**
     * Filter which Referees to update
     */
    where?: RefereeWhereInput
    /**
     * Limit how many Referees to update.
     */
    limit?: number
  }

  /**
   * Referee updateManyAndReturn
   */
  export type RefereeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * The data used to update Referees.
     */
    data: XOR<RefereeUpdateManyMutationInput, RefereeUncheckedUpdateManyInput>
    /**
     * Filter which Referees to update
     */
    where?: RefereeWhereInput
    /**
     * Limit how many Referees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referee upsert
   */
  export type RefereeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * The filter to search for the Referee to update in case it exists.
     */
    where: RefereeWhereUniqueInput
    /**
     * In case the Referee found by the `where` argument doesn't exist, create a new Referee with this data.
     */
    create: XOR<RefereeCreateInput, RefereeUncheckedCreateInput>
    /**
     * In case the Referee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefereeUpdateInput, RefereeUncheckedUpdateInput>
  }

  /**
   * Referee delete
   */
  export type RefereeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
    /**
     * Filter which Referee to delete.
     */
    where: RefereeWhereUniqueInput
  }

  /**
   * Referee deleteMany
   */
  export type RefereeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referees to delete
     */
    where?: RefereeWhereInput
    /**
     * Limit how many Referees to delete.
     */
    limit?: number
  }

  /**
   * Referee without action
   */
  export type RefereeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referee
     */
    select?: RefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referee
     */
    omit?: RefereeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefereeInclude<ExtArgs> | null
  }


  /**
   * Model BankDetail
   */

  export type AggregateBankDetail = {
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  export type BankDetailMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    bankName: string | null
    branch: string | null
    accountName: string | null
    accountNumber: string | null
    proofDocument: string | null
    proofDocumentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    bankName: string | null
    branch: string | null
    accountName: string | null
    accountNumber: string | null
    proofDocument: string | null
    proofDocumentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailCountAggregateOutputType = {
    id: number
    clientId: number
    bankName: number
    branch: number
    accountName: number
    accountNumber: number
    proofDocument: number
    proofDocumentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankDetailMinAggregateInputType = {
    id?: true
    clientId?: true
    bankName?: true
    branch?: true
    accountName?: true
    accountNumber?: true
    proofDocument?: true
    proofDocumentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailMaxAggregateInputType = {
    id?: true
    clientId?: true
    bankName?: true
    branch?: true
    accountName?: true
    accountNumber?: true
    proofDocument?: true
    proofDocumentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailCountAggregateInputType = {
    id?: true
    clientId?: true
    bankName?: true
    branch?: true
    accountName?: true
    accountNumber?: true
    proofDocument?: true
    proofDocumentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetail to aggregate.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankDetails
    **/
    _count?: true | BankDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankDetailMaxAggregateInputType
  }

  export type GetBankDetailAggregateType<T extends BankDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBankDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankDetail[P]>
      : GetScalarType<T[P], AggregateBankDetail[P]>
  }




  export type BankDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankDetailWhereInput
    orderBy?: BankDetailOrderByWithAggregationInput | BankDetailOrderByWithAggregationInput[]
    by: BankDetailScalarFieldEnum[] | BankDetailScalarFieldEnum
    having?: BankDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankDetailCountAggregateInputType | true
    _min?: BankDetailMinAggregateInputType
    _max?: BankDetailMaxAggregateInputType
  }

  export type BankDetailGroupByOutputType = {
    id: string
    clientId: string
    bankName: string
    branch: string
    accountName: string
    accountNumber: string
    proofDocument: string | null
    proofDocumentUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  type GetBankDetailGroupByPayload<T extends BankDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
        }
      >
    >


  export type BankDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    bankName?: boolean
    branch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    proofDocument?: boolean
    proofDocumentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    bankName?: boolean
    branch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    proofDocument?: boolean
    proofDocumentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    bankName?: boolean
    branch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    proofDocument?: boolean
    proofDocumentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectScalar = {
    id?: boolean
    clientId?: boolean
    bankName?: boolean
    branch?: boolean
    accountName?: boolean
    accountNumber?: boolean
    proofDocument?: boolean
    proofDocumentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "bankName" | "branch" | "accountName" | "accountNumber" | "proofDocument" | "proofDocumentUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["bankDetail"]>
  export type BankDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type BankDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type BankDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $BankDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankDetail"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      bankName: string
      branch: string
      accountName: string
      accountNumber: string
      proofDocument: string | null
      proofDocumentUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankDetail"]>
    composites: {}
  }

  type BankDetailGetPayload<S extends boolean | null | undefined | BankDetailDefaultArgs> = $Result.GetResult<Prisma.$BankDetailPayload, S>

  type BankDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankDetailCountAggregateInputType | true
    }

  export interface BankDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankDetail'], meta: { name: 'BankDetail' } }
    /**
     * Find zero or one BankDetail that matches the filter.
     * @param {BankDetailFindUniqueArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankDetailFindUniqueArgs>(args: SelectSubset<T, BankDetailFindUniqueArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankDetailFindUniqueOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BankDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankDetailFindFirstArgs>(args?: SelectSubset<T, BankDetailFindFirstArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BankDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankDetails
     * const bankDetails = await prisma.bankDetail.findMany()
     * 
     * // Get first 10 BankDetails
     * const bankDetails = await prisma.bankDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankDetailFindManyArgs>(args?: SelectSubset<T, BankDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankDetail.
     * @param {BankDetailCreateArgs} args - Arguments to create a BankDetail.
     * @example
     * // Create one BankDetail
     * const BankDetail = await prisma.bankDetail.create({
     *   data: {
     *     // ... data to create a BankDetail
     *   }
     * })
     * 
     */
    create<T extends BankDetailCreateArgs>(args: SelectSubset<T, BankDetailCreateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankDetails.
     * @param {BankDetailCreateManyArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankDetailCreateManyArgs>(args?: SelectSubset<T, BankDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankDetails and returns the data saved in the database.
     * @param {BankDetailCreateManyAndReturnArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BankDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankDetail.
     * @param {BankDetailDeleteArgs} args - Arguments to delete one BankDetail.
     * @example
     * // Delete one BankDetail
     * const BankDetail = await prisma.bankDetail.delete({
     *   where: {
     *     // ... filter to delete one BankDetail
     *   }
     * })
     * 
     */
    delete<T extends BankDetailDeleteArgs>(args: SelectSubset<T, BankDetailDeleteArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankDetail.
     * @param {BankDetailUpdateArgs} args - Arguments to update one BankDetail.
     * @example
     * // Update one BankDetail
     * const bankDetail = await prisma.bankDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankDetailUpdateArgs>(args: SelectSubset<T, BankDetailUpdateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankDetails.
     * @param {BankDetailDeleteManyArgs} args - Arguments to filter BankDetails to delete.
     * @example
     * // Delete a few BankDetails
     * const { count } = await prisma.bankDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankDetailDeleteManyArgs>(args?: SelectSubset<T, BankDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankDetailUpdateManyArgs>(args: SelectSubset<T, BankDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails and returns the data updated in the database.
     * @param {BankDetailUpdateManyAndReturnArgs} args - Arguments to update many BankDetails.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BankDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankDetail.
     * @param {BankDetailUpsertArgs} args - Arguments to update or create a BankDetail.
     * @example
     * // Update or create a BankDetail
     * const bankDetail = await prisma.bankDetail.upsert({
     *   create: {
     *     // ... data to create a BankDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankDetail we want to update
     *   }
     * })
     */
    upsert<T extends BankDetailUpsertArgs>(args: SelectSubset<T, BankDetailUpsertArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailCountArgs} args - Arguments to filter BankDetails to count.
     * @example
     * // Count the number of BankDetails
     * const count = await prisma.bankDetail.count({
     *   where: {
     *     // ... the filter for the BankDetails we want to count
     *   }
     * })
    **/
    count<T extends BankDetailCountArgs>(
      args?: Subset<T, BankDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankDetailAggregateArgs>(args: Subset<T, BankDetailAggregateArgs>): Prisma.PrismaPromise<GetBankDetailAggregateType<T>>

    /**
     * Group by BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankDetailGroupByArgs['orderBy'] }
        : { orderBy?: BankDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankDetail model
   */
  readonly fields: BankDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankDetail model
   */
  interface BankDetailFieldRefs {
    readonly id: FieldRef<"BankDetail", 'String'>
    readonly clientId: FieldRef<"BankDetail", 'String'>
    readonly bankName: FieldRef<"BankDetail", 'String'>
    readonly branch: FieldRef<"BankDetail", 'String'>
    readonly accountName: FieldRef<"BankDetail", 'String'>
    readonly accountNumber: FieldRef<"BankDetail", 'String'>
    readonly proofDocument: FieldRef<"BankDetail", 'String'>
    readonly proofDocumentUrl: FieldRef<"BankDetail", 'String'>
    readonly createdAt: FieldRef<"BankDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"BankDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankDetail findUnique
   */
  export type BankDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findUniqueOrThrow
   */
  export type BankDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findFirst
   */
  export type BankDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findFirstOrThrow
   */
  export type BankDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findMany
   */
  export type BankDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail create
   */
  export type BankDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BankDetail.
     */
    data: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
  }

  /**
   * BankDetail createMany
   */
  export type BankDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetail createManyAndReturn
   */
  export type BankDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetail update
   */
  export type BankDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BankDetail.
     */
    data: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
    /**
     * Choose, which BankDetail to update.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail updateMany
   */
  export type BankDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetail updateManyAndReturn
   */
  export type BankDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetail upsert
   */
  export type BankDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BankDetail to update in case it exists.
     */
    where: BankDetailWhereUniqueInput
    /**
     * In case the BankDetail found by the `where` argument doesn't exist, create a new BankDetail with this data.
     */
    create: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
    /**
     * In case the BankDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
  }

  /**
   * BankDetail delete
   */
  export type BankDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter which BankDetail to delete.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail deleteMany
   */
  export type BankDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to delete
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to delete.
     */
    limit?: number
  }

  /**
   * BankDetail without action
   */
  export type BankDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
  }


  /**
   * Model LoanApplication
   */

  export type AggregateLoanApplication = {
    _count: LoanApplicationCountAggregateOutputType | null
    _avg: LoanApplicationAvgAggregateOutputType | null
    _sum: LoanApplicationSumAggregateOutputType | null
    _min: LoanApplicationMinAggregateOutputType | null
    _max: LoanApplicationMaxAggregateOutputType | null
  }

  export type LoanApplicationAvgAggregateOutputType = {
    amountRequested: Decimal | null
    approvedAmount: Decimal | null
    interestRate: Decimal | null
    repaymentPeriod: number | null
  }

  export type LoanApplicationSumAggregateOutputType = {
    amountRequested: Decimal | null
    approvedAmount: Decimal | null
    interestRate: Decimal | null
    repaymentPeriod: number | null
  }

  export type LoanApplicationMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    purpose: string | null
    amountRequested: Decimal | null
    approvedAmount: Decimal | null
    qualificationType: $Enums.QualificationType | null
    interestRate: Decimal | null
    startDate: Date | null
    repaymentPeriod: number | null
    status: $Enums.LoanApplicationStatus | null
    appliedAt: Date | null
    reviewedAt: Date | null
    reviewedById: string | null
    approvedAt: Date | null
    approvedById: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanApplicationMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    purpose: string | null
    amountRequested: Decimal | null
    approvedAmount: Decimal | null
    qualificationType: $Enums.QualificationType | null
    interestRate: Decimal | null
    startDate: Date | null
    repaymentPeriod: number | null
    status: $Enums.LoanApplicationStatus | null
    appliedAt: Date | null
    reviewedAt: Date | null
    reviewedById: string | null
    approvedAt: Date | null
    approvedById: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanApplicationCountAggregateOutputType = {
    id: number
    clientId: number
    purpose: number
    amountRequested: number
    approvedAmount: number
    qualificationType: number
    interestRate: number
    startDate: number
    repaymentPeriod: number
    status: number
    appliedAt: number
    reviewedAt: number
    reviewedById: number
    approvedAt: number
    approvedById: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanApplicationAvgAggregateInputType = {
    amountRequested?: true
    approvedAmount?: true
    interestRate?: true
    repaymentPeriod?: true
  }

  export type LoanApplicationSumAggregateInputType = {
    amountRequested?: true
    approvedAmount?: true
    interestRate?: true
    repaymentPeriod?: true
  }

  export type LoanApplicationMinAggregateInputType = {
    id?: true
    clientId?: true
    purpose?: true
    amountRequested?: true
    approvedAmount?: true
    qualificationType?: true
    interestRate?: true
    startDate?: true
    repaymentPeriod?: true
    status?: true
    appliedAt?: true
    reviewedAt?: true
    reviewedById?: true
    approvedAt?: true
    approvedById?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanApplicationMaxAggregateInputType = {
    id?: true
    clientId?: true
    purpose?: true
    amountRequested?: true
    approvedAmount?: true
    qualificationType?: true
    interestRate?: true
    startDate?: true
    repaymentPeriod?: true
    status?: true
    appliedAt?: true
    reviewedAt?: true
    reviewedById?: true
    approvedAt?: true
    approvedById?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanApplicationCountAggregateInputType = {
    id?: true
    clientId?: true
    purpose?: true
    amountRequested?: true
    approvedAmount?: true
    qualificationType?: true
    interestRate?: true
    startDate?: true
    repaymentPeriod?: true
    status?: true
    appliedAt?: true
    reviewedAt?: true
    reviewedById?: true
    approvedAt?: true
    approvedById?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanApplication to aggregate.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanApplications
    **/
    _count?: true | LoanApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanApplicationMaxAggregateInputType
  }

  export type GetLoanApplicationAggregateType<T extends LoanApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanApplication[P]>
      : GetScalarType<T[P], AggregateLoanApplication[P]>
  }




  export type LoanApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
    orderBy?: LoanApplicationOrderByWithAggregationInput | LoanApplicationOrderByWithAggregationInput[]
    by: LoanApplicationScalarFieldEnum[] | LoanApplicationScalarFieldEnum
    having?: LoanApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanApplicationCountAggregateInputType | true
    _avg?: LoanApplicationAvgAggregateInputType
    _sum?: LoanApplicationSumAggregateInputType
    _min?: LoanApplicationMinAggregateInputType
    _max?: LoanApplicationMaxAggregateInputType
  }

  export type LoanApplicationGroupByOutputType = {
    id: string
    clientId: string
    purpose: string
    amountRequested: Decimal
    approvedAmount: Decimal | null
    qualificationType: $Enums.QualificationType | null
    interestRate: Decimal
    startDate: Date | null
    repaymentPeriod: number
    status: $Enums.LoanApplicationStatus
    appliedAt: Date
    reviewedAt: Date | null
    reviewedById: string | null
    approvedAt: Date | null
    approvedById: string | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoanApplicationCountAggregateOutputType | null
    _avg: LoanApplicationAvgAggregateOutputType | null
    _sum: LoanApplicationSumAggregateOutputType | null
    _min: LoanApplicationMinAggregateOutputType | null
    _max: LoanApplicationMaxAggregateOutputType | null
  }

  type GetLoanApplicationGroupByPayload<T extends LoanApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], LoanApplicationGroupByOutputType[P]>
        }
      >
    >


  export type LoanApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    purpose?: boolean
    amountRequested?: boolean
    approvedAmount?: boolean
    qualificationType?: boolean
    interestRate?: boolean
    startDate?: boolean
    repaymentPeriod?: boolean
    status?: boolean
    appliedAt?: boolean
    reviewedAt?: boolean
    reviewedById?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documents?: boolean | LoanApplication$documentsArgs<ExtArgs>
    guarantors?: boolean | LoanApplication$guarantorsArgs<ExtArgs>
    investorAllocations?: boolean | LoanApplication$investorAllocationsArgs<ExtArgs>
    invoices?: boolean | LoanApplication$invoicesArgs<ExtArgs>
    approvedBy?: boolean | LoanApplication$approvedByArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    reviewedBy?: boolean | LoanApplication$reviewedByArgs<ExtArgs>
    disbursement?: boolean | LoanApplication$disbursementArgs<ExtArgs>
    financials?: boolean | LoanApplication$financialsArgs<ExtArgs>
    qualification?: boolean | LoanApplication$qualificationArgs<ExtArgs>
    security?: boolean | LoanApplication$securityArgs<ExtArgs>
    npl?: boolean | LoanApplication$nplArgs<ExtArgs>
    recoveryRecords?: boolean | LoanApplication$recoveryRecordsArgs<ExtArgs>
    repayments?: boolean | LoanApplication$repaymentsArgs<ExtArgs>
    vehicleSecurity?: boolean | LoanApplication$vehicleSecurityArgs<ExtArgs>
    _count?: boolean | LoanApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanApplication"]>

  export type LoanApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    purpose?: boolean
    amountRequested?: boolean
    approvedAmount?: boolean
    qualificationType?: boolean
    interestRate?: boolean
    startDate?: boolean
    repaymentPeriod?: boolean
    status?: boolean
    appliedAt?: boolean
    reviewedAt?: boolean
    reviewedById?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean | LoanApplication$approvedByArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    reviewedBy?: boolean | LoanApplication$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["loanApplication"]>

  export type LoanApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    purpose?: boolean
    amountRequested?: boolean
    approvedAmount?: boolean
    qualificationType?: boolean
    interestRate?: boolean
    startDate?: boolean
    repaymentPeriod?: boolean
    status?: boolean
    appliedAt?: boolean
    reviewedAt?: boolean
    reviewedById?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean | LoanApplication$approvedByArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    reviewedBy?: boolean | LoanApplication$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["loanApplication"]>

  export type LoanApplicationSelectScalar = {
    id?: boolean
    clientId?: boolean
    purpose?: boolean
    amountRequested?: boolean
    approvedAmount?: boolean
    qualificationType?: boolean
    interestRate?: boolean
    startDate?: boolean
    repaymentPeriod?: boolean
    status?: boolean
    appliedAt?: boolean
    reviewedAt?: boolean
    reviewedById?: boolean
    approvedAt?: boolean
    approvedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "purpose" | "amountRequested" | "approvedAmount" | "qualificationType" | "interestRate" | "startDate" | "repaymentPeriod" | "status" | "appliedAt" | "reviewedAt" | "reviewedById" | "approvedAt" | "approvedById" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["loanApplication"]>
  export type LoanApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | LoanApplication$documentsArgs<ExtArgs>
    guarantors?: boolean | LoanApplication$guarantorsArgs<ExtArgs>
    investorAllocations?: boolean | LoanApplication$investorAllocationsArgs<ExtArgs>
    invoices?: boolean | LoanApplication$invoicesArgs<ExtArgs>
    approvedBy?: boolean | LoanApplication$approvedByArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    reviewedBy?: boolean | LoanApplication$reviewedByArgs<ExtArgs>
    disbursement?: boolean | LoanApplication$disbursementArgs<ExtArgs>
    financials?: boolean | LoanApplication$financialsArgs<ExtArgs>
    qualification?: boolean | LoanApplication$qualificationArgs<ExtArgs>
    security?: boolean | LoanApplication$securityArgs<ExtArgs>
    npl?: boolean | LoanApplication$nplArgs<ExtArgs>
    recoveryRecords?: boolean | LoanApplication$recoveryRecordsArgs<ExtArgs>
    repayments?: boolean | LoanApplication$repaymentsArgs<ExtArgs>
    vehicleSecurity?: boolean | LoanApplication$vehicleSecurityArgs<ExtArgs>
    _count?: boolean | LoanApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoanApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | LoanApplication$approvedByArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    reviewedBy?: boolean | LoanApplication$reviewedByArgs<ExtArgs>
  }
  export type LoanApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | LoanApplication$approvedByArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    reviewedBy?: boolean | LoanApplication$reviewedByArgs<ExtArgs>
  }

  export type $LoanApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanApplication"
    objects: {
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      guarantors: Prisma.$GuarantorPayload<ExtArgs>[]
      investorAllocations: Prisma.$InvestorAllocationPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs>
      reviewedBy: Prisma.$UserPayload<ExtArgs> | null
      disbursement: Prisma.$LoanDisbursementPayload<ExtArgs> | null
      financials: Prisma.$LoanFinancialPayload<ExtArgs> | null
      qualification: Prisma.$LoanQualificationPayload<ExtArgs> | null
      security: Prisma.$LoanSecurityPayload<ExtArgs> | null
      npl: Prisma.$NonPerformingLoanPayload<ExtArgs> | null
      recoveryRecords: Prisma.$RecoveryRecordPayload<ExtArgs>[]
      repayments: Prisma.$RepaymentPayload<ExtArgs>[]
      vehicleSecurity: Prisma.$VehicleSecurityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      purpose: string
      amountRequested: Prisma.Decimal
      approvedAmount: Prisma.Decimal | null
      qualificationType: $Enums.QualificationType | null
      interestRate: Prisma.Decimal
      startDate: Date | null
      repaymentPeriod: number
      status: $Enums.LoanApplicationStatus
      appliedAt: Date
      reviewedAt: Date | null
      reviewedById: string | null
      approvedAt: Date | null
      approvedById: string | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loanApplication"]>
    composites: {}
  }

  type LoanApplicationGetPayload<S extends boolean | null | undefined | LoanApplicationDefaultArgs> = $Result.GetResult<Prisma.$LoanApplicationPayload, S>

  type LoanApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanApplicationCountAggregateInputType | true
    }

  export interface LoanApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanApplication'], meta: { name: 'LoanApplication' } }
    /**
     * Find zero or one LoanApplication that matches the filter.
     * @param {LoanApplicationFindUniqueArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanApplicationFindUniqueArgs>(args: SelectSubset<T, LoanApplicationFindUniqueArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoanApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanApplicationFindUniqueOrThrowArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindFirstArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanApplicationFindFirstArgs>(args?: SelectSubset<T, LoanApplicationFindFirstArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindFirstOrThrowArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoanApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanApplications
     * const loanApplications = await prisma.loanApplication.findMany()
     * 
     * // Get first 10 LoanApplications
     * const loanApplications = await prisma.loanApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanApplicationWithIdOnly = await prisma.loanApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanApplicationFindManyArgs>(args?: SelectSubset<T, LoanApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoanApplication.
     * @param {LoanApplicationCreateArgs} args - Arguments to create a LoanApplication.
     * @example
     * // Create one LoanApplication
     * const LoanApplication = await prisma.loanApplication.create({
     *   data: {
     *     // ... data to create a LoanApplication
     *   }
     * })
     * 
     */
    create<T extends LoanApplicationCreateArgs>(args: SelectSubset<T, LoanApplicationCreateArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoanApplications.
     * @param {LoanApplicationCreateManyArgs} args - Arguments to create many LoanApplications.
     * @example
     * // Create many LoanApplications
     * const loanApplication = await prisma.loanApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanApplicationCreateManyArgs>(args?: SelectSubset<T, LoanApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanApplications and returns the data saved in the database.
     * @param {LoanApplicationCreateManyAndReturnArgs} args - Arguments to create many LoanApplications.
     * @example
     * // Create many LoanApplications
     * const loanApplication = await prisma.loanApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanApplications and only return the `id`
     * const loanApplicationWithIdOnly = await prisma.loanApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoanApplication.
     * @param {LoanApplicationDeleteArgs} args - Arguments to delete one LoanApplication.
     * @example
     * // Delete one LoanApplication
     * const LoanApplication = await prisma.loanApplication.delete({
     *   where: {
     *     // ... filter to delete one LoanApplication
     *   }
     * })
     * 
     */
    delete<T extends LoanApplicationDeleteArgs>(args: SelectSubset<T, LoanApplicationDeleteArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoanApplication.
     * @param {LoanApplicationUpdateArgs} args - Arguments to update one LoanApplication.
     * @example
     * // Update one LoanApplication
     * const loanApplication = await prisma.loanApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanApplicationUpdateArgs>(args: SelectSubset<T, LoanApplicationUpdateArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoanApplications.
     * @param {LoanApplicationDeleteManyArgs} args - Arguments to filter LoanApplications to delete.
     * @example
     * // Delete a few LoanApplications
     * const { count } = await prisma.loanApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanApplicationDeleteManyArgs>(args?: SelectSubset<T, LoanApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanApplications
     * const loanApplication = await prisma.loanApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanApplicationUpdateManyArgs>(args: SelectSubset<T, LoanApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanApplications and returns the data updated in the database.
     * @param {LoanApplicationUpdateManyAndReturnArgs} args - Arguments to update many LoanApplications.
     * @example
     * // Update many LoanApplications
     * const loanApplication = await prisma.loanApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoanApplications and only return the `id`
     * const loanApplicationWithIdOnly = await prisma.loanApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoanApplication.
     * @param {LoanApplicationUpsertArgs} args - Arguments to update or create a LoanApplication.
     * @example
     * // Update or create a LoanApplication
     * const loanApplication = await prisma.loanApplication.upsert({
     *   create: {
     *     // ... data to create a LoanApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanApplication we want to update
     *   }
     * })
     */
    upsert<T extends LoanApplicationUpsertArgs>(args: SelectSubset<T, LoanApplicationUpsertArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoanApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationCountArgs} args - Arguments to filter LoanApplications to count.
     * @example
     * // Count the number of LoanApplications
     * const count = await prisma.loanApplication.count({
     *   where: {
     *     // ... the filter for the LoanApplications we want to count
     *   }
     * })
    **/
    count<T extends LoanApplicationCountArgs>(
      args?: Subset<T, LoanApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanApplicationAggregateArgs>(args: Subset<T, LoanApplicationAggregateArgs>): Prisma.PrismaPromise<GetLoanApplicationAggregateType<T>>

    /**
     * Group by LoanApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanApplicationGroupByArgs['orderBy'] }
        : { orderBy?: LoanApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanApplication model
   */
  readonly fields: LoanApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends LoanApplication$documentsArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guarantors<T extends LoanApplication$guarantorsArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$guarantorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investorAllocations<T extends LoanApplication$investorAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$investorAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends LoanApplication$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedBy<T extends LoanApplication$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewedBy<T extends LoanApplication$reviewedByArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$reviewedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    disbursement<T extends LoanApplication$disbursementArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$disbursementArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    financials<T extends LoanApplication$financialsArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$financialsArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qualification<T extends LoanApplication$qualificationArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$qualificationArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    security<T extends LoanApplication$securityArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$securityArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    npl<T extends LoanApplication$nplArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$nplArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recoveryRecords<T extends LoanApplication$recoveryRecordsArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$recoveryRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    repayments<T extends LoanApplication$repaymentsArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$repaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleSecurity<T extends LoanApplication$vehicleSecurityArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplication$vehicleSecurityArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanApplication model
   */
  interface LoanApplicationFieldRefs {
    readonly id: FieldRef<"LoanApplication", 'String'>
    readonly clientId: FieldRef<"LoanApplication", 'String'>
    readonly purpose: FieldRef<"LoanApplication", 'String'>
    readonly amountRequested: FieldRef<"LoanApplication", 'Decimal'>
    readonly approvedAmount: FieldRef<"LoanApplication", 'Decimal'>
    readonly qualificationType: FieldRef<"LoanApplication", 'QualificationType'>
    readonly interestRate: FieldRef<"LoanApplication", 'Decimal'>
    readonly startDate: FieldRef<"LoanApplication", 'DateTime'>
    readonly repaymentPeriod: FieldRef<"LoanApplication", 'Int'>
    readonly status: FieldRef<"LoanApplication", 'LoanApplicationStatus'>
    readonly appliedAt: FieldRef<"LoanApplication", 'DateTime'>
    readonly reviewedAt: FieldRef<"LoanApplication", 'DateTime'>
    readonly reviewedById: FieldRef<"LoanApplication", 'String'>
    readonly approvedAt: FieldRef<"LoanApplication", 'DateTime'>
    readonly approvedById: FieldRef<"LoanApplication", 'String'>
    readonly rejectionReason: FieldRef<"LoanApplication", 'String'>
    readonly createdAt: FieldRef<"LoanApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"LoanApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanApplication findUnique
   */
  export type LoanApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication findUniqueOrThrow
   */
  export type LoanApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication findFirst
   */
  export type LoanApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanApplications.
     */
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * LoanApplication findFirstOrThrow
   */
  export type LoanApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanApplications.
     */
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * LoanApplication findMany
   */
  export type LoanApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplications to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * LoanApplication create
   */
  export type LoanApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanApplication.
     */
    data: XOR<LoanApplicationCreateInput, LoanApplicationUncheckedCreateInput>
  }

  /**
   * LoanApplication createMany
   */
  export type LoanApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanApplications.
     */
    data: LoanApplicationCreateManyInput | LoanApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanApplication createManyAndReturn
   */
  export type LoanApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many LoanApplications.
     */
    data: LoanApplicationCreateManyInput | LoanApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanApplication update
   */
  export type LoanApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanApplication.
     */
    data: XOR<LoanApplicationUpdateInput, LoanApplicationUncheckedUpdateInput>
    /**
     * Choose, which LoanApplication to update.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication updateMany
   */
  export type LoanApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanApplications.
     */
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LoanApplications to update
     */
    where?: LoanApplicationWhereInput
    /**
     * Limit how many LoanApplications to update.
     */
    limit?: number
  }

  /**
   * LoanApplication updateManyAndReturn
   */
  export type LoanApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * The data used to update LoanApplications.
     */
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LoanApplications to update
     */
    where?: LoanApplicationWhereInput
    /**
     * Limit how many LoanApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanApplication upsert
   */
  export type LoanApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanApplication to update in case it exists.
     */
    where: LoanApplicationWhereUniqueInput
    /**
     * In case the LoanApplication found by the `where` argument doesn't exist, create a new LoanApplication with this data.
     */
    create: XOR<LoanApplicationCreateInput, LoanApplicationUncheckedCreateInput>
    /**
     * In case the LoanApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanApplicationUpdateInput, LoanApplicationUncheckedUpdateInput>
  }

  /**
   * LoanApplication delete
   */
  export type LoanApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter which LoanApplication to delete.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication deleteMany
   */
  export type LoanApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanApplications to delete
     */
    where?: LoanApplicationWhereInput
    /**
     * Limit how many LoanApplications to delete.
     */
    limit?: number
  }

  /**
   * LoanApplication.documents
   */
  export type LoanApplication$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * LoanApplication.guarantors
   */
  export type LoanApplication$guarantorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    where?: GuarantorWhereInput
    orderBy?: GuarantorOrderByWithRelationInput | GuarantorOrderByWithRelationInput[]
    cursor?: GuarantorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuarantorScalarFieldEnum | GuarantorScalarFieldEnum[]
  }

  /**
   * LoanApplication.investorAllocations
   */
  export type LoanApplication$investorAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    where?: InvestorAllocationWhereInput
    orderBy?: InvestorAllocationOrderByWithRelationInput | InvestorAllocationOrderByWithRelationInput[]
    cursor?: InvestorAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorAllocationScalarFieldEnum | InvestorAllocationScalarFieldEnum[]
  }

  /**
   * LoanApplication.invoices
   */
  export type LoanApplication$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * LoanApplication.approvedBy
   */
  export type LoanApplication$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LoanApplication.reviewedBy
   */
  export type LoanApplication$reviewedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LoanApplication.disbursement
   */
  export type LoanApplication$disbursementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    where?: LoanDisbursementWhereInput
  }

  /**
   * LoanApplication.financials
   */
  export type LoanApplication$financialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    where?: LoanFinancialWhereInput
  }

  /**
   * LoanApplication.qualification
   */
  export type LoanApplication$qualificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    where?: LoanQualificationWhereInput
  }

  /**
   * LoanApplication.security
   */
  export type LoanApplication$securityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    where?: LoanSecurityWhereInput
  }

  /**
   * LoanApplication.npl
   */
  export type LoanApplication$nplArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    where?: NonPerformingLoanWhereInput
  }

  /**
   * LoanApplication.recoveryRecords
   */
  export type LoanApplication$recoveryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    where?: RecoveryRecordWhereInput
    orderBy?: RecoveryRecordOrderByWithRelationInput | RecoveryRecordOrderByWithRelationInput[]
    cursor?: RecoveryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecoveryRecordScalarFieldEnum | RecoveryRecordScalarFieldEnum[]
  }

  /**
   * LoanApplication.repayments
   */
  export type LoanApplication$repaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    where?: RepaymentWhereInput
    orderBy?: RepaymentOrderByWithRelationInput | RepaymentOrderByWithRelationInput[]
    cursor?: RepaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepaymentScalarFieldEnum | RepaymentScalarFieldEnum[]
  }

  /**
   * LoanApplication.vehicleSecurity
   */
  export type LoanApplication$vehicleSecurityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    where?: VehicleSecurityWhereInput
  }

  /**
   * LoanApplication without action
   */
  export type LoanApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
  }


  /**
   * Model LoanQualification
   */

  export type AggregateLoanQualification = {
    _count: LoanQualificationCountAggregateOutputType | null
    _avg: LoanQualificationAvgAggregateOutputType | null
    _sum: LoanQualificationSumAggregateOutputType | null
    _min: LoanQualificationMinAggregateOutputType | null
    _max: LoanQualificationMaxAggregateOutputType | null
  }

  export type LoanQualificationAvgAggregateOutputType = {
    avgIncome: Decimal | null
    eligibilityAmount: Decimal | null
  }

  export type LoanQualificationSumAggregateOutputType = {
    avgIncome: Decimal | null
    eligibilityAmount: Decimal | null
  }

  export type LoanQualificationMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    avgIncome: Decimal | null
    eligibilityAmount: Decimal | null
    ruleApplied: $Enums.QualificationType | null
    createdAt: Date | null
  }

  export type LoanQualificationMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    avgIncome: Decimal | null
    eligibilityAmount: Decimal | null
    ruleApplied: $Enums.QualificationType | null
    createdAt: Date | null
  }

  export type LoanQualificationCountAggregateOutputType = {
    id: number
    loanId: number
    avgIncome: number
    eligibilityAmount: number
    ruleApplied: number
    createdAt: number
    _all: number
  }


  export type LoanQualificationAvgAggregateInputType = {
    avgIncome?: true
    eligibilityAmount?: true
  }

  export type LoanQualificationSumAggregateInputType = {
    avgIncome?: true
    eligibilityAmount?: true
  }

  export type LoanQualificationMinAggregateInputType = {
    id?: true
    loanId?: true
    avgIncome?: true
    eligibilityAmount?: true
    ruleApplied?: true
    createdAt?: true
  }

  export type LoanQualificationMaxAggregateInputType = {
    id?: true
    loanId?: true
    avgIncome?: true
    eligibilityAmount?: true
    ruleApplied?: true
    createdAt?: true
  }

  export type LoanQualificationCountAggregateInputType = {
    id?: true
    loanId?: true
    avgIncome?: true
    eligibilityAmount?: true
    ruleApplied?: true
    createdAt?: true
    _all?: true
  }

  export type LoanQualificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanQualification to aggregate.
     */
    where?: LoanQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanQualifications to fetch.
     */
    orderBy?: LoanQualificationOrderByWithRelationInput | LoanQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanQualifications
    **/
    _count?: true | LoanQualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanQualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanQualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanQualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanQualificationMaxAggregateInputType
  }

  export type GetLoanQualificationAggregateType<T extends LoanQualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanQualification[P]>
      : GetScalarType<T[P], AggregateLoanQualification[P]>
  }




  export type LoanQualificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanQualificationWhereInput
    orderBy?: LoanQualificationOrderByWithAggregationInput | LoanQualificationOrderByWithAggregationInput[]
    by: LoanQualificationScalarFieldEnum[] | LoanQualificationScalarFieldEnum
    having?: LoanQualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanQualificationCountAggregateInputType | true
    _avg?: LoanQualificationAvgAggregateInputType
    _sum?: LoanQualificationSumAggregateInputType
    _min?: LoanQualificationMinAggregateInputType
    _max?: LoanQualificationMaxAggregateInputType
  }

  export type LoanQualificationGroupByOutputType = {
    id: string
    loanId: string
    avgIncome: Decimal
    eligibilityAmount: Decimal
    ruleApplied: $Enums.QualificationType
    createdAt: Date
    _count: LoanQualificationCountAggregateOutputType | null
    _avg: LoanQualificationAvgAggregateOutputType | null
    _sum: LoanQualificationSumAggregateOutputType | null
    _min: LoanQualificationMinAggregateOutputType | null
    _max: LoanQualificationMaxAggregateOutputType | null
  }

  type GetLoanQualificationGroupByPayload<T extends LoanQualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanQualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanQualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanQualificationGroupByOutputType[P]>
            : GetScalarType<T[P], LoanQualificationGroupByOutputType[P]>
        }
      >
    >


  export type LoanQualificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    avgIncome?: boolean
    eligibilityAmount?: boolean
    ruleApplied?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanQualification"]>

  export type LoanQualificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    avgIncome?: boolean
    eligibilityAmount?: boolean
    ruleApplied?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanQualification"]>

  export type LoanQualificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    avgIncome?: boolean
    eligibilityAmount?: boolean
    ruleApplied?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanQualification"]>

  export type LoanQualificationSelectScalar = {
    id?: boolean
    loanId?: boolean
    avgIncome?: boolean
    eligibilityAmount?: boolean
    ruleApplied?: boolean
    createdAt?: boolean
  }

  export type LoanQualificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "avgIncome" | "eligibilityAmount" | "ruleApplied" | "createdAt", ExtArgs["result"]["loanQualification"]>
  export type LoanQualificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanQualificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanQualificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $LoanQualificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanQualification"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      avgIncome: Prisma.Decimal
      eligibilityAmount: Prisma.Decimal
      ruleApplied: $Enums.QualificationType
      createdAt: Date
    }, ExtArgs["result"]["loanQualification"]>
    composites: {}
  }

  type LoanQualificationGetPayload<S extends boolean | null | undefined | LoanQualificationDefaultArgs> = $Result.GetResult<Prisma.$LoanQualificationPayload, S>

  type LoanQualificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanQualificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanQualificationCountAggregateInputType | true
    }

  export interface LoanQualificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanQualification'], meta: { name: 'LoanQualification' } }
    /**
     * Find zero or one LoanQualification that matches the filter.
     * @param {LoanQualificationFindUniqueArgs} args - Arguments to find a LoanQualification
     * @example
     * // Get one LoanQualification
     * const loanQualification = await prisma.loanQualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanQualificationFindUniqueArgs>(args: SelectSubset<T, LoanQualificationFindUniqueArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoanQualification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanQualificationFindUniqueOrThrowArgs} args - Arguments to find a LoanQualification
     * @example
     * // Get one LoanQualification
     * const loanQualification = await prisma.loanQualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanQualificationFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanQualificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanQualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanQualificationFindFirstArgs} args - Arguments to find a LoanQualification
     * @example
     * // Get one LoanQualification
     * const loanQualification = await prisma.loanQualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanQualificationFindFirstArgs>(args?: SelectSubset<T, LoanQualificationFindFirstArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanQualification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanQualificationFindFirstOrThrowArgs} args - Arguments to find a LoanQualification
     * @example
     * // Get one LoanQualification
     * const loanQualification = await prisma.loanQualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanQualificationFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanQualificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoanQualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanQualificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanQualifications
     * const loanQualifications = await prisma.loanQualification.findMany()
     * 
     * // Get first 10 LoanQualifications
     * const loanQualifications = await prisma.loanQualification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanQualificationWithIdOnly = await prisma.loanQualification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanQualificationFindManyArgs>(args?: SelectSubset<T, LoanQualificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoanQualification.
     * @param {LoanQualificationCreateArgs} args - Arguments to create a LoanQualification.
     * @example
     * // Create one LoanQualification
     * const LoanQualification = await prisma.loanQualification.create({
     *   data: {
     *     // ... data to create a LoanQualification
     *   }
     * })
     * 
     */
    create<T extends LoanQualificationCreateArgs>(args: SelectSubset<T, LoanQualificationCreateArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoanQualifications.
     * @param {LoanQualificationCreateManyArgs} args - Arguments to create many LoanQualifications.
     * @example
     * // Create many LoanQualifications
     * const loanQualification = await prisma.loanQualification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanQualificationCreateManyArgs>(args?: SelectSubset<T, LoanQualificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanQualifications and returns the data saved in the database.
     * @param {LoanQualificationCreateManyAndReturnArgs} args - Arguments to create many LoanQualifications.
     * @example
     * // Create many LoanQualifications
     * const loanQualification = await prisma.loanQualification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanQualifications and only return the `id`
     * const loanQualificationWithIdOnly = await prisma.loanQualification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanQualificationCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanQualificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoanQualification.
     * @param {LoanQualificationDeleteArgs} args - Arguments to delete one LoanQualification.
     * @example
     * // Delete one LoanQualification
     * const LoanQualification = await prisma.loanQualification.delete({
     *   where: {
     *     // ... filter to delete one LoanQualification
     *   }
     * })
     * 
     */
    delete<T extends LoanQualificationDeleteArgs>(args: SelectSubset<T, LoanQualificationDeleteArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoanQualification.
     * @param {LoanQualificationUpdateArgs} args - Arguments to update one LoanQualification.
     * @example
     * // Update one LoanQualification
     * const loanQualification = await prisma.loanQualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanQualificationUpdateArgs>(args: SelectSubset<T, LoanQualificationUpdateArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoanQualifications.
     * @param {LoanQualificationDeleteManyArgs} args - Arguments to filter LoanQualifications to delete.
     * @example
     * // Delete a few LoanQualifications
     * const { count } = await prisma.loanQualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanQualificationDeleteManyArgs>(args?: SelectSubset<T, LoanQualificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanQualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanQualifications
     * const loanQualification = await prisma.loanQualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanQualificationUpdateManyArgs>(args: SelectSubset<T, LoanQualificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanQualifications and returns the data updated in the database.
     * @param {LoanQualificationUpdateManyAndReturnArgs} args - Arguments to update many LoanQualifications.
     * @example
     * // Update many LoanQualifications
     * const loanQualification = await prisma.loanQualification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoanQualifications and only return the `id`
     * const loanQualificationWithIdOnly = await prisma.loanQualification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanQualificationUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanQualificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoanQualification.
     * @param {LoanQualificationUpsertArgs} args - Arguments to update or create a LoanQualification.
     * @example
     * // Update or create a LoanQualification
     * const loanQualification = await prisma.loanQualification.upsert({
     *   create: {
     *     // ... data to create a LoanQualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanQualification we want to update
     *   }
     * })
     */
    upsert<T extends LoanQualificationUpsertArgs>(args: SelectSubset<T, LoanQualificationUpsertArgs<ExtArgs>>): Prisma__LoanQualificationClient<$Result.GetResult<Prisma.$LoanQualificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoanQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanQualificationCountArgs} args - Arguments to filter LoanQualifications to count.
     * @example
     * // Count the number of LoanQualifications
     * const count = await prisma.loanQualification.count({
     *   where: {
     *     // ... the filter for the LoanQualifications we want to count
     *   }
     * })
    **/
    count<T extends LoanQualificationCountArgs>(
      args?: Subset<T, LoanQualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanQualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanQualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanQualificationAggregateArgs>(args: Subset<T, LoanQualificationAggregateArgs>): Prisma.PrismaPromise<GetLoanQualificationAggregateType<T>>

    /**
     * Group by LoanQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanQualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanQualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanQualificationGroupByArgs['orderBy'] }
        : { orderBy?: LoanQualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanQualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanQualification model
   */
  readonly fields: LoanQualificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanQualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanQualificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanQualification model
   */
  interface LoanQualificationFieldRefs {
    readonly id: FieldRef<"LoanQualification", 'String'>
    readonly loanId: FieldRef<"LoanQualification", 'String'>
    readonly avgIncome: FieldRef<"LoanQualification", 'Decimal'>
    readonly eligibilityAmount: FieldRef<"LoanQualification", 'Decimal'>
    readonly ruleApplied: FieldRef<"LoanQualification", 'QualificationType'>
    readonly createdAt: FieldRef<"LoanQualification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanQualification findUnique
   */
  export type LoanQualificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * Filter, which LoanQualification to fetch.
     */
    where: LoanQualificationWhereUniqueInput
  }

  /**
   * LoanQualification findUniqueOrThrow
   */
  export type LoanQualificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * Filter, which LoanQualification to fetch.
     */
    where: LoanQualificationWhereUniqueInput
  }

  /**
   * LoanQualification findFirst
   */
  export type LoanQualificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * Filter, which LoanQualification to fetch.
     */
    where?: LoanQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanQualifications to fetch.
     */
    orderBy?: LoanQualificationOrderByWithRelationInput | LoanQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanQualifications.
     */
    cursor?: LoanQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanQualifications.
     */
    distinct?: LoanQualificationScalarFieldEnum | LoanQualificationScalarFieldEnum[]
  }

  /**
   * LoanQualification findFirstOrThrow
   */
  export type LoanQualificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * Filter, which LoanQualification to fetch.
     */
    where?: LoanQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanQualifications to fetch.
     */
    orderBy?: LoanQualificationOrderByWithRelationInput | LoanQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanQualifications.
     */
    cursor?: LoanQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanQualifications.
     */
    distinct?: LoanQualificationScalarFieldEnum | LoanQualificationScalarFieldEnum[]
  }

  /**
   * LoanQualification findMany
   */
  export type LoanQualificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * Filter, which LoanQualifications to fetch.
     */
    where?: LoanQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanQualifications to fetch.
     */
    orderBy?: LoanQualificationOrderByWithRelationInput | LoanQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanQualifications.
     */
    cursor?: LoanQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanQualifications.
     */
    skip?: number
    distinct?: LoanQualificationScalarFieldEnum | LoanQualificationScalarFieldEnum[]
  }

  /**
   * LoanQualification create
   */
  export type LoanQualificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanQualification.
     */
    data: XOR<LoanQualificationCreateInput, LoanQualificationUncheckedCreateInput>
  }

  /**
   * LoanQualification createMany
   */
  export type LoanQualificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanQualifications.
     */
    data: LoanQualificationCreateManyInput | LoanQualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanQualification createManyAndReturn
   */
  export type LoanQualificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * The data used to create many LoanQualifications.
     */
    data: LoanQualificationCreateManyInput | LoanQualificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanQualification update
   */
  export type LoanQualificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanQualification.
     */
    data: XOR<LoanQualificationUpdateInput, LoanQualificationUncheckedUpdateInput>
    /**
     * Choose, which LoanQualification to update.
     */
    where: LoanQualificationWhereUniqueInput
  }

  /**
   * LoanQualification updateMany
   */
  export type LoanQualificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanQualifications.
     */
    data: XOR<LoanQualificationUpdateManyMutationInput, LoanQualificationUncheckedUpdateManyInput>
    /**
     * Filter which LoanQualifications to update
     */
    where?: LoanQualificationWhereInput
    /**
     * Limit how many LoanQualifications to update.
     */
    limit?: number
  }

  /**
   * LoanQualification updateManyAndReturn
   */
  export type LoanQualificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * The data used to update LoanQualifications.
     */
    data: XOR<LoanQualificationUpdateManyMutationInput, LoanQualificationUncheckedUpdateManyInput>
    /**
     * Filter which LoanQualifications to update
     */
    where?: LoanQualificationWhereInput
    /**
     * Limit how many LoanQualifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanQualification upsert
   */
  export type LoanQualificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanQualification to update in case it exists.
     */
    where: LoanQualificationWhereUniqueInput
    /**
     * In case the LoanQualification found by the `where` argument doesn't exist, create a new LoanQualification with this data.
     */
    create: XOR<LoanQualificationCreateInput, LoanQualificationUncheckedCreateInput>
    /**
     * In case the LoanQualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanQualificationUpdateInput, LoanQualificationUncheckedUpdateInput>
  }

  /**
   * LoanQualification delete
   */
  export type LoanQualificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
    /**
     * Filter which LoanQualification to delete.
     */
    where: LoanQualificationWhereUniqueInput
  }

  /**
   * LoanQualification deleteMany
   */
  export type LoanQualificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanQualifications to delete
     */
    where?: LoanQualificationWhereInput
    /**
     * Limit how many LoanQualifications to delete.
     */
    limit?: number
  }

  /**
   * LoanQualification without action
   */
  export type LoanQualificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanQualification
     */
    select?: LoanQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanQualification
     */
    omit?: LoanQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanQualificationInclude<ExtArgs> | null
  }


  /**
   * Model LoanSecurity
   */

  export type AggregateLoanSecurity = {
    _count: LoanSecurityCountAggregateOutputType | null
    _min: LoanSecurityMinAggregateOutputType | null
    _max: LoanSecurityMaxAggregateOutputType | null
  }

  export type LoanSecurityMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    idCopy: boolean | null
    passportPhoto: boolean | null
    appointmentLetter: boolean | null
    payslips: boolean | null
    bankStatement: boolean | null
    chequeLeafNo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanSecurityMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    idCopy: boolean | null
    passportPhoto: boolean | null
    appointmentLetter: boolean | null
    payslips: boolean | null
    bankStatement: boolean | null
    chequeLeafNo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanSecurityCountAggregateOutputType = {
    id: number
    loanId: number
    idCopy: number
    passportPhoto: number
    appointmentLetter: number
    payslips: number
    bankStatement: number
    chequeLeafNo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanSecurityMinAggregateInputType = {
    id?: true
    loanId?: true
    idCopy?: true
    passportPhoto?: true
    appointmentLetter?: true
    payslips?: true
    bankStatement?: true
    chequeLeafNo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanSecurityMaxAggregateInputType = {
    id?: true
    loanId?: true
    idCopy?: true
    passportPhoto?: true
    appointmentLetter?: true
    payslips?: true
    bankStatement?: true
    chequeLeafNo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanSecurityCountAggregateInputType = {
    id?: true
    loanId?: true
    idCopy?: true
    passportPhoto?: true
    appointmentLetter?: true
    payslips?: true
    bankStatement?: true
    chequeLeafNo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanSecurityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanSecurity to aggregate.
     */
    where?: LoanSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanSecurities to fetch.
     */
    orderBy?: LoanSecurityOrderByWithRelationInput | LoanSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanSecurities
    **/
    _count?: true | LoanSecurityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanSecurityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanSecurityMaxAggregateInputType
  }

  export type GetLoanSecurityAggregateType<T extends LoanSecurityAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanSecurity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanSecurity[P]>
      : GetScalarType<T[P], AggregateLoanSecurity[P]>
  }




  export type LoanSecurityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanSecurityWhereInput
    orderBy?: LoanSecurityOrderByWithAggregationInput | LoanSecurityOrderByWithAggregationInput[]
    by: LoanSecurityScalarFieldEnum[] | LoanSecurityScalarFieldEnum
    having?: LoanSecurityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanSecurityCountAggregateInputType | true
    _min?: LoanSecurityMinAggregateInputType
    _max?: LoanSecurityMaxAggregateInputType
  }

  export type LoanSecurityGroupByOutputType = {
    id: string
    loanId: string
    idCopy: boolean
    passportPhoto: boolean
    appointmentLetter: boolean
    payslips: boolean
    bankStatement: boolean
    chequeLeafNo: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoanSecurityCountAggregateOutputType | null
    _min: LoanSecurityMinAggregateOutputType | null
    _max: LoanSecurityMaxAggregateOutputType | null
  }

  type GetLoanSecurityGroupByPayload<T extends LoanSecurityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanSecurityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanSecurityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanSecurityGroupByOutputType[P]>
            : GetScalarType<T[P], LoanSecurityGroupByOutputType[P]>
        }
      >
    >


  export type LoanSecuritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanSecurity"]>

  export type LoanSecuritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanSecurity"]>

  export type LoanSecuritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanSecurity"]>

  export type LoanSecuritySelectScalar = {
    id?: boolean
    loanId?: boolean
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanSecurityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "idCopy" | "passportPhoto" | "appointmentLetter" | "payslips" | "bankStatement" | "chequeLeafNo" | "createdAt" | "updatedAt", ExtArgs["result"]["loanSecurity"]>
  export type LoanSecurityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanSecurityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanSecurityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $LoanSecurityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanSecurity"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      idCopy: boolean
      passportPhoto: boolean
      appointmentLetter: boolean
      payslips: boolean
      bankStatement: boolean
      chequeLeafNo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loanSecurity"]>
    composites: {}
  }

  type LoanSecurityGetPayload<S extends boolean | null | undefined | LoanSecurityDefaultArgs> = $Result.GetResult<Prisma.$LoanSecurityPayload, S>

  type LoanSecurityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanSecurityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanSecurityCountAggregateInputType | true
    }

  export interface LoanSecurityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanSecurity'], meta: { name: 'LoanSecurity' } }
    /**
     * Find zero or one LoanSecurity that matches the filter.
     * @param {LoanSecurityFindUniqueArgs} args - Arguments to find a LoanSecurity
     * @example
     * // Get one LoanSecurity
     * const loanSecurity = await prisma.loanSecurity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanSecurityFindUniqueArgs>(args: SelectSubset<T, LoanSecurityFindUniqueArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoanSecurity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanSecurityFindUniqueOrThrowArgs} args - Arguments to find a LoanSecurity
     * @example
     * // Get one LoanSecurity
     * const loanSecurity = await prisma.loanSecurity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanSecurityFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanSecurityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanSecurity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanSecurityFindFirstArgs} args - Arguments to find a LoanSecurity
     * @example
     * // Get one LoanSecurity
     * const loanSecurity = await prisma.loanSecurity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanSecurityFindFirstArgs>(args?: SelectSubset<T, LoanSecurityFindFirstArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanSecurity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanSecurityFindFirstOrThrowArgs} args - Arguments to find a LoanSecurity
     * @example
     * // Get one LoanSecurity
     * const loanSecurity = await prisma.loanSecurity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanSecurityFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanSecurityFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoanSecurities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanSecurityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanSecurities
     * const loanSecurities = await prisma.loanSecurity.findMany()
     * 
     * // Get first 10 LoanSecurities
     * const loanSecurities = await prisma.loanSecurity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanSecurityWithIdOnly = await prisma.loanSecurity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanSecurityFindManyArgs>(args?: SelectSubset<T, LoanSecurityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoanSecurity.
     * @param {LoanSecurityCreateArgs} args - Arguments to create a LoanSecurity.
     * @example
     * // Create one LoanSecurity
     * const LoanSecurity = await prisma.loanSecurity.create({
     *   data: {
     *     // ... data to create a LoanSecurity
     *   }
     * })
     * 
     */
    create<T extends LoanSecurityCreateArgs>(args: SelectSubset<T, LoanSecurityCreateArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoanSecurities.
     * @param {LoanSecurityCreateManyArgs} args - Arguments to create many LoanSecurities.
     * @example
     * // Create many LoanSecurities
     * const loanSecurity = await prisma.loanSecurity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanSecurityCreateManyArgs>(args?: SelectSubset<T, LoanSecurityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanSecurities and returns the data saved in the database.
     * @param {LoanSecurityCreateManyAndReturnArgs} args - Arguments to create many LoanSecurities.
     * @example
     * // Create many LoanSecurities
     * const loanSecurity = await prisma.loanSecurity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanSecurities and only return the `id`
     * const loanSecurityWithIdOnly = await prisma.loanSecurity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanSecurityCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanSecurityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoanSecurity.
     * @param {LoanSecurityDeleteArgs} args - Arguments to delete one LoanSecurity.
     * @example
     * // Delete one LoanSecurity
     * const LoanSecurity = await prisma.loanSecurity.delete({
     *   where: {
     *     // ... filter to delete one LoanSecurity
     *   }
     * })
     * 
     */
    delete<T extends LoanSecurityDeleteArgs>(args: SelectSubset<T, LoanSecurityDeleteArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoanSecurity.
     * @param {LoanSecurityUpdateArgs} args - Arguments to update one LoanSecurity.
     * @example
     * // Update one LoanSecurity
     * const loanSecurity = await prisma.loanSecurity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanSecurityUpdateArgs>(args: SelectSubset<T, LoanSecurityUpdateArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoanSecurities.
     * @param {LoanSecurityDeleteManyArgs} args - Arguments to filter LoanSecurities to delete.
     * @example
     * // Delete a few LoanSecurities
     * const { count } = await prisma.loanSecurity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanSecurityDeleteManyArgs>(args?: SelectSubset<T, LoanSecurityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanSecurityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanSecurities
     * const loanSecurity = await prisma.loanSecurity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanSecurityUpdateManyArgs>(args: SelectSubset<T, LoanSecurityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanSecurities and returns the data updated in the database.
     * @param {LoanSecurityUpdateManyAndReturnArgs} args - Arguments to update many LoanSecurities.
     * @example
     * // Update many LoanSecurities
     * const loanSecurity = await prisma.loanSecurity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoanSecurities and only return the `id`
     * const loanSecurityWithIdOnly = await prisma.loanSecurity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanSecurityUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanSecurityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoanSecurity.
     * @param {LoanSecurityUpsertArgs} args - Arguments to update or create a LoanSecurity.
     * @example
     * // Update or create a LoanSecurity
     * const loanSecurity = await prisma.loanSecurity.upsert({
     *   create: {
     *     // ... data to create a LoanSecurity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanSecurity we want to update
     *   }
     * })
     */
    upsert<T extends LoanSecurityUpsertArgs>(args: SelectSubset<T, LoanSecurityUpsertArgs<ExtArgs>>): Prisma__LoanSecurityClient<$Result.GetResult<Prisma.$LoanSecurityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoanSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanSecurityCountArgs} args - Arguments to filter LoanSecurities to count.
     * @example
     * // Count the number of LoanSecurities
     * const count = await prisma.loanSecurity.count({
     *   where: {
     *     // ... the filter for the LoanSecurities we want to count
     *   }
     * })
    **/
    count<T extends LoanSecurityCountArgs>(
      args?: Subset<T, LoanSecurityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanSecurityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanSecurityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanSecurityAggregateArgs>(args: Subset<T, LoanSecurityAggregateArgs>): Prisma.PrismaPromise<GetLoanSecurityAggregateType<T>>

    /**
     * Group by LoanSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanSecurityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanSecurityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanSecurityGroupByArgs['orderBy'] }
        : { orderBy?: LoanSecurityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanSecurityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanSecurityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanSecurity model
   */
  readonly fields: LoanSecurityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanSecurity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanSecurityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanSecurity model
   */
  interface LoanSecurityFieldRefs {
    readonly id: FieldRef<"LoanSecurity", 'String'>
    readonly loanId: FieldRef<"LoanSecurity", 'String'>
    readonly idCopy: FieldRef<"LoanSecurity", 'Boolean'>
    readonly passportPhoto: FieldRef<"LoanSecurity", 'Boolean'>
    readonly appointmentLetter: FieldRef<"LoanSecurity", 'Boolean'>
    readonly payslips: FieldRef<"LoanSecurity", 'Boolean'>
    readonly bankStatement: FieldRef<"LoanSecurity", 'Boolean'>
    readonly chequeLeafNo: FieldRef<"LoanSecurity", 'String'>
    readonly createdAt: FieldRef<"LoanSecurity", 'DateTime'>
    readonly updatedAt: FieldRef<"LoanSecurity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanSecurity findUnique
   */
  export type LoanSecurityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * Filter, which LoanSecurity to fetch.
     */
    where: LoanSecurityWhereUniqueInput
  }

  /**
   * LoanSecurity findUniqueOrThrow
   */
  export type LoanSecurityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * Filter, which LoanSecurity to fetch.
     */
    where: LoanSecurityWhereUniqueInput
  }

  /**
   * LoanSecurity findFirst
   */
  export type LoanSecurityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * Filter, which LoanSecurity to fetch.
     */
    where?: LoanSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanSecurities to fetch.
     */
    orderBy?: LoanSecurityOrderByWithRelationInput | LoanSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanSecurities.
     */
    cursor?: LoanSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanSecurities.
     */
    distinct?: LoanSecurityScalarFieldEnum | LoanSecurityScalarFieldEnum[]
  }

  /**
   * LoanSecurity findFirstOrThrow
   */
  export type LoanSecurityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * Filter, which LoanSecurity to fetch.
     */
    where?: LoanSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanSecurities to fetch.
     */
    orderBy?: LoanSecurityOrderByWithRelationInput | LoanSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanSecurities.
     */
    cursor?: LoanSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanSecurities.
     */
    distinct?: LoanSecurityScalarFieldEnum | LoanSecurityScalarFieldEnum[]
  }

  /**
   * LoanSecurity findMany
   */
  export type LoanSecurityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * Filter, which LoanSecurities to fetch.
     */
    where?: LoanSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanSecurities to fetch.
     */
    orderBy?: LoanSecurityOrderByWithRelationInput | LoanSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanSecurities.
     */
    cursor?: LoanSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanSecurities.
     */
    skip?: number
    distinct?: LoanSecurityScalarFieldEnum | LoanSecurityScalarFieldEnum[]
  }

  /**
   * LoanSecurity create
   */
  export type LoanSecurityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanSecurity.
     */
    data: XOR<LoanSecurityCreateInput, LoanSecurityUncheckedCreateInput>
  }

  /**
   * LoanSecurity createMany
   */
  export type LoanSecurityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanSecurities.
     */
    data: LoanSecurityCreateManyInput | LoanSecurityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanSecurity createManyAndReturn
   */
  export type LoanSecurityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * The data used to create many LoanSecurities.
     */
    data: LoanSecurityCreateManyInput | LoanSecurityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanSecurity update
   */
  export type LoanSecurityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanSecurity.
     */
    data: XOR<LoanSecurityUpdateInput, LoanSecurityUncheckedUpdateInput>
    /**
     * Choose, which LoanSecurity to update.
     */
    where: LoanSecurityWhereUniqueInput
  }

  /**
   * LoanSecurity updateMany
   */
  export type LoanSecurityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanSecurities.
     */
    data: XOR<LoanSecurityUpdateManyMutationInput, LoanSecurityUncheckedUpdateManyInput>
    /**
     * Filter which LoanSecurities to update
     */
    where?: LoanSecurityWhereInput
    /**
     * Limit how many LoanSecurities to update.
     */
    limit?: number
  }

  /**
   * LoanSecurity updateManyAndReturn
   */
  export type LoanSecurityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * The data used to update LoanSecurities.
     */
    data: XOR<LoanSecurityUpdateManyMutationInput, LoanSecurityUncheckedUpdateManyInput>
    /**
     * Filter which LoanSecurities to update
     */
    where?: LoanSecurityWhereInput
    /**
     * Limit how many LoanSecurities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanSecurity upsert
   */
  export type LoanSecurityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanSecurity to update in case it exists.
     */
    where: LoanSecurityWhereUniqueInput
    /**
     * In case the LoanSecurity found by the `where` argument doesn't exist, create a new LoanSecurity with this data.
     */
    create: XOR<LoanSecurityCreateInput, LoanSecurityUncheckedCreateInput>
    /**
     * In case the LoanSecurity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanSecurityUpdateInput, LoanSecurityUncheckedUpdateInput>
  }

  /**
   * LoanSecurity delete
   */
  export type LoanSecurityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
    /**
     * Filter which LoanSecurity to delete.
     */
    where: LoanSecurityWhereUniqueInput
  }

  /**
   * LoanSecurity deleteMany
   */
  export type LoanSecurityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanSecurities to delete
     */
    where?: LoanSecurityWhereInput
    /**
     * Limit how many LoanSecurities to delete.
     */
    limit?: number
  }

  /**
   * LoanSecurity without action
   */
  export type LoanSecurityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanSecurity
     */
    select?: LoanSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanSecurity
     */
    omit?: LoanSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanSecurityInclude<ExtArgs> | null
  }


  /**
   * Model VehicleSecurity
   */

  export type AggregateVehicleSecurity = {
    _count: VehicleSecurityCountAggregateOutputType | null
    _avg: VehicleSecurityAvgAggregateOutputType | null
    _sum: VehicleSecuritySumAggregateOutputType | null
    _min: VehicleSecurityMinAggregateOutputType | null
    _max: VehicleSecurityMaxAggregateOutputType | null
  }

  export type VehicleSecurityAvgAggregateOutputType = {
    yearOfManufacture: number | null
  }

  export type VehicleSecuritySumAggregateOutputType = {
    yearOfManufacture: number | null
  }

  export type VehicleSecurityMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    registrationNumber: string | null
    chassisNumber: string | null
    engineNumber: string | null
    yearOfManufacture: number | null
    make: string | null
    model: string | null
    bodyColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleSecurityMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    registrationNumber: string | null
    chassisNumber: string | null
    engineNumber: string | null
    yearOfManufacture: number | null
    make: string | null
    model: string | null
    bodyColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleSecurityCountAggregateOutputType = {
    id: number
    loanId: number
    registrationNumber: number
    chassisNumber: number
    engineNumber: number
    yearOfManufacture: number
    make: number
    model: number
    bodyColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleSecurityAvgAggregateInputType = {
    yearOfManufacture?: true
  }

  export type VehicleSecuritySumAggregateInputType = {
    yearOfManufacture?: true
  }

  export type VehicleSecurityMinAggregateInputType = {
    id?: true
    loanId?: true
    registrationNumber?: true
    chassisNumber?: true
    engineNumber?: true
    yearOfManufacture?: true
    make?: true
    model?: true
    bodyColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleSecurityMaxAggregateInputType = {
    id?: true
    loanId?: true
    registrationNumber?: true
    chassisNumber?: true
    engineNumber?: true
    yearOfManufacture?: true
    make?: true
    model?: true
    bodyColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleSecurityCountAggregateInputType = {
    id?: true
    loanId?: true
    registrationNumber?: true
    chassisNumber?: true
    engineNumber?: true
    yearOfManufacture?: true
    make?: true
    model?: true
    bodyColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleSecurityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleSecurity to aggregate.
     */
    where?: VehicleSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleSecurities to fetch.
     */
    orderBy?: VehicleSecurityOrderByWithRelationInput | VehicleSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleSecurities
    **/
    _count?: true | VehicleSecurityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleSecurityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSecuritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleSecurityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleSecurityMaxAggregateInputType
  }

  export type GetVehicleSecurityAggregateType<T extends VehicleSecurityAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleSecurity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleSecurity[P]>
      : GetScalarType<T[P], AggregateVehicleSecurity[P]>
  }




  export type VehicleSecurityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleSecurityWhereInput
    orderBy?: VehicleSecurityOrderByWithAggregationInput | VehicleSecurityOrderByWithAggregationInput[]
    by: VehicleSecurityScalarFieldEnum[] | VehicleSecurityScalarFieldEnum
    having?: VehicleSecurityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleSecurityCountAggregateInputType | true
    _avg?: VehicleSecurityAvgAggregateInputType
    _sum?: VehicleSecuritySumAggregateInputType
    _min?: VehicleSecurityMinAggregateInputType
    _max?: VehicleSecurityMaxAggregateInputType
  }

  export type VehicleSecurityGroupByOutputType = {
    id: string
    loanId: string
    registrationNumber: string
    chassisNumber: string
    engineNumber: string
    yearOfManufacture: number
    make: string
    model: string
    bodyColor: string
    createdAt: Date
    updatedAt: Date
    _count: VehicleSecurityCountAggregateOutputType | null
    _avg: VehicleSecurityAvgAggregateOutputType | null
    _sum: VehicleSecuritySumAggregateOutputType | null
    _min: VehicleSecurityMinAggregateOutputType | null
    _max: VehicleSecurityMaxAggregateOutputType | null
  }

  type GetVehicleSecurityGroupByPayload<T extends VehicleSecurityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleSecurityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleSecurityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleSecurityGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleSecurityGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSecuritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    registrationNumber?: boolean
    chassisNumber?: boolean
    engineNumber?: boolean
    yearOfManufacture?: boolean
    make?: boolean
    model?: boolean
    bodyColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleSecurity"]>

  export type VehicleSecuritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    registrationNumber?: boolean
    chassisNumber?: boolean
    engineNumber?: boolean
    yearOfManufacture?: boolean
    make?: boolean
    model?: boolean
    bodyColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleSecurity"]>

  export type VehicleSecuritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    registrationNumber?: boolean
    chassisNumber?: boolean
    engineNumber?: boolean
    yearOfManufacture?: boolean
    make?: boolean
    model?: boolean
    bodyColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleSecurity"]>

  export type VehicleSecuritySelectScalar = {
    id?: boolean
    loanId?: boolean
    registrationNumber?: boolean
    chassisNumber?: boolean
    engineNumber?: boolean
    yearOfManufacture?: boolean
    make?: boolean
    model?: boolean
    bodyColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleSecurityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "registrationNumber" | "chassisNumber" | "engineNumber" | "yearOfManufacture" | "make" | "model" | "bodyColor" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicleSecurity"]>
  export type VehicleSecurityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type VehicleSecurityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type VehicleSecurityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $VehicleSecurityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleSecurity"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      registrationNumber: string
      chassisNumber: string
      engineNumber: string
      yearOfManufacture: number
      make: string
      model: string
      bodyColor: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicleSecurity"]>
    composites: {}
  }

  type VehicleSecurityGetPayload<S extends boolean | null | undefined | VehicleSecurityDefaultArgs> = $Result.GetResult<Prisma.$VehicleSecurityPayload, S>

  type VehicleSecurityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleSecurityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleSecurityCountAggregateInputType | true
    }

  export interface VehicleSecurityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleSecurity'], meta: { name: 'VehicleSecurity' } }
    /**
     * Find zero or one VehicleSecurity that matches the filter.
     * @param {VehicleSecurityFindUniqueArgs} args - Arguments to find a VehicleSecurity
     * @example
     * // Get one VehicleSecurity
     * const vehicleSecurity = await prisma.vehicleSecurity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleSecurityFindUniqueArgs>(args: SelectSubset<T, VehicleSecurityFindUniqueArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleSecurity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleSecurityFindUniqueOrThrowArgs} args - Arguments to find a VehicleSecurity
     * @example
     * // Get one VehicleSecurity
     * const vehicleSecurity = await prisma.vehicleSecurity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleSecurityFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleSecurityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleSecurity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleSecurityFindFirstArgs} args - Arguments to find a VehicleSecurity
     * @example
     * // Get one VehicleSecurity
     * const vehicleSecurity = await prisma.vehicleSecurity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleSecurityFindFirstArgs>(args?: SelectSubset<T, VehicleSecurityFindFirstArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleSecurity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleSecurityFindFirstOrThrowArgs} args - Arguments to find a VehicleSecurity
     * @example
     * // Get one VehicleSecurity
     * const vehicleSecurity = await prisma.vehicleSecurity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleSecurityFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleSecurityFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleSecurities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleSecurityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleSecurities
     * const vehicleSecurities = await prisma.vehicleSecurity.findMany()
     * 
     * // Get first 10 VehicleSecurities
     * const vehicleSecurities = await prisma.vehicleSecurity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleSecurityWithIdOnly = await prisma.vehicleSecurity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleSecurityFindManyArgs>(args?: SelectSubset<T, VehicleSecurityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleSecurity.
     * @param {VehicleSecurityCreateArgs} args - Arguments to create a VehicleSecurity.
     * @example
     * // Create one VehicleSecurity
     * const VehicleSecurity = await prisma.vehicleSecurity.create({
     *   data: {
     *     // ... data to create a VehicleSecurity
     *   }
     * })
     * 
     */
    create<T extends VehicleSecurityCreateArgs>(args: SelectSubset<T, VehicleSecurityCreateArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleSecurities.
     * @param {VehicleSecurityCreateManyArgs} args - Arguments to create many VehicleSecurities.
     * @example
     * // Create many VehicleSecurities
     * const vehicleSecurity = await prisma.vehicleSecurity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleSecurityCreateManyArgs>(args?: SelectSubset<T, VehicleSecurityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleSecurities and returns the data saved in the database.
     * @param {VehicleSecurityCreateManyAndReturnArgs} args - Arguments to create many VehicleSecurities.
     * @example
     * // Create many VehicleSecurities
     * const vehicleSecurity = await prisma.vehicleSecurity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleSecurities and only return the `id`
     * const vehicleSecurityWithIdOnly = await prisma.vehicleSecurity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleSecurityCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleSecurityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleSecurity.
     * @param {VehicleSecurityDeleteArgs} args - Arguments to delete one VehicleSecurity.
     * @example
     * // Delete one VehicleSecurity
     * const VehicleSecurity = await prisma.vehicleSecurity.delete({
     *   where: {
     *     // ... filter to delete one VehicleSecurity
     *   }
     * })
     * 
     */
    delete<T extends VehicleSecurityDeleteArgs>(args: SelectSubset<T, VehicleSecurityDeleteArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleSecurity.
     * @param {VehicleSecurityUpdateArgs} args - Arguments to update one VehicleSecurity.
     * @example
     * // Update one VehicleSecurity
     * const vehicleSecurity = await prisma.vehicleSecurity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleSecurityUpdateArgs>(args: SelectSubset<T, VehicleSecurityUpdateArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleSecurities.
     * @param {VehicleSecurityDeleteManyArgs} args - Arguments to filter VehicleSecurities to delete.
     * @example
     * // Delete a few VehicleSecurities
     * const { count } = await prisma.vehicleSecurity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleSecurityDeleteManyArgs>(args?: SelectSubset<T, VehicleSecurityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleSecurityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleSecurities
     * const vehicleSecurity = await prisma.vehicleSecurity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleSecurityUpdateManyArgs>(args: SelectSubset<T, VehicleSecurityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleSecurities and returns the data updated in the database.
     * @param {VehicleSecurityUpdateManyAndReturnArgs} args - Arguments to update many VehicleSecurities.
     * @example
     * // Update many VehicleSecurities
     * const vehicleSecurity = await prisma.vehicleSecurity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleSecurities and only return the `id`
     * const vehicleSecurityWithIdOnly = await prisma.vehicleSecurity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleSecurityUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleSecurityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleSecurity.
     * @param {VehicleSecurityUpsertArgs} args - Arguments to update or create a VehicleSecurity.
     * @example
     * // Update or create a VehicleSecurity
     * const vehicleSecurity = await prisma.vehicleSecurity.upsert({
     *   create: {
     *     // ... data to create a VehicleSecurity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleSecurity we want to update
     *   }
     * })
     */
    upsert<T extends VehicleSecurityUpsertArgs>(args: SelectSubset<T, VehicleSecurityUpsertArgs<ExtArgs>>): Prisma__VehicleSecurityClient<$Result.GetResult<Prisma.$VehicleSecurityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleSecurityCountArgs} args - Arguments to filter VehicleSecurities to count.
     * @example
     * // Count the number of VehicleSecurities
     * const count = await prisma.vehicleSecurity.count({
     *   where: {
     *     // ... the filter for the VehicleSecurities we want to count
     *   }
     * })
    **/
    count<T extends VehicleSecurityCountArgs>(
      args?: Subset<T, VehicleSecurityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleSecurityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleSecurityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleSecurityAggregateArgs>(args: Subset<T, VehicleSecurityAggregateArgs>): Prisma.PrismaPromise<GetVehicleSecurityAggregateType<T>>

    /**
     * Group by VehicleSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleSecurityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleSecurityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleSecurityGroupByArgs['orderBy'] }
        : { orderBy?: VehicleSecurityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleSecurityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleSecurityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleSecurity model
   */
  readonly fields: VehicleSecurityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleSecurity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleSecurityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleSecurity model
   */
  interface VehicleSecurityFieldRefs {
    readonly id: FieldRef<"VehicleSecurity", 'String'>
    readonly loanId: FieldRef<"VehicleSecurity", 'String'>
    readonly registrationNumber: FieldRef<"VehicleSecurity", 'String'>
    readonly chassisNumber: FieldRef<"VehicleSecurity", 'String'>
    readonly engineNumber: FieldRef<"VehicleSecurity", 'String'>
    readonly yearOfManufacture: FieldRef<"VehicleSecurity", 'Int'>
    readonly make: FieldRef<"VehicleSecurity", 'String'>
    readonly model: FieldRef<"VehicleSecurity", 'String'>
    readonly bodyColor: FieldRef<"VehicleSecurity", 'String'>
    readonly createdAt: FieldRef<"VehicleSecurity", 'DateTime'>
    readonly updatedAt: FieldRef<"VehicleSecurity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VehicleSecurity findUnique
   */
  export type VehicleSecurityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * Filter, which VehicleSecurity to fetch.
     */
    where: VehicleSecurityWhereUniqueInput
  }

  /**
   * VehicleSecurity findUniqueOrThrow
   */
  export type VehicleSecurityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * Filter, which VehicleSecurity to fetch.
     */
    where: VehicleSecurityWhereUniqueInput
  }

  /**
   * VehicleSecurity findFirst
   */
  export type VehicleSecurityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * Filter, which VehicleSecurity to fetch.
     */
    where?: VehicleSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleSecurities to fetch.
     */
    orderBy?: VehicleSecurityOrderByWithRelationInput | VehicleSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleSecurities.
     */
    cursor?: VehicleSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleSecurities.
     */
    distinct?: VehicleSecurityScalarFieldEnum | VehicleSecurityScalarFieldEnum[]
  }

  /**
   * VehicleSecurity findFirstOrThrow
   */
  export type VehicleSecurityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * Filter, which VehicleSecurity to fetch.
     */
    where?: VehicleSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleSecurities to fetch.
     */
    orderBy?: VehicleSecurityOrderByWithRelationInput | VehicleSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleSecurities.
     */
    cursor?: VehicleSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleSecurities.
     */
    distinct?: VehicleSecurityScalarFieldEnum | VehicleSecurityScalarFieldEnum[]
  }

  /**
   * VehicleSecurity findMany
   */
  export type VehicleSecurityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * Filter, which VehicleSecurities to fetch.
     */
    where?: VehicleSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleSecurities to fetch.
     */
    orderBy?: VehicleSecurityOrderByWithRelationInput | VehicleSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleSecurities.
     */
    cursor?: VehicleSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleSecurities.
     */
    skip?: number
    distinct?: VehicleSecurityScalarFieldEnum | VehicleSecurityScalarFieldEnum[]
  }

  /**
   * VehicleSecurity create
   */
  export type VehicleSecurityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleSecurity.
     */
    data: XOR<VehicleSecurityCreateInput, VehicleSecurityUncheckedCreateInput>
  }

  /**
   * VehicleSecurity createMany
   */
  export type VehicleSecurityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleSecurities.
     */
    data: VehicleSecurityCreateManyInput | VehicleSecurityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleSecurity createManyAndReturn
   */
  export type VehicleSecurityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleSecurities.
     */
    data: VehicleSecurityCreateManyInput | VehicleSecurityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleSecurity update
   */
  export type VehicleSecurityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleSecurity.
     */
    data: XOR<VehicleSecurityUpdateInput, VehicleSecurityUncheckedUpdateInput>
    /**
     * Choose, which VehicleSecurity to update.
     */
    where: VehicleSecurityWhereUniqueInput
  }

  /**
   * VehicleSecurity updateMany
   */
  export type VehicleSecurityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleSecurities.
     */
    data: XOR<VehicleSecurityUpdateManyMutationInput, VehicleSecurityUncheckedUpdateManyInput>
    /**
     * Filter which VehicleSecurities to update
     */
    where?: VehicleSecurityWhereInput
    /**
     * Limit how many VehicleSecurities to update.
     */
    limit?: number
  }

  /**
   * VehicleSecurity updateManyAndReturn
   */
  export type VehicleSecurityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * The data used to update VehicleSecurities.
     */
    data: XOR<VehicleSecurityUpdateManyMutationInput, VehicleSecurityUncheckedUpdateManyInput>
    /**
     * Filter which VehicleSecurities to update
     */
    where?: VehicleSecurityWhereInput
    /**
     * Limit how many VehicleSecurities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleSecurity upsert
   */
  export type VehicleSecurityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleSecurity to update in case it exists.
     */
    where: VehicleSecurityWhereUniqueInput
    /**
     * In case the VehicleSecurity found by the `where` argument doesn't exist, create a new VehicleSecurity with this data.
     */
    create: XOR<VehicleSecurityCreateInput, VehicleSecurityUncheckedCreateInput>
    /**
     * In case the VehicleSecurity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleSecurityUpdateInput, VehicleSecurityUncheckedUpdateInput>
  }

  /**
   * VehicleSecurity delete
   */
  export type VehicleSecurityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
    /**
     * Filter which VehicleSecurity to delete.
     */
    where: VehicleSecurityWhereUniqueInput
  }

  /**
   * VehicleSecurity deleteMany
   */
  export type VehicleSecurityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleSecurities to delete
     */
    where?: VehicleSecurityWhereInput
    /**
     * Limit how many VehicleSecurities to delete.
     */
    limit?: number
  }

  /**
   * VehicleSecurity without action
   */
  export type VehicleSecurityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleSecurity
     */
    select?: VehicleSecuritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleSecurity
     */
    omit?: VehicleSecurityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleSecurityInclude<ExtArgs> | null
  }


  /**
   * Model Guarantor
   */

  export type AggregateGuarantor = {
    _count: GuarantorCountAggregateOutputType | null
    _min: GuarantorMinAggregateOutputType | null
    _max: GuarantorMaxAggregateOutputType | null
  }

  export type GuarantorMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    fullName: string | null
    phone: string | null
    email: string | null
    idNumber: string | null
    relationship: string | null
    confirmationStatus: $Enums.GuarantorStatus | null
    confirmedAt: Date | null
    createdAt: Date | null
  }

  export type GuarantorMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    fullName: string | null
    phone: string | null
    email: string | null
    idNumber: string | null
    relationship: string | null
    confirmationStatus: $Enums.GuarantorStatus | null
    confirmedAt: Date | null
    createdAt: Date | null
  }

  export type GuarantorCountAggregateOutputType = {
    id: number
    loanId: number
    fullName: number
    phone: number
    email: number
    idNumber: number
    relationship: number
    confirmationStatus: number
    confirmedAt: number
    createdAt: number
    _all: number
  }


  export type GuarantorMinAggregateInputType = {
    id?: true
    loanId?: true
    fullName?: true
    phone?: true
    email?: true
    idNumber?: true
    relationship?: true
    confirmationStatus?: true
    confirmedAt?: true
    createdAt?: true
  }

  export type GuarantorMaxAggregateInputType = {
    id?: true
    loanId?: true
    fullName?: true
    phone?: true
    email?: true
    idNumber?: true
    relationship?: true
    confirmationStatus?: true
    confirmedAt?: true
    createdAt?: true
  }

  export type GuarantorCountAggregateInputType = {
    id?: true
    loanId?: true
    fullName?: true
    phone?: true
    email?: true
    idNumber?: true
    relationship?: true
    confirmationStatus?: true
    confirmedAt?: true
    createdAt?: true
    _all?: true
  }

  export type GuarantorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guarantor to aggregate.
     */
    where?: GuarantorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guarantors to fetch.
     */
    orderBy?: GuarantorOrderByWithRelationInput | GuarantorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuarantorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guarantors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guarantors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guarantors
    **/
    _count?: true | GuarantorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuarantorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuarantorMaxAggregateInputType
  }

  export type GetGuarantorAggregateType<T extends GuarantorAggregateArgs> = {
        [P in keyof T & keyof AggregateGuarantor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuarantor[P]>
      : GetScalarType<T[P], AggregateGuarantor[P]>
  }




  export type GuarantorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuarantorWhereInput
    orderBy?: GuarantorOrderByWithAggregationInput | GuarantorOrderByWithAggregationInput[]
    by: GuarantorScalarFieldEnum[] | GuarantorScalarFieldEnum
    having?: GuarantorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuarantorCountAggregateInputType | true
    _min?: GuarantorMinAggregateInputType
    _max?: GuarantorMaxAggregateInputType
  }

  export type GuarantorGroupByOutputType = {
    id: string
    loanId: string
    fullName: string
    phone: string
    email: string | null
    idNumber: string | null
    relationship: string | null
    confirmationStatus: $Enums.GuarantorStatus
    confirmedAt: Date | null
    createdAt: Date
    _count: GuarantorCountAggregateOutputType | null
    _min: GuarantorMinAggregateOutputType | null
    _max: GuarantorMaxAggregateOutputType | null
  }

  type GetGuarantorGroupByPayload<T extends GuarantorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuarantorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuarantorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuarantorGroupByOutputType[P]>
            : GetScalarType<T[P], GuarantorGroupByOutputType[P]>
        }
      >
    >


  export type GuarantorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    idNumber?: boolean
    relationship?: boolean
    confirmationStatus?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guarantor"]>

  export type GuarantorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    idNumber?: boolean
    relationship?: boolean
    confirmationStatus?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guarantor"]>

  export type GuarantorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    idNumber?: boolean
    relationship?: boolean
    confirmationStatus?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guarantor"]>

  export type GuarantorSelectScalar = {
    id?: boolean
    loanId?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    idNumber?: boolean
    relationship?: boolean
    confirmationStatus?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
  }

  export type GuarantorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "fullName" | "phone" | "email" | "idNumber" | "relationship" | "confirmationStatus" | "confirmedAt" | "createdAt", ExtArgs["result"]["guarantor"]>
  export type GuarantorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type GuarantorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type GuarantorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $GuarantorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guarantor"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      fullName: string
      phone: string
      email: string | null
      idNumber: string | null
      relationship: string | null
      confirmationStatus: $Enums.GuarantorStatus
      confirmedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["guarantor"]>
    composites: {}
  }

  type GuarantorGetPayload<S extends boolean | null | undefined | GuarantorDefaultArgs> = $Result.GetResult<Prisma.$GuarantorPayload, S>

  type GuarantorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuarantorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuarantorCountAggregateInputType | true
    }

  export interface GuarantorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guarantor'], meta: { name: 'Guarantor' } }
    /**
     * Find zero or one Guarantor that matches the filter.
     * @param {GuarantorFindUniqueArgs} args - Arguments to find a Guarantor
     * @example
     * // Get one Guarantor
     * const guarantor = await prisma.guarantor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuarantorFindUniqueArgs>(args: SelectSubset<T, GuarantorFindUniqueArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guarantor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuarantorFindUniqueOrThrowArgs} args - Arguments to find a Guarantor
     * @example
     * // Get one Guarantor
     * const guarantor = await prisma.guarantor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuarantorFindUniqueOrThrowArgs>(args: SelectSubset<T, GuarantorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guarantor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorFindFirstArgs} args - Arguments to find a Guarantor
     * @example
     * // Get one Guarantor
     * const guarantor = await prisma.guarantor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuarantorFindFirstArgs>(args?: SelectSubset<T, GuarantorFindFirstArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guarantor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorFindFirstOrThrowArgs} args - Arguments to find a Guarantor
     * @example
     * // Get one Guarantor
     * const guarantor = await prisma.guarantor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuarantorFindFirstOrThrowArgs>(args?: SelectSubset<T, GuarantorFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guarantors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guarantors
     * const guarantors = await prisma.guarantor.findMany()
     * 
     * // Get first 10 Guarantors
     * const guarantors = await prisma.guarantor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guarantorWithIdOnly = await prisma.guarantor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuarantorFindManyArgs>(args?: SelectSubset<T, GuarantorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guarantor.
     * @param {GuarantorCreateArgs} args - Arguments to create a Guarantor.
     * @example
     * // Create one Guarantor
     * const Guarantor = await prisma.guarantor.create({
     *   data: {
     *     // ... data to create a Guarantor
     *   }
     * })
     * 
     */
    create<T extends GuarantorCreateArgs>(args: SelectSubset<T, GuarantorCreateArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guarantors.
     * @param {GuarantorCreateManyArgs} args - Arguments to create many Guarantors.
     * @example
     * // Create many Guarantors
     * const guarantor = await prisma.guarantor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuarantorCreateManyArgs>(args?: SelectSubset<T, GuarantorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guarantors and returns the data saved in the database.
     * @param {GuarantorCreateManyAndReturnArgs} args - Arguments to create many Guarantors.
     * @example
     * // Create many Guarantors
     * const guarantor = await prisma.guarantor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guarantors and only return the `id`
     * const guarantorWithIdOnly = await prisma.guarantor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuarantorCreateManyAndReturnArgs>(args?: SelectSubset<T, GuarantorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Guarantor.
     * @param {GuarantorDeleteArgs} args - Arguments to delete one Guarantor.
     * @example
     * // Delete one Guarantor
     * const Guarantor = await prisma.guarantor.delete({
     *   where: {
     *     // ... filter to delete one Guarantor
     *   }
     * })
     * 
     */
    delete<T extends GuarantorDeleteArgs>(args: SelectSubset<T, GuarantorDeleteArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guarantor.
     * @param {GuarantorUpdateArgs} args - Arguments to update one Guarantor.
     * @example
     * // Update one Guarantor
     * const guarantor = await prisma.guarantor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuarantorUpdateArgs>(args: SelectSubset<T, GuarantorUpdateArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guarantors.
     * @param {GuarantorDeleteManyArgs} args - Arguments to filter Guarantors to delete.
     * @example
     * // Delete a few Guarantors
     * const { count } = await prisma.guarantor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuarantorDeleteManyArgs>(args?: SelectSubset<T, GuarantorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guarantors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guarantors
     * const guarantor = await prisma.guarantor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuarantorUpdateManyArgs>(args: SelectSubset<T, GuarantorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guarantors and returns the data updated in the database.
     * @param {GuarantorUpdateManyAndReturnArgs} args - Arguments to update many Guarantors.
     * @example
     * // Update many Guarantors
     * const guarantor = await prisma.guarantor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guarantors and only return the `id`
     * const guarantorWithIdOnly = await prisma.guarantor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuarantorUpdateManyAndReturnArgs>(args: SelectSubset<T, GuarantorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Guarantor.
     * @param {GuarantorUpsertArgs} args - Arguments to update or create a Guarantor.
     * @example
     * // Update or create a Guarantor
     * const guarantor = await prisma.guarantor.upsert({
     *   create: {
     *     // ... data to create a Guarantor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guarantor we want to update
     *   }
     * })
     */
    upsert<T extends GuarantorUpsertArgs>(args: SelectSubset<T, GuarantorUpsertArgs<ExtArgs>>): Prisma__GuarantorClient<$Result.GetResult<Prisma.$GuarantorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guarantors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorCountArgs} args - Arguments to filter Guarantors to count.
     * @example
     * // Count the number of Guarantors
     * const count = await prisma.guarantor.count({
     *   where: {
     *     // ... the filter for the Guarantors we want to count
     *   }
     * })
    **/
    count<T extends GuarantorCountArgs>(
      args?: Subset<T, GuarantorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuarantorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guarantor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuarantorAggregateArgs>(args: Subset<T, GuarantorAggregateArgs>): Prisma.PrismaPromise<GetGuarantorAggregateType<T>>

    /**
     * Group by Guarantor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuarantorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuarantorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuarantorGroupByArgs['orderBy'] }
        : { orderBy?: GuarantorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuarantorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuarantorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guarantor model
   */
  readonly fields: GuarantorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guarantor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuarantorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guarantor model
   */
  interface GuarantorFieldRefs {
    readonly id: FieldRef<"Guarantor", 'String'>
    readonly loanId: FieldRef<"Guarantor", 'String'>
    readonly fullName: FieldRef<"Guarantor", 'String'>
    readonly phone: FieldRef<"Guarantor", 'String'>
    readonly email: FieldRef<"Guarantor", 'String'>
    readonly idNumber: FieldRef<"Guarantor", 'String'>
    readonly relationship: FieldRef<"Guarantor", 'String'>
    readonly confirmationStatus: FieldRef<"Guarantor", 'GuarantorStatus'>
    readonly confirmedAt: FieldRef<"Guarantor", 'DateTime'>
    readonly createdAt: FieldRef<"Guarantor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guarantor findUnique
   */
  export type GuarantorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * Filter, which Guarantor to fetch.
     */
    where: GuarantorWhereUniqueInput
  }

  /**
   * Guarantor findUniqueOrThrow
   */
  export type GuarantorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * Filter, which Guarantor to fetch.
     */
    where: GuarantorWhereUniqueInput
  }

  /**
   * Guarantor findFirst
   */
  export type GuarantorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * Filter, which Guarantor to fetch.
     */
    where?: GuarantorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guarantors to fetch.
     */
    orderBy?: GuarantorOrderByWithRelationInput | GuarantorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guarantors.
     */
    cursor?: GuarantorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guarantors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guarantors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guarantors.
     */
    distinct?: GuarantorScalarFieldEnum | GuarantorScalarFieldEnum[]
  }

  /**
   * Guarantor findFirstOrThrow
   */
  export type GuarantorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * Filter, which Guarantor to fetch.
     */
    where?: GuarantorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guarantors to fetch.
     */
    orderBy?: GuarantorOrderByWithRelationInput | GuarantorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guarantors.
     */
    cursor?: GuarantorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guarantors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guarantors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guarantors.
     */
    distinct?: GuarantorScalarFieldEnum | GuarantorScalarFieldEnum[]
  }

  /**
   * Guarantor findMany
   */
  export type GuarantorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * Filter, which Guarantors to fetch.
     */
    where?: GuarantorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guarantors to fetch.
     */
    orderBy?: GuarantorOrderByWithRelationInput | GuarantorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guarantors.
     */
    cursor?: GuarantorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guarantors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guarantors.
     */
    skip?: number
    distinct?: GuarantorScalarFieldEnum | GuarantorScalarFieldEnum[]
  }

  /**
   * Guarantor create
   */
  export type GuarantorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * The data needed to create a Guarantor.
     */
    data: XOR<GuarantorCreateInput, GuarantorUncheckedCreateInput>
  }

  /**
   * Guarantor createMany
   */
  export type GuarantorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guarantors.
     */
    data: GuarantorCreateManyInput | GuarantorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guarantor createManyAndReturn
   */
  export type GuarantorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * The data used to create many Guarantors.
     */
    data: GuarantorCreateManyInput | GuarantorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Guarantor update
   */
  export type GuarantorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * The data needed to update a Guarantor.
     */
    data: XOR<GuarantorUpdateInput, GuarantorUncheckedUpdateInput>
    /**
     * Choose, which Guarantor to update.
     */
    where: GuarantorWhereUniqueInput
  }

  /**
   * Guarantor updateMany
   */
  export type GuarantorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guarantors.
     */
    data: XOR<GuarantorUpdateManyMutationInput, GuarantorUncheckedUpdateManyInput>
    /**
     * Filter which Guarantors to update
     */
    where?: GuarantorWhereInput
    /**
     * Limit how many Guarantors to update.
     */
    limit?: number
  }

  /**
   * Guarantor updateManyAndReturn
   */
  export type GuarantorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * The data used to update Guarantors.
     */
    data: XOR<GuarantorUpdateManyMutationInput, GuarantorUncheckedUpdateManyInput>
    /**
     * Filter which Guarantors to update
     */
    where?: GuarantorWhereInput
    /**
     * Limit how many Guarantors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Guarantor upsert
   */
  export type GuarantorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * The filter to search for the Guarantor to update in case it exists.
     */
    where: GuarantorWhereUniqueInput
    /**
     * In case the Guarantor found by the `where` argument doesn't exist, create a new Guarantor with this data.
     */
    create: XOR<GuarantorCreateInput, GuarantorUncheckedCreateInput>
    /**
     * In case the Guarantor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuarantorUpdateInput, GuarantorUncheckedUpdateInput>
  }

  /**
   * Guarantor delete
   */
  export type GuarantorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
    /**
     * Filter which Guarantor to delete.
     */
    where: GuarantorWhereUniqueInput
  }

  /**
   * Guarantor deleteMany
   */
  export type GuarantorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guarantors to delete
     */
    where?: GuarantorWhereInput
    /**
     * Limit how many Guarantors to delete.
     */
    limit?: number
  }

  /**
   * Guarantor without action
   */
  export type GuarantorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guarantor
     */
    select?: GuarantorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guarantor
     */
    omit?: GuarantorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuarantorInclude<ExtArgs> | null
  }


  /**
   * Model LoanDisbursement
   */

  export type AggregateLoanDisbursement = {
    _count: LoanDisbursementCountAggregateOutputType | null
    _avg: LoanDisbursementAvgAggregateOutputType | null
    _sum: LoanDisbursementSumAggregateOutputType | null
    _min: LoanDisbursementMinAggregateOutputType | null
    _max: LoanDisbursementMaxAggregateOutputType | null
  }

  export type LoanDisbursementAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type LoanDisbursementSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type LoanDisbursementMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    amount: Decimal | null
    method: $Enums.DisbursementMethod | null
    reference: string | null
    disbursedAt: Date | null
    createdAt: Date | null
  }

  export type LoanDisbursementMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    amount: Decimal | null
    method: $Enums.DisbursementMethod | null
    reference: string | null
    disbursedAt: Date | null
    createdAt: Date | null
  }

  export type LoanDisbursementCountAggregateOutputType = {
    id: number
    loanId: number
    amount: number
    method: number
    reference: number
    disbursedAt: number
    createdAt: number
    _all: number
  }


  export type LoanDisbursementAvgAggregateInputType = {
    amount?: true
  }

  export type LoanDisbursementSumAggregateInputType = {
    amount?: true
  }

  export type LoanDisbursementMinAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    method?: true
    reference?: true
    disbursedAt?: true
    createdAt?: true
  }

  export type LoanDisbursementMaxAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    method?: true
    reference?: true
    disbursedAt?: true
    createdAt?: true
  }

  export type LoanDisbursementCountAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    method?: true
    reference?: true
    disbursedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LoanDisbursementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanDisbursement to aggregate.
     */
    where?: LoanDisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDisbursements to fetch.
     */
    orderBy?: LoanDisbursementOrderByWithRelationInput | LoanDisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanDisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDisbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDisbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanDisbursements
    **/
    _count?: true | LoanDisbursementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanDisbursementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanDisbursementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanDisbursementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanDisbursementMaxAggregateInputType
  }

  export type GetLoanDisbursementAggregateType<T extends LoanDisbursementAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanDisbursement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanDisbursement[P]>
      : GetScalarType<T[P], AggregateLoanDisbursement[P]>
  }




  export type LoanDisbursementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanDisbursementWhereInput
    orderBy?: LoanDisbursementOrderByWithAggregationInput | LoanDisbursementOrderByWithAggregationInput[]
    by: LoanDisbursementScalarFieldEnum[] | LoanDisbursementScalarFieldEnum
    having?: LoanDisbursementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanDisbursementCountAggregateInputType | true
    _avg?: LoanDisbursementAvgAggregateInputType
    _sum?: LoanDisbursementSumAggregateInputType
    _min?: LoanDisbursementMinAggregateInputType
    _max?: LoanDisbursementMaxAggregateInputType
  }

  export type LoanDisbursementGroupByOutputType = {
    id: string
    loanId: string
    amount: Decimal
    method: $Enums.DisbursementMethod
    reference: string | null
    disbursedAt: Date
    createdAt: Date
    _count: LoanDisbursementCountAggregateOutputType | null
    _avg: LoanDisbursementAvgAggregateOutputType | null
    _sum: LoanDisbursementSumAggregateOutputType | null
    _min: LoanDisbursementMinAggregateOutputType | null
    _max: LoanDisbursementMaxAggregateOutputType | null
  }

  type GetLoanDisbursementGroupByPayload<T extends LoanDisbursementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanDisbursementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanDisbursementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanDisbursementGroupByOutputType[P]>
            : GetScalarType<T[P], LoanDisbursementGroupByOutputType[P]>
        }
      >
    >


  export type LoanDisbursementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    disbursedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanDisbursement"]>

  export type LoanDisbursementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    disbursedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanDisbursement"]>

  export type LoanDisbursementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    disbursedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanDisbursement"]>

  export type LoanDisbursementSelectScalar = {
    id?: boolean
    loanId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    disbursedAt?: boolean
    createdAt?: boolean
  }

  export type LoanDisbursementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "amount" | "method" | "reference" | "disbursedAt" | "createdAt", ExtArgs["result"]["loanDisbursement"]>
  export type LoanDisbursementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanDisbursementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanDisbursementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $LoanDisbursementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanDisbursement"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      amount: Prisma.Decimal
      method: $Enums.DisbursementMethod
      reference: string | null
      disbursedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["loanDisbursement"]>
    composites: {}
  }

  type LoanDisbursementGetPayload<S extends boolean | null | undefined | LoanDisbursementDefaultArgs> = $Result.GetResult<Prisma.$LoanDisbursementPayload, S>

  type LoanDisbursementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanDisbursementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanDisbursementCountAggregateInputType | true
    }

  export interface LoanDisbursementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanDisbursement'], meta: { name: 'LoanDisbursement' } }
    /**
     * Find zero or one LoanDisbursement that matches the filter.
     * @param {LoanDisbursementFindUniqueArgs} args - Arguments to find a LoanDisbursement
     * @example
     * // Get one LoanDisbursement
     * const loanDisbursement = await prisma.loanDisbursement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanDisbursementFindUniqueArgs>(args: SelectSubset<T, LoanDisbursementFindUniqueArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoanDisbursement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanDisbursementFindUniqueOrThrowArgs} args - Arguments to find a LoanDisbursement
     * @example
     * // Get one LoanDisbursement
     * const loanDisbursement = await prisma.loanDisbursement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanDisbursementFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanDisbursementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanDisbursement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDisbursementFindFirstArgs} args - Arguments to find a LoanDisbursement
     * @example
     * // Get one LoanDisbursement
     * const loanDisbursement = await prisma.loanDisbursement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanDisbursementFindFirstArgs>(args?: SelectSubset<T, LoanDisbursementFindFirstArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanDisbursement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDisbursementFindFirstOrThrowArgs} args - Arguments to find a LoanDisbursement
     * @example
     * // Get one LoanDisbursement
     * const loanDisbursement = await prisma.loanDisbursement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanDisbursementFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanDisbursementFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoanDisbursements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDisbursementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanDisbursements
     * const loanDisbursements = await prisma.loanDisbursement.findMany()
     * 
     * // Get first 10 LoanDisbursements
     * const loanDisbursements = await prisma.loanDisbursement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanDisbursementWithIdOnly = await prisma.loanDisbursement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanDisbursementFindManyArgs>(args?: SelectSubset<T, LoanDisbursementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoanDisbursement.
     * @param {LoanDisbursementCreateArgs} args - Arguments to create a LoanDisbursement.
     * @example
     * // Create one LoanDisbursement
     * const LoanDisbursement = await prisma.loanDisbursement.create({
     *   data: {
     *     // ... data to create a LoanDisbursement
     *   }
     * })
     * 
     */
    create<T extends LoanDisbursementCreateArgs>(args: SelectSubset<T, LoanDisbursementCreateArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoanDisbursements.
     * @param {LoanDisbursementCreateManyArgs} args - Arguments to create many LoanDisbursements.
     * @example
     * // Create many LoanDisbursements
     * const loanDisbursement = await prisma.loanDisbursement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanDisbursementCreateManyArgs>(args?: SelectSubset<T, LoanDisbursementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanDisbursements and returns the data saved in the database.
     * @param {LoanDisbursementCreateManyAndReturnArgs} args - Arguments to create many LoanDisbursements.
     * @example
     * // Create many LoanDisbursements
     * const loanDisbursement = await prisma.loanDisbursement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanDisbursements and only return the `id`
     * const loanDisbursementWithIdOnly = await prisma.loanDisbursement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanDisbursementCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanDisbursementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoanDisbursement.
     * @param {LoanDisbursementDeleteArgs} args - Arguments to delete one LoanDisbursement.
     * @example
     * // Delete one LoanDisbursement
     * const LoanDisbursement = await prisma.loanDisbursement.delete({
     *   where: {
     *     // ... filter to delete one LoanDisbursement
     *   }
     * })
     * 
     */
    delete<T extends LoanDisbursementDeleteArgs>(args: SelectSubset<T, LoanDisbursementDeleteArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoanDisbursement.
     * @param {LoanDisbursementUpdateArgs} args - Arguments to update one LoanDisbursement.
     * @example
     * // Update one LoanDisbursement
     * const loanDisbursement = await prisma.loanDisbursement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanDisbursementUpdateArgs>(args: SelectSubset<T, LoanDisbursementUpdateArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoanDisbursements.
     * @param {LoanDisbursementDeleteManyArgs} args - Arguments to filter LoanDisbursements to delete.
     * @example
     * // Delete a few LoanDisbursements
     * const { count } = await prisma.loanDisbursement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanDisbursementDeleteManyArgs>(args?: SelectSubset<T, LoanDisbursementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanDisbursements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDisbursementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanDisbursements
     * const loanDisbursement = await prisma.loanDisbursement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanDisbursementUpdateManyArgs>(args: SelectSubset<T, LoanDisbursementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanDisbursements and returns the data updated in the database.
     * @param {LoanDisbursementUpdateManyAndReturnArgs} args - Arguments to update many LoanDisbursements.
     * @example
     * // Update many LoanDisbursements
     * const loanDisbursement = await prisma.loanDisbursement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoanDisbursements and only return the `id`
     * const loanDisbursementWithIdOnly = await prisma.loanDisbursement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanDisbursementUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanDisbursementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoanDisbursement.
     * @param {LoanDisbursementUpsertArgs} args - Arguments to update or create a LoanDisbursement.
     * @example
     * // Update or create a LoanDisbursement
     * const loanDisbursement = await prisma.loanDisbursement.upsert({
     *   create: {
     *     // ... data to create a LoanDisbursement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanDisbursement we want to update
     *   }
     * })
     */
    upsert<T extends LoanDisbursementUpsertArgs>(args: SelectSubset<T, LoanDisbursementUpsertArgs<ExtArgs>>): Prisma__LoanDisbursementClient<$Result.GetResult<Prisma.$LoanDisbursementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoanDisbursements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDisbursementCountArgs} args - Arguments to filter LoanDisbursements to count.
     * @example
     * // Count the number of LoanDisbursements
     * const count = await prisma.loanDisbursement.count({
     *   where: {
     *     // ... the filter for the LoanDisbursements we want to count
     *   }
     * })
    **/
    count<T extends LoanDisbursementCountArgs>(
      args?: Subset<T, LoanDisbursementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanDisbursementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanDisbursement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDisbursementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanDisbursementAggregateArgs>(args: Subset<T, LoanDisbursementAggregateArgs>): Prisma.PrismaPromise<GetLoanDisbursementAggregateType<T>>

    /**
     * Group by LoanDisbursement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanDisbursementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanDisbursementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanDisbursementGroupByArgs['orderBy'] }
        : { orderBy?: LoanDisbursementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanDisbursementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanDisbursementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanDisbursement model
   */
  readonly fields: LoanDisbursementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanDisbursement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanDisbursementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanDisbursement model
   */
  interface LoanDisbursementFieldRefs {
    readonly id: FieldRef<"LoanDisbursement", 'String'>
    readonly loanId: FieldRef<"LoanDisbursement", 'String'>
    readonly amount: FieldRef<"LoanDisbursement", 'Decimal'>
    readonly method: FieldRef<"LoanDisbursement", 'DisbursementMethod'>
    readonly reference: FieldRef<"LoanDisbursement", 'String'>
    readonly disbursedAt: FieldRef<"LoanDisbursement", 'DateTime'>
    readonly createdAt: FieldRef<"LoanDisbursement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanDisbursement findUnique
   */
  export type LoanDisbursementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * Filter, which LoanDisbursement to fetch.
     */
    where: LoanDisbursementWhereUniqueInput
  }

  /**
   * LoanDisbursement findUniqueOrThrow
   */
  export type LoanDisbursementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * Filter, which LoanDisbursement to fetch.
     */
    where: LoanDisbursementWhereUniqueInput
  }

  /**
   * LoanDisbursement findFirst
   */
  export type LoanDisbursementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * Filter, which LoanDisbursement to fetch.
     */
    where?: LoanDisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDisbursements to fetch.
     */
    orderBy?: LoanDisbursementOrderByWithRelationInput | LoanDisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanDisbursements.
     */
    cursor?: LoanDisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDisbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDisbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanDisbursements.
     */
    distinct?: LoanDisbursementScalarFieldEnum | LoanDisbursementScalarFieldEnum[]
  }

  /**
   * LoanDisbursement findFirstOrThrow
   */
  export type LoanDisbursementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * Filter, which LoanDisbursement to fetch.
     */
    where?: LoanDisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDisbursements to fetch.
     */
    orderBy?: LoanDisbursementOrderByWithRelationInput | LoanDisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanDisbursements.
     */
    cursor?: LoanDisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDisbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDisbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanDisbursements.
     */
    distinct?: LoanDisbursementScalarFieldEnum | LoanDisbursementScalarFieldEnum[]
  }

  /**
   * LoanDisbursement findMany
   */
  export type LoanDisbursementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * Filter, which LoanDisbursements to fetch.
     */
    where?: LoanDisbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanDisbursements to fetch.
     */
    orderBy?: LoanDisbursementOrderByWithRelationInput | LoanDisbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanDisbursements.
     */
    cursor?: LoanDisbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanDisbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanDisbursements.
     */
    skip?: number
    distinct?: LoanDisbursementScalarFieldEnum | LoanDisbursementScalarFieldEnum[]
  }

  /**
   * LoanDisbursement create
   */
  export type LoanDisbursementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanDisbursement.
     */
    data: XOR<LoanDisbursementCreateInput, LoanDisbursementUncheckedCreateInput>
  }

  /**
   * LoanDisbursement createMany
   */
  export type LoanDisbursementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanDisbursements.
     */
    data: LoanDisbursementCreateManyInput | LoanDisbursementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanDisbursement createManyAndReturn
   */
  export type LoanDisbursementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * The data used to create many LoanDisbursements.
     */
    data: LoanDisbursementCreateManyInput | LoanDisbursementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanDisbursement update
   */
  export type LoanDisbursementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanDisbursement.
     */
    data: XOR<LoanDisbursementUpdateInput, LoanDisbursementUncheckedUpdateInput>
    /**
     * Choose, which LoanDisbursement to update.
     */
    where: LoanDisbursementWhereUniqueInput
  }

  /**
   * LoanDisbursement updateMany
   */
  export type LoanDisbursementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanDisbursements.
     */
    data: XOR<LoanDisbursementUpdateManyMutationInput, LoanDisbursementUncheckedUpdateManyInput>
    /**
     * Filter which LoanDisbursements to update
     */
    where?: LoanDisbursementWhereInput
    /**
     * Limit how many LoanDisbursements to update.
     */
    limit?: number
  }

  /**
   * LoanDisbursement updateManyAndReturn
   */
  export type LoanDisbursementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * The data used to update LoanDisbursements.
     */
    data: XOR<LoanDisbursementUpdateManyMutationInput, LoanDisbursementUncheckedUpdateManyInput>
    /**
     * Filter which LoanDisbursements to update
     */
    where?: LoanDisbursementWhereInput
    /**
     * Limit how many LoanDisbursements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanDisbursement upsert
   */
  export type LoanDisbursementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanDisbursement to update in case it exists.
     */
    where: LoanDisbursementWhereUniqueInput
    /**
     * In case the LoanDisbursement found by the `where` argument doesn't exist, create a new LoanDisbursement with this data.
     */
    create: XOR<LoanDisbursementCreateInput, LoanDisbursementUncheckedCreateInput>
    /**
     * In case the LoanDisbursement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanDisbursementUpdateInput, LoanDisbursementUncheckedUpdateInput>
  }

  /**
   * LoanDisbursement delete
   */
  export type LoanDisbursementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
    /**
     * Filter which LoanDisbursement to delete.
     */
    where: LoanDisbursementWhereUniqueInput
  }

  /**
   * LoanDisbursement deleteMany
   */
  export type LoanDisbursementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanDisbursements to delete
     */
    where?: LoanDisbursementWhereInput
    /**
     * Limit how many LoanDisbursements to delete.
     */
    limit?: number
  }

  /**
   * LoanDisbursement without action
   */
  export type LoanDisbursementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanDisbursement
     */
    select?: LoanDisbursementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanDisbursement
     */
    omit?: LoanDisbursementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanDisbursementInclude<ExtArgs> | null
  }


  /**
   * Model LoanFinancial
   */

  export type AggregateLoanFinancial = {
    _count: LoanFinancialCountAggregateOutputType | null
    _avg: LoanFinancialAvgAggregateOutputType | null
    _sum: LoanFinancialSumAggregateOutputType | null
    _min: LoanFinancialMinAggregateOutputType | null
    _max: LoanFinancialMaxAggregateOutputType | null
  }

  export type LoanFinancialAvgAggregateOutputType = {
    processingFee: Decimal | null
    legalFee: Decimal | null
    penaltyFee: Decimal | null
    interestAmount: Decimal | null
  }

  export type LoanFinancialSumAggregateOutputType = {
    processingFee: Decimal | null
    legalFee: Decimal | null
    penaltyFee: Decimal | null
    interestAmount: Decimal | null
  }

  export type LoanFinancialMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    processingFee: Decimal | null
    legalFee: Decimal | null
    penaltyFee: Decimal | null
    interestAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanFinancialMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    processingFee: Decimal | null
    legalFee: Decimal | null
    penaltyFee: Decimal | null
    interestAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanFinancialCountAggregateOutputType = {
    id: number
    loanId: number
    processingFee: number
    legalFee: number
    penaltyFee: number
    interestAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanFinancialAvgAggregateInputType = {
    processingFee?: true
    legalFee?: true
    penaltyFee?: true
    interestAmount?: true
  }

  export type LoanFinancialSumAggregateInputType = {
    processingFee?: true
    legalFee?: true
    penaltyFee?: true
    interestAmount?: true
  }

  export type LoanFinancialMinAggregateInputType = {
    id?: true
    loanId?: true
    processingFee?: true
    legalFee?: true
    penaltyFee?: true
    interestAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanFinancialMaxAggregateInputType = {
    id?: true
    loanId?: true
    processingFee?: true
    legalFee?: true
    penaltyFee?: true
    interestAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanFinancialCountAggregateInputType = {
    id?: true
    loanId?: true
    processingFee?: true
    legalFee?: true
    penaltyFee?: true
    interestAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanFinancialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanFinancial to aggregate.
     */
    where?: LoanFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanFinancials to fetch.
     */
    orderBy?: LoanFinancialOrderByWithRelationInput | LoanFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanFinancials
    **/
    _count?: true | LoanFinancialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanFinancialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanFinancialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanFinancialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanFinancialMaxAggregateInputType
  }

  export type GetLoanFinancialAggregateType<T extends LoanFinancialAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanFinancial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanFinancial[P]>
      : GetScalarType<T[P], AggregateLoanFinancial[P]>
  }




  export type LoanFinancialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanFinancialWhereInput
    orderBy?: LoanFinancialOrderByWithAggregationInput | LoanFinancialOrderByWithAggregationInput[]
    by: LoanFinancialScalarFieldEnum[] | LoanFinancialScalarFieldEnum
    having?: LoanFinancialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanFinancialCountAggregateInputType | true
    _avg?: LoanFinancialAvgAggregateInputType
    _sum?: LoanFinancialSumAggregateInputType
    _min?: LoanFinancialMinAggregateInputType
    _max?: LoanFinancialMaxAggregateInputType
  }

  export type LoanFinancialGroupByOutputType = {
    id: string
    loanId: string
    processingFee: Decimal
    legalFee: Decimal
    penaltyFee: Decimal
    interestAmount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: LoanFinancialCountAggregateOutputType | null
    _avg: LoanFinancialAvgAggregateOutputType | null
    _sum: LoanFinancialSumAggregateOutputType | null
    _min: LoanFinancialMinAggregateOutputType | null
    _max: LoanFinancialMaxAggregateOutputType | null
  }

  type GetLoanFinancialGroupByPayload<T extends LoanFinancialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanFinancialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanFinancialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanFinancialGroupByOutputType[P]>
            : GetScalarType<T[P], LoanFinancialGroupByOutputType[P]>
        }
      >
    >


  export type LoanFinancialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    processingFee?: boolean
    legalFee?: boolean
    penaltyFee?: boolean
    interestAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanFinancial"]>

  export type LoanFinancialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    processingFee?: boolean
    legalFee?: boolean
    penaltyFee?: boolean
    interestAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanFinancial"]>

  export type LoanFinancialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    processingFee?: boolean
    legalFee?: boolean
    penaltyFee?: boolean
    interestAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanFinancial"]>

  export type LoanFinancialSelectScalar = {
    id?: boolean
    loanId?: boolean
    processingFee?: boolean
    legalFee?: boolean
    penaltyFee?: boolean
    interestAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanFinancialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "processingFee" | "legalFee" | "penaltyFee" | "interestAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["loanFinancial"]>
  export type LoanFinancialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanFinancialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type LoanFinancialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $LoanFinancialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanFinancial"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      processingFee: Prisma.Decimal
      legalFee: Prisma.Decimal
      penaltyFee: Prisma.Decimal
      interestAmount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loanFinancial"]>
    composites: {}
  }

  type LoanFinancialGetPayload<S extends boolean | null | undefined | LoanFinancialDefaultArgs> = $Result.GetResult<Prisma.$LoanFinancialPayload, S>

  type LoanFinancialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanFinancialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanFinancialCountAggregateInputType | true
    }

  export interface LoanFinancialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanFinancial'], meta: { name: 'LoanFinancial' } }
    /**
     * Find zero or one LoanFinancial that matches the filter.
     * @param {LoanFinancialFindUniqueArgs} args - Arguments to find a LoanFinancial
     * @example
     * // Get one LoanFinancial
     * const loanFinancial = await prisma.loanFinancial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanFinancialFindUniqueArgs>(args: SelectSubset<T, LoanFinancialFindUniqueArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoanFinancial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanFinancialFindUniqueOrThrowArgs} args - Arguments to find a LoanFinancial
     * @example
     * // Get one LoanFinancial
     * const loanFinancial = await prisma.loanFinancial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanFinancialFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanFinancialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanFinancial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFinancialFindFirstArgs} args - Arguments to find a LoanFinancial
     * @example
     * // Get one LoanFinancial
     * const loanFinancial = await prisma.loanFinancial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanFinancialFindFirstArgs>(args?: SelectSubset<T, LoanFinancialFindFirstArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanFinancial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFinancialFindFirstOrThrowArgs} args - Arguments to find a LoanFinancial
     * @example
     * // Get one LoanFinancial
     * const loanFinancial = await prisma.loanFinancial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanFinancialFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanFinancialFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoanFinancials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFinancialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanFinancials
     * const loanFinancials = await prisma.loanFinancial.findMany()
     * 
     * // Get first 10 LoanFinancials
     * const loanFinancials = await prisma.loanFinancial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanFinancialWithIdOnly = await prisma.loanFinancial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanFinancialFindManyArgs>(args?: SelectSubset<T, LoanFinancialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoanFinancial.
     * @param {LoanFinancialCreateArgs} args - Arguments to create a LoanFinancial.
     * @example
     * // Create one LoanFinancial
     * const LoanFinancial = await prisma.loanFinancial.create({
     *   data: {
     *     // ... data to create a LoanFinancial
     *   }
     * })
     * 
     */
    create<T extends LoanFinancialCreateArgs>(args: SelectSubset<T, LoanFinancialCreateArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoanFinancials.
     * @param {LoanFinancialCreateManyArgs} args - Arguments to create many LoanFinancials.
     * @example
     * // Create many LoanFinancials
     * const loanFinancial = await prisma.loanFinancial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanFinancialCreateManyArgs>(args?: SelectSubset<T, LoanFinancialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanFinancials and returns the data saved in the database.
     * @param {LoanFinancialCreateManyAndReturnArgs} args - Arguments to create many LoanFinancials.
     * @example
     * // Create many LoanFinancials
     * const loanFinancial = await prisma.loanFinancial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanFinancials and only return the `id`
     * const loanFinancialWithIdOnly = await prisma.loanFinancial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanFinancialCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanFinancialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoanFinancial.
     * @param {LoanFinancialDeleteArgs} args - Arguments to delete one LoanFinancial.
     * @example
     * // Delete one LoanFinancial
     * const LoanFinancial = await prisma.loanFinancial.delete({
     *   where: {
     *     // ... filter to delete one LoanFinancial
     *   }
     * })
     * 
     */
    delete<T extends LoanFinancialDeleteArgs>(args: SelectSubset<T, LoanFinancialDeleteArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoanFinancial.
     * @param {LoanFinancialUpdateArgs} args - Arguments to update one LoanFinancial.
     * @example
     * // Update one LoanFinancial
     * const loanFinancial = await prisma.loanFinancial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanFinancialUpdateArgs>(args: SelectSubset<T, LoanFinancialUpdateArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoanFinancials.
     * @param {LoanFinancialDeleteManyArgs} args - Arguments to filter LoanFinancials to delete.
     * @example
     * // Delete a few LoanFinancials
     * const { count } = await prisma.loanFinancial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanFinancialDeleteManyArgs>(args?: SelectSubset<T, LoanFinancialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanFinancials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFinancialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanFinancials
     * const loanFinancial = await prisma.loanFinancial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanFinancialUpdateManyArgs>(args: SelectSubset<T, LoanFinancialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanFinancials and returns the data updated in the database.
     * @param {LoanFinancialUpdateManyAndReturnArgs} args - Arguments to update many LoanFinancials.
     * @example
     * // Update many LoanFinancials
     * const loanFinancial = await prisma.loanFinancial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoanFinancials and only return the `id`
     * const loanFinancialWithIdOnly = await prisma.loanFinancial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanFinancialUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanFinancialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoanFinancial.
     * @param {LoanFinancialUpsertArgs} args - Arguments to update or create a LoanFinancial.
     * @example
     * // Update or create a LoanFinancial
     * const loanFinancial = await prisma.loanFinancial.upsert({
     *   create: {
     *     // ... data to create a LoanFinancial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanFinancial we want to update
     *   }
     * })
     */
    upsert<T extends LoanFinancialUpsertArgs>(args: SelectSubset<T, LoanFinancialUpsertArgs<ExtArgs>>): Prisma__LoanFinancialClient<$Result.GetResult<Prisma.$LoanFinancialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoanFinancials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFinancialCountArgs} args - Arguments to filter LoanFinancials to count.
     * @example
     * // Count the number of LoanFinancials
     * const count = await prisma.loanFinancial.count({
     *   where: {
     *     // ... the filter for the LoanFinancials we want to count
     *   }
     * })
    **/
    count<T extends LoanFinancialCountArgs>(
      args?: Subset<T, LoanFinancialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanFinancialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanFinancial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFinancialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanFinancialAggregateArgs>(args: Subset<T, LoanFinancialAggregateArgs>): Prisma.PrismaPromise<GetLoanFinancialAggregateType<T>>

    /**
     * Group by LoanFinancial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFinancialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanFinancialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanFinancialGroupByArgs['orderBy'] }
        : { orderBy?: LoanFinancialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanFinancialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanFinancialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanFinancial model
   */
  readonly fields: LoanFinancialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanFinancial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanFinancialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanFinancial model
   */
  interface LoanFinancialFieldRefs {
    readonly id: FieldRef<"LoanFinancial", 'String'>
    readonly loanId: FieldRef<"LoanFinancial", 'String'>
    readonly processingFee: FieldRef<"LoanFinancial", 'Decimal'>
    readonly legalFee: FieldRef<"LoanFinancial", 'Decimal'>
    readonly penaltyFee: FieldRef<"LoanFinancial", 'Decimal'>
    readonly interestAmount: FieldRef<"LoanFinancial", 'Decimal'>
    readonly createdAt: FieldRef<"LoanFinancial", 'DateTime'>
    readonly updatedAt: FieldRef<"LoanFinancial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanFinancial findUnique
   */
  export type LoanFinancialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * Filter, which LoanFinancial to fetch.
     */
    where: LoanFinancialWhereUniqueInput
  }

  /**
   * LoanFinancial findUniqueOrThrow
   */
  export type LoanFinancialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * Filter, which LoanFinancial to fetch.
     */
    where: LoanFinancialWhereUniqueInput
  }

  /**
   * LoanFinancial findFirst
   */
  export type LoanFinancialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * Filter, which LoanFinancial to fetch.
     */
    where?: LoanFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanFinancials to fetch.
     */
    orderBy?: LoanFinancialOrderByWithRelationInput | LoanFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanFinancials.
     */
    cursor?: LoanFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanFinancials.
     */
    distinct?: LoanFinancialScalarFieldEnum | LoanFinancialScalarFieldEnum[]
  }

  /**
   * LoanFinancial findFirstOrThrow
   */
  export type LoanFinancialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * Filter, which LoanFinancial to fetch.
     */
    where?: LoanFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanFinancials to fetch.
     */
    orderBy?: LoanFinancialOrderByWithRelationInput | LoanFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanFinancials.
     */
    cursor?: LoanFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanFinancials.
     */
    distinct?: LoanFinancialScalarFieldEnum | LoanFinancialScalarFieldEnum[]
  }

  /**
   * LoanFinancial findMany
   */
  export type LoanFinancialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * Filter, which LoanFinancials to fetch.
     */
    where?: LoanFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanFinancials to fetch.
     */
    orderBy?: LoanFinancialOrderByWithRelationInput | LoanFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanFinancials.
     */
    cursor?: LoanFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanFinancials.
     */
    skip?: number
    distinct?: LoanFinancialScalarFieldEnum | LoanFinancialScalarFieldEnum[]
  }

  /**
   * LoanFinancial create
   */
  export type LoanFinancialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanFinancial.
     */
    data: XOR<LoanFinancialCreateInput, LoanFinancialUncheckedCreateInput>
  }

  /**
   * LoanFinancial createMany
   */
  export type LoanFinancialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanFinancials.
     */
    data: LoanFinancialCreateManyInput | LoanFinancialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanFinancial createManyAndReturn
   */
  export type LoanFinancialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * The data used to create many LoanFinancials.
     */
    data: LoanFinancialCreateManyInput | LoanFinancialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanFinancial update
   */
  export type LoanFinancialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanFinancial.
     */
    data: XOR<LoanFinancialUpdateInput, LoanFinancialUncheckedUpdateInput>
    /**
     * Choose, which LoanFinancial to update.
     */
    where: LoanFinancialWhereUniqueInput
  }

  /**
   * LoanFinancial updateMany
   */
  export type LoanFinancialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanFinancials.
     */
    data: XOR<LoanFinancialUpdateManyMutationInput, LoanFinancialUncheckedUpdateManyInput>
    /**
     * Filter which LoanFinancials to update
     */
    where?: LoanFinancialWhereInput
    /**
     * Limit how many LoanFinancials to update.
     */
    limit?: number
  }

  /**
   * LoanFinancial updateManyAndReturn
   */
  export type LoanFinancialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * The data used to update LoanFinancials.
     */
    data: XOR<LoanFinancialUpdateManyMutationInput, LoanFinancialUncheckedUpdateManyInput>
    /**
     * Filter which LoanFinancials to update
     */
    where?: LoanFinancialWhereInput
    /**
     * Limit how many LoanFinancials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanFinancial upsert
   */
  export type LoanFinancialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanFinancial to update in case it exists.
     */
    where: LoanFinancialWhereUniqueInput
    /**
     * In case the LoanFinancial found by the `where` argument doesn't exist, create a new LoanFinancial with this data.
     */
    create: XOR<LoanFinancialCreateInput, LoanFinancialUncheckedCreateInput>
    /**
     * In case the LoanFinancial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanFinancialUpdateInput, LoanFinancialUncheckedUpdateInput>
  }

  /**
   * LoanFinancial delete
   */
  export type LoanFinancialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
    /**
     * Filter which LoanFinancial to delete.
     */
    where: LoanFinancialWhereUniqueInput
  }

  /**
   * LoanFinancial deleteMany
   */
  export type LoanFinancialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanFinancials to delete
     */
    where?: LoanFinancialWhereInput
    /**
     * Limit how many LoanFinancials to delete.
     */
    limit?: number
  }

  /**
   * LoanFinancial without action
   */
  export type LoanFinancialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanFinancial
     */
    select?: LoanFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanFinancial
     */
    omit?: LoanFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanFinancialInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    clientId: string | null
    loanId: string | null
    invoiceType: $Enums.InvoiceType | null
    invoiceDate: Date | null
    dueDate: Date | null
    totalAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    issuedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    clientId: string | null
    loanId: string | null
    invoiceType: $Enums.InvoiceType | null
    invoiceDate: Date | null
    dueDate: Date | null
    totalAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    issuedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    clientId: number
    loanId: number
    invoiceType: number
    invoiceDate: number
    dueDate: number
    totalAmount: number
    status: number
    issuedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    clientId?: true
    loanId?: true
    invoiceType?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    status?: true
    issuedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    clientId?: true
    loanId?: true
    invoiceType?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    status?: true
    issuedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    clientId?: true
    loanId?: true
    invoiceType?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    status?: true
    issuedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    clientId: string
    loanId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date
    dueDate: Date
    totalAmount: Decimal
    status: $Enums.InvoiceStatus
    issuedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    clientId?: boolean
    loanId?: boolean
    invoiceType?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    status?: boolean
    issuedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    clientId?: boolean
    loanId?: boolean
    invoiceType?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    status?: boolean
    issuedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    clientId?: boolean
    loanId?: boolean
    invoiceType?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    status?: boolean
    issuedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    clientId?: boolean
    loanId?: boolean
    invoiceType?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    status?: boolean
    issuedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "clientId" | "loanId" | "invoiceType" | "invoiceDate" | "dueDate" | "totalAmount" | "status" | "issuedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$InvoicePaymentPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs>
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      clientId: string
      loanId: string
      invoiceType: $Enums.InvoiceType
      invoiceDate: Date
      dueDate: Date
      totalAmount: Prisma.Decimal
      status: $Enums.InvoiceStatus
      issuedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly clientId: FieldRef<"Invoice", 'String'>
    readonly loanId: FieldRef<"Invoice", 'String'>
    readonly invoiceType: FieldRef<"Invoice", 'InvoiceType'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly issuedBy: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    cursor?: InvoicePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    chargeType: $Enums.ChargeType | null
    description: string | null
    amount: Decimal | null
    glAccount: string | null
    createdAt: Date | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    chargeType: $Enums.ChargeType | null
    description: string | null
    amount: Decimal | null
    glAccount: string | null
    createdAt: Date | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    chargeType: number
    description: number
    amount: number
    glAccount: number
    createdAt: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    chargeType?: true
    description?: true
    amount?: true
    glAccount?: true
    createdAt?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    chargeType?: true
    description?: true
    amount?: true
    glAccount?: true
    createdAt?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    chargeType?: true
    description?: true
    amount?: true
    glAccount?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    chargeType: $Enums.ChargeType
    description: string | null
    amount: Decimal
    glAccount: string | null
    createdAt: Date
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    chargeType?: boolean
    description?: boolean
    amount?: boolean
    glAccount?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    chargeType?: boolean
    description?: boolean
    amount?: boolean
    glAccount?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    chargeType?: boolean
    description?: boolean
    amount?: boolean
    glAccount?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    chargeType?: boolean
    description?: boolean
    amount?: boolean
    glAccount?: boolean
    createdAt?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "chargeType" | "description" | "amount" | "glAccount" | "createdAt", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      chargeType: $Enums.ChargeType
      description: string | null
      amount: Prisma.Decimal
      glAccount: string | null
      createdAt: Date
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly chargeType: FieldRef<"InvoiceItem", 'ChargeType'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly amount: FieldRef<"InvoiceItem", 'Decimal'>
    readonly glAccount: FieldRef<"InvoiceItem", 'String'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model InvoicePayment
   */

  export type AggregateInvoicePayment = {
    _count: InvoicePaymentCountAggregateOutputType | null
    _avg: InvoicePaymentAvgAggregateOutputType | null
    _sum: InvoicePaymentSumAggregateOutputType | null
    _min: InvoicePaymentMinAggregateOutputType | null
    _max: InvoicePaymentMaxAggregateOutputType | null
  }

  export type InvoicePaymentAvgAggregateOutputType = {
    amountPaid: Decimal | null
  }

  export type InvoicePaymentSumAggregateOutputType = {
    amountPaid: Decimal | null
  }

  export type InvoicePaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    transactionId: string | null
    amountPaid: Decimal | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
  }

  export type InvoicePaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    transactionId: string | null
    amountPaid: Decimal | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
  }

  export type InvoicePaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    transactionId: number
    amountPaid: number
    paymentDate: number
    paymentMethod: number
    createdAt: number
    _all: number
  }


  export type InvoicePaymentAvgAggregateInputType = {
    amountPaid?: true
  }

  export type InvoicePaymentSumAggregateInputType = {
    amountPaid?: true
  }

  export type InvoicePaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    transactionId?: true
    amountPaid?: true
    paymentDate?: true
    paymentMethod?: true
    createdAt?: true
  }

  export type InvoicePaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    transactionId?: true
    amountPaid?: true
    paymentDate?: true
    paymentMethod?: true
    createdAt?: true
  }

  export type InvoicePaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    transactionId?: true
    amountPaid?: true
    paymentDate?: true
    paymentMethod?: true
    createdAt?: true
    _all?: true
  }

  export type InvoicePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoicePayment to aggregate.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoicePayments
    **/
    _count?: true | InvoicePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicePaymentMaxAggregateInputType
  }

  export type GetInvoicePaymentAggregateType<T extends InvoicePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoicePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoicePayment[P]>
      : GetScalarType<T[P], AggregateInvoicePayment[P]>
  }




  export type InvoicePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithAggregationInput | InvoicePaymentOrderByWithAggregationInput[]
    by: InvoicePaymentScalarFieldEnum[] | InvoicePaymentScalarFieldEnum
    having?: InvoicePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicePaymentCountAggregateInputType | true
    _avg?: InvoicePaymentAvgAggregateInputType
    _sum?: InvoicePaymentSumAggregateInputType
    _min?: InvoicePaymentMinAggregateInputType
    _max?: InvoicePaymentMaxAggregateInputType
  }

  export type InvoicePaymentGroupByOutputType = {
    id: string
    invoiceId: string
    transactionId: string | null
    amountPaid: Decimal
    paymentDate: Date
    paymentMethod: $Enums.PaymentMethod
    createdAt: Date
    _count: InvoicePaymentCountAggregateOutputType | null
    _avg: InvoicePaymentAvgAggregateOutputType | null
    _sum: InvoicePaymentSumAggregateOutputType | null
    _min: InvoicePaymentMinAggregateOutputType | null
    _max: InvoicePaymentMaxAggregateOutputType | null
  }

  type GetInvoicePaymentGroupByPayload<T extends InvoicePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicePaymentGroupByOutputType[P]>
        }
      >
    >


  export type InvoicePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    transactionId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    transaction?: boolean | InvoicePayment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    transactionId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    transaction?: boolean | InvoicePayment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    transactionId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    transaction?: boolean | InvoicePayment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    transactionId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
  }

  export type InvoicePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "transactionId" | "amountPaid" | "paymentDate" | "paymentMethod" | "createdAt", ExtArgs["result"]["invoicePayment"]>
  export type InvoicePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    transaction?: boolean | InvoicePayment$transactionArgs<ExtArgs>
  }
  export type InvoicePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    transaction?: boolean | InvoicePayment$transactionArgs<ExtArgs>
  }
  export type InvoicePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    transaction?: boolean | InvoicePayment$transactionArgs<ExtArgs>
  }

  export type $InvoicePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoicePayment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      transactionId: string | null
      amountPaid: Prisma.Decimal
      paymentDate: Date
      paymentMethod: $Enums.PaymentMethod
      createdAt: Date
    }, ExtArgs["result"]["invoicePayment"]>
    composites: {}
  }

  type InvoicePaymentGetPayload<S extends boolean | null | undefined | InvoicePaymentDefaultArgs> = $Result.GetResult<Prisma.$InvoicePaymentPayload, S>

  type InvoicePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoicePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicePaymentCountAggregateInputType | true
    }

  export interface InvoicePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoicePayment'], meta: { name: 'InvoicePayment' } }
    /**
     * Find zero or one InvoicePayment that matches the filter.
     * @param {InvoicePaymentFindUniqueArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoicePaymentFindUniqueArgs>(args: SelectSubset<T, InvoicePaymentFindUniqueArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoicePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoicePaymentFindUniqueOrThrowArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoicePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoicePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoicePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindFirstArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoicePaymentFindFirstArgs>(args?: SelectSubset<T, InvoicePaymentFindFirstArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoicePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindFirstOrThrowArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoicePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoicePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoicePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoicePayments
     * const invoicePayments = await prisma.invoicePayment.findMany()
     * 
     * // Get first 10 InvoicePayments
     * const invoicePayments = await prisma.invoicePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoicePaymentFindManyArgs>(args?: SelectSubset<T, InvoicePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoicePayment.
     * @param {InvoicePaymentCreateArgs} args - Arguments to create a InvoicePayment.
     * @example
     * // Create one InvoicePayment
     * const InvoicePayment = await prisma.invoicePayment.create({
     *   data: {
     *     // ... data to create a InvoicePayment
     *   }
     * })
     * 
     */
    create<T extends InvoicePaymentCreateArgs>(args: SelectSubset<T, InvoicePaymentCreateArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoicePayments.
     * @param {InvoicePaymentCreateManyArgs} args - Arguments to create many InvoicePayments.
     * @example
     * // Create many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoicePaymentCreateManyArgs>(args?: SelectSubset<T, InvoicePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoicePayments and returns the data saved in the database.
     * @param {InvoicePaymentCreateManyAndReturnArgs} args - Arguments to create many InvoicePayments.
     * @example
     * // Create many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoicePayments and only return the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoicePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoicePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoicePayment.
     * @param {InvoicePaymentDeleteArgs} args - Arguments to delete one InvoicePayment.
     * @example
     * // Delete one InvoicePayment
     * const InvoicePayment = await prisma.invoicePayment.delete({
     *   where: {
     *     // ... filter to delete one InvoicePayment
     *   }
     * })
     * 
     */
    delete<T extends InvoicePaymentDeleteArgs>(args: SelectSubset<T, InvoicePaymentDeleteArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoicePayment.
     * @param {InvoicePaymentUpdateArgs} args - Arguments to update one InvoicePayment.
     * @example
     * // Update one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoicePaymentUpdateArgs>(args: SelectSubset<T, InvoicePaymentUpdateArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoicePayments.
     * @param {InvoicePaymentDeleteManyArgs} args - Arguments to filter InvoicePayments to delete.
     * @example
     * // Delete a few InvoicePayments
     * const { count } = await prisma.invoicePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoicePaymentDeleteManyArgs>(args?: SelectSubset<T, InvoicePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoicePaymentUpdateManyArgs>(args: SelectSubset<T, InvoicePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoicePayments and returns the data updated in the database.
     * @param {InvoicePaymentUpdateManyAndReturnArgs} args - Arguments to update many InvoicePayments.
     * @example
     * // Update many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoicePayments and only return the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoicePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoicePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoicePayment.
     * @param {InvoicePaymentUpsertArgs} args - Arguments to update or create a InvoicePayment.
     * @example
     * // Update or create a InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.upsert({
     *   create: {
     *     // ... data to create a InvoicePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoicePayment we want to update
     *   }
     * })
     */
    upsert<T extends InvoicePaymentUpsertArgs>(args: SelectSubset<T, InvoicePaymentUpsertArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentCountArgs} args - Arguments to filter InvoicePayments to count.
     * @example
     * // Count the number of InvoicePayments
     * const count = await prisma.invoicePayment.count({
     *   where: {
     *     // ... the filter for the InvoicePayments we want to count
     *   }
     * })
    **/
    count<T extends InvoicePaymentCountArgs>(
      args?: Subset<T, InvoicePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicePaymentAggregateArgs>(args: Subset<T, InvoicePaymentAggregateArgs>): Prisma.PrismaPromise<GetInvoicePaymentAggregateType<T>>

    /**
     * Group by InvoicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoicePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicePaymentGroupByArgs['orderBy'] }
        : { orderBy?: InvoicePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoicePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoicePayment model
   */
  readonly fields: InvoicePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoicePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoicePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends InvoicePayment$transactionArgs<ExtArgs> = {}>(args?: Subset<T, InvoicePayment$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoicePayment model
   */
  interface InvoicePaymentFieldRefs {
    readonly id: FieldRef<"InvoicePayment", 'String'>
    readonly invoiceId: FieldRef<"InvoicePayment", 'String'>
    readonly transactionId: FieldRef<"InvoicePayment", 'String'>
    readonly amountPaid: FieldRef<"InvoicePayment", 'Decimal'>
    readonly paymentDate: FieldRef<"InvoicePayment", 'DateTime'>
    readonly paymentMethod: FieldRef<"InvoicePayment", 'PaymentMethod'>
    readonly createdAt: FieldRef<"InvoicePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoicePayment findUnique
   */
  export type InvoicePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment findUniqueOrThrow
   */
  export type InvoicePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment findFirst
   */
  export type InvoicePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoicePayments.
     */
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment findFirstOrThrow
   */
  export type InvoicePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoicePayments.
     */
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment findMany
   */
  export type InvoicePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayments to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment create
   */
  export type InvoicePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoicePayment.
     */
    data: XOR<InvoicePaymentCreateInput, InvoicePaymentUncheckedCreateInput>
  }

  /**
   * InvoicePayment createMany
   */
  export type InvoicePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoicePayments.
     */
    data: InvoicePaymentCreateManyInput | InvoicePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoicePayment createManyAndReturn
   */
  export type InvoicePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many InvoicePayments.
     */
    data: InvoicePaymentCreateManyInput | InvoicePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoicePayment update
   */
  export type InvoicePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoicePayment.
     */
    data: XOR<InvoicePaymentUpdateInput, InvoicePaymentUncheckedUpdateInput>
    /**
     * Choose, which InvoicePayment to update.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment updateMany
   */
  export type InvoicePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoicePayments.
     */
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyInput>
    /**
     * Filter which InvoicePayments to update
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to update.
     */
    limit?: number
  }

  /**
   * InvoicePayment updateManyAndReturn
   */
  export type InvoicePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * The data used to update InvoicePayments.
     */
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyInput>
    /**
     * Filter which InvoicePayments to update
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoicePayment upsert
   */
  export type InvoicePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoicePayment to update in case it exists.
     */
    where: InvoicePaymentWhereUniqueInput
    /**
     * In case the InvoicePayment found by the `where` argument doesn't exist, create a new InvoicePayment with this data.
     */
    create: XOR<InvoicePaymentCreateInput, InvoicePaymentUncheckedCreateInput>
    /**
     * In case the InvoicePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoicePaymentUpdateInput, InvoicePaymentUncheckedUpdateInput>
  }

  /**
   * InvoicePayment delete
   */
  export type InvoicePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter which InvoicePayment to delete.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment deleteMany
   */
  export type InvoicePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoicePayments to delete
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to delete.
     */
    limit?: number
  }

  /**
   * InvoicePayment.transaction
   */
  export type InvoicePayment$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * InvoicePayment without action
   */
  export type InvoicePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    transactionCode: string | null
    transactionType: $Enums.TransactionType | null
    referenceType: $Enums.ReferenceType | null
    referenceId: string | null
    amount: Decimal | null
    debitAccount: string | null
    creditAccount: string | null
    paymentMethod: $Enums.PaymentMethod | null
    transactionDate: Date | null
    description: string | null
    status: $Enums.TransactionStatus | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    transactionCode: string | null
    transactionType: $Enums.TransactionType | null
    referenceType: $Enums.ReferenceType | null
    referenceId: string | null
    amount: Decimal | null
    debitAccount: string | null
    creditAccount: string | null
    paymentMethod: $Enums.PaymentMethod | null
    transactionDate: Date | null
    description: string | null
    status: $Enums.TransactionStatus | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    transactionCode: number
    transactionType: number
    referenceType: number
    referenceId: number
    amount: number
    debitAccount: number
    creditAccount: number
    paymentMethod: number
    transactionDate: number
    description: number
    status: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    transactionCode?: true
    transactionType?: true
    referenceType?: true
    referenceId?: true
    amount?: true
    debitAccount?: true
    creditAccount?: true
    paymentMethod?: true
    transactionDate?: true
    description?: true
    status?: true
    createdBy?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    transactionCode?: true
    transactionType?: true
    referenceType?: true
    referenceId?: true
    amount?: true
    debitAccount?: true
    creditAccount?: true
    paymentMethod?: true
    transactionDate?: true
    description?: true
    status?: true
    createdBy?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    transactionCode?: true
    transactionType?: true
    referenceType?: true
    referenceId?: true
    amount?: true
    debitAccount?: true
    creditAccount?: true
    paymentMethod?: true
    transactionDate?: true
    description?: true
    status?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    transactionCode: string
    transactionType: $Enums.TransactionType
    referenceType: $Enums.ReferenceType
    referenceId: string
    amount: Decimal
    debitAccount: string
    creditAccount: string
    paymentMethod: $Enums.PaymentMethod | null
    transactionDate: Date
    description: string | null
    status: $Enums.TransactionStatus
    createdBy: string | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionCode?: boolean
    transactionType?: boolean
    referenceType?: boolean
    referenceId?: boolean
    amount?: boolean
    debitAccount?: boolean
    creditAccount?: boolean
    paymentMethod?: boolean
    transactionDate?: boolean
    description?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    invoicePayments?: boolean | Transaction$invoicePaymentsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionCode?: boolean
    transactionType?: boolean
    referenceType?: boolean
    referenceId?: boolean
    amount?: boolean
    debitAccount?: boolean
    creditAccount?: boolean
    paymentMethod?: boolean
    transactionDate?: boolean
    description?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionCode?: boolean
    transactionType?: boolean
    referenceType?: boolean
    referenceId?: boolean
    amount?: boolean
    debitAccount?: boolean
    creditAccount?: boolean
    paymentMethod?: boolean
    transactionDate?: boolean
    description?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    transactionCode?: boolean
    transactionType?: boolean
    referenceType?: boolean
    referenceId?: boolean
    amount?: boolean
    debitAccount?: boolean
    creditAccount?: boolean
    paymentMethod?: boolean
    transactionDate?: boolean
    description?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionCode" | "transactionType" | "referenceType" | "referenceId" | "amount" | "debitAccount" | "creditAccount" | "paymentMethod" | "transactionDate" | "description" | "status" | "createdBy" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoicePayments?: boolean | Transaction$invoicePaymentsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      invoicePayments: Prisma.$InvoicePaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionCode: string
      transactionType: $Enums.TransactionType
      referenceType: $Enums.ReferenceType
      referenceId: string
      amount: Prisma.Decimal
      debitAccount: string
      creditAccount: string
      paymentMethod: $Enums.PaymentMethod | null
      transactionDate: Date
      description: string | null
      status: $Enums.TransactionStatus
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoicePayments<T extends Transaction$invoicePaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$invoicePaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly transactionCode: FieldRef<"Transaction", 'String'>
    readonly transactionType: FieldRef<"Transaction", 'TransactionType'>
    readonly referenceType: FieldRef<"Transaction", 'ReferenceType'>
    readonly referenceId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly debitAccount: FieldRef<"Transaction", 'String'>
    readonly creditAccount: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly transactionDate: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly createdBy: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.invoicePayments
   */
  export type Transaction$invoicePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    cursor?: InvoicePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Repayment
   */

  export type AggregateRepayment = {
    _count: RepaymentCountAggregateOutputType | null
    _avg: RepaymentAvgAggregateOutputType | null
    _sum: RepaymentSumAggregateOutputType | null
    _min: RepaymentMinAggregateOutputType | null
    _max: RepaymentMaxAggregateOutputType | null
  }

  export type RepaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type RepaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type RepaymentMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    category: $Enums.RepaymentCategory | null
    reference: string | null
    createdAt: Date | null
  }

  export type RepaymentMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    category: $Enums.RepaymentCategory | null
    reference: string | null
    createdAt: Date | null
  }

  export type RepaymentCountAggregateOutputType = {
    id: number
    loanId: number
    amount: number
    paymentMethod: number
    paymentDate: number
    category: number
    reference: number
    createdAt: number
    _all: number
  }


  export type RepaymentAvgAggregateInputType = {
    amount?: true
  }

  export type RepaymentSumAggregateInputType = {
    amount?: true
  }

  export type RepaymentMinAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    category?: true
    reference?: true
    createdAt?: true
  }

  export type RepaymentMaxAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    category?: true
    reference?: true
    createdAt?: true
  }

  export type RepaymentCountAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    category?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type RepaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repayment to aggregate.
     */
    where?: RepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repayments to fetch.
     */
    orderBy?: RepaymentOrderByWithRelationInput | RepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Repayments
    **/
    _count?: true | RepaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepaymentMaxAggregateInputType
  }

  export type GetRepaymentAggregateType<T extends RepaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateRepayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepayment[P]>
      : GetScalarType<T[P], AggregateRepayment[P]>
  }




  export type RepaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepaymentWhereInput
    orderBy?: RepaymentOrderByWithAggregationInput | RepaymentOrderByWithAggregationInput[]
    by: RepaymentScalarFieldEnum[] | RepaymentScalarFieldEnum
    having?: RepaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepaymentCountAggregateInputType | true
    _avg?: RepaymentAvgAggregateInputType
    _sum?: RepaymentSumAggregateInputType
    _min?: RepaymentMinAggregateInputType
    _max?: RepaymentMaxAggregateInputType
  }

  export type RepaymentGroupByOutputType = {
    id: string
    loanId: string
    amount: Decimal
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date
    category: $Enums.RepaymentCategory
    reference: string | null
    createdAt: Date
    _count: RepaymentCountAggregateOutputType | null
    _avg: RepaymentAvgAggregateOutputType | null
    _sum: RepaymentSumAggregateOutputType | null
    _min: RepaymentMinAggregateOutputType | null
    _max: RepaymentMaxAggregateOutputType | null
  }

  type GetRepaymentGroupByPayload<T extends RepaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepaymentGroupByOutputType[P]>
            : GetScalarType<T[P], RepaymentGroupByOutputType[P]>
        }
      >
    >


  export type RepaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    category?: boolean
    reference?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repayment"]>

  export type RepaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    category?: boolean
    reference?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repayment"]>

  export type RepaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    category?: boolean
    reference?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repayment"]>

  export type RepaymentSelectScalar = {
    id?: boolean
    loanId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    category?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type RepaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "amount" | "paymentMethod" | "paymentDate" | "category" | "reference" | "createdAt", ExtArgs["result"]["repayment"]>
  export type RepaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type RepaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type RepaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $RepaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Repayment"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      amount: Prisma.Decimal
      paymentMethod: $Enums.PaymentMethod
      paymentDate: Date
      category: $Enums.RepaymentCategory
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["repayment"]>
    composites: {}
  }

  type RepaymentGetPayload<S extends boolean | null | undefined | RepaymentDefaultArgs> = $Result.GetResult<Prisma.$RepaymentPayload, S>

  type RepaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RepaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RepaymentCountAggregateInputType | true
    }

  export interface RepaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Repayment'], meta: { name: 'Repayment' } }
    /**
     * Find zero or one Repayment that matches the filter.
     * @param {RepaymentFindUniqueArgs} args - Arguments to find a Repayment
     * @example
     * // Get one Repayment
     * const repayment = await prisma.repayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepaymentFindUniqueArgs>(args: SelectSubset<T, RepaymentFindUniqueArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Repayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RepaymentFindUniqueOrThrowArgs} args - Arguments to find a Repayment
     * @example
     * // Get one Repayment
     * const repayment = await prisma.repayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, RepaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepaymentFindFirstArgs} args - Arguments to find a Repayment
     * @example
     * // Get one Repayment
     * const repayment = await prisma.repayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepaymentFindFirstArgs>(args?: SelectSubset<T, RepaymentFindFirstArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepaymentFindFirstOrThrowArgs} args - Arguments to find a Repayment
     * @example
     * // Get one Repayment
     * const repayment = await prisma.repayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, RepaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Repayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repayments
     * const repayments = await prisma.repayment.findMany()
     * 
     * // Get first 10 Repayments
     * const repayments = await prisma.repayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repaymentWithIdOnly = await prisma.repayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepaymentFindManyArgs>(args?: SelectSubset<T, RepaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Repayment.
     * @param {RepaymentCreateArgs} args - Arguments to create a Repayment.
     * @example
     * // Create one Repayment
     * const Repayment = await prisma.repayment.create({
     *   data: {
     *     // ... data to create a Repayment
     *   }
     * })
     * 
     */
    create<T extends RepaymentCreateArgs>(args: SelectSubset<T, RepaymentCreateArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Repayments.
     * @param {RepaymentCreateManyArgs} args - Arguments to create many Repayments.
     * @example
     * // Create many Repayments
     * const repayment = await prisma.repayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepaymentCreateManyArgs>(args?: SelectSubset<T, RepaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Repayments and returns the data saved in the database.
     * @param {RepaymentCreateManyAndReturnArgs} args - Arguments to create many Repayments.
     * @example
     * // Create many Repayments
     * const repayment = await prisma.repayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Repayments and only return the `id`
     * const repaymentWithIdOnly = await prisma.repayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, RepaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Repayment.
     * @param {RepaymentDeleteArgs} args - Arguments to delete one Repayment.
     * @example
     * // Delete one Repayment
     * const Repayment = await prisma.repayment.delete({
     *   where: {
     *     // ... filter to delete one Repayment
     *   }
     * })
     * 
     */
    delete<T extends RepaymentDeleteArgs>(args: SelectSubset<T, RepaymentDeleteArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Repayment.
     * @param {RepaymentUpdateArgs} args - Arguments to update one Repayment.
     * @example
     * // Update one Repayment
     * const repayment = await prisma.repayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepaymentUpdateArgs>(args: SelectSubset<T, RepaymentUpdateArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Repayments.
     * @param {RepaymentDeleteManyArgs} args - Arguments to filter Repayments to delete.
     * @example
     * // Delete a few Repayments
     * const { count } = await prisma.repayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepaymentDeleteManyArgs>(args?: SelectSubset<T, RepaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repayments
     * const repayment = await prisma.repayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepaymentUpdateManyArgs>(args: SelectSubset<T, RepaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repayments and returns the data updated in the database.
     * @param {RepaymentUpdateManyAndReturnArgs} args - Arguments to update many Repayments.
     * @example
     * // Update many Repayments
     * const repayment = await prisma.repayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Repayments and only return the `id`
     * const repaymentWithIdOnly = await prisma.repayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RepaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, RepaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Repayment.
     * @param {RepaymentUpsertArgs} args - Arguments to update or create a Repayment.
     * @example
     * // Update or create a Repayment
     * const repayment = await prisma.repayment.upsert({
     *   create: {
     *     // ... data to create a Repayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repayment we want to update
     *   }
     * })
     */
    upsert<T extends RepaymentUpsertArgs>(args: SelectSubset<T, RepaymentUpsertArgs<ExtArgs>>): Prisma__RepaymentClient<$Result.GetResult<Prisma.$RepaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Repayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepaymentCountArgs} args - Arguments to filter Repayments to count.
     * @example
     * // Count the number of Repayments
     * const count = await prisma.repayment.count({
     *   where: {
     *     // ... the filter for the Repayments we want to count
     *   }
     * })
    **/
    count<T extends RepaymentCountArgs>(
      args?: Subset<T, RepaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepaymentAggregateArgs>(args: Subset<T, RepaymentAggregateArgs>): Prisma.PrismaPromise<GetRepaymentAggregateType<T>>

    /**
     * Group by Repayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepaymentGroupByArgs['orderBy'] }
        : { orderBy?: RepaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Repayment model
   */
  readonly fields: RepaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Repayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Repayment model
   */
  interface RepaymentFieldRefs {
    readonly id: FieldRef<"Repayment", 'String'>
    readonly loanId: FieldRef<"Repayment", 'String'>
    readonly amount: FieldRef<"Repayment", 'Decimal'>
    readonly paymentMethod: FieldRef<"Repayment", 'PaymentMethod'>
    readonly paymentDate: FieldRef<"Repayment", 'DateTime'>
    readonly category: FieldRef<"Repayment", 'RepaymentCategory'>
    readonly reference: FieldRef<"Repayment", 'String'>
    readonly createdAt: FieldRef<"Repayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Repayment findUnique
   */
  export type RepaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * Filter, which Repayment to fetch.
     */
    where: RepaymentWhereUniqueInput
  }

  /**
   * Repayment findUniqueOrThrow
   */
  export type RepaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * Filter, which Repayment to fetch.
     */
    where: RepaymentWhereUniqueInput
  }

  /**
   * Repayment findFirst
   */
  export type RepaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * Filter, which Repayment to fetch.
     */
    where?: RepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repayments to fetch.
     */
    orderBy?: RepaymentOrderByWithRelationInput | RepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repayments.
     */
    cursor?: RepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repayments.
     */
    distinct?: RepaymentScalarFieldEnum | RepaymentScalarFieldEnum[]
  }

  /**
   * Repayment findFirstOrThrow
   */
  export type RepaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * Filter, which Repayment to fetch.
     */
    where?: RepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repayments to fetch.
     */
    orderBy?: RepaymentOrderByWithRelationInput | RepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repayments.
     */
    cursor?: RepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repayments.
     */
    distinct?: RepaymentScalarFieldEnum | RepaymentScalarFieldEnum[]
  }

  /**
   * Repayment findMany
   */
  export type RepaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * Filter, which Repayments to fetch.
     */
    where?: RepaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repayments to fetch.
     */
    orderBy?: RepaymentOrderByWithRelationInput | RepaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Repayments.
     */
    cursor?: RepaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repayments.
     */
    skip?: number
    distinct?: RepaymentScalarFieldEnum | RepaymentScalarFieldEnum[]
  }

  /**
   * Repayment create
   */
  export type RepaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Repayment.
     */
    data: XOR<RepaymentCreateInput, RepaymentUncheckedCreateInput>
  }

  /**
   * Repayment createMany
   */
  export type RepaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Repayments.
     */
    data: RepaymentCreateManyInput | RepaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Repayment createManyAndReturn
   */
  export type RepaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Repayments.
     */
    data: RepaymentCreateManyInput | RepaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Repayment update
   */
  export type RepaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Repayment.
     */
    data: XOR<RepaymentUpdateInput, RepaymentUncheckedUpdateInput>
    /**
     * Choose, which Repayment to update.
     */
    where: RepaymentWhereUniqueInput
  }

  /**
   * Repayment updateMany
   */
  export type RepaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Repayments.
     */
    data: XOR<RepaymentUpdateManyMutationInput, RepaymentUncheckedUpdateManyInput>
    /**
     * Filter which Repayments to update
     */
    where?: RepaymentWhereInput
    /**
     * Limit how many Repayments to update.
     */
    limit?: number
  }

  /**
   * Repayment updateManyAndReturn
   */
  export type RepaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * The data used to update Repayments.
     */
    data: XOR<RepaymentUpdateManyMutationInput, RepaymentUncheckedUpdateManyInput>
    /**
     * Filter which Repayments to update
     */
    where?: RepaymentWhereInput
    /**
     * Limit how many Repayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Repayment upsert
   */
  export type RepaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Repayment to update in case it exists.
     */
    where: RepaymentWhereUniqueInput
    /**
     * In case the Repayment found by the `where` argument doesn't exist, create a new Repayment with this data.
     */
    create: XOR<RepaymentCreateInput, RepaymentUncheckedCreateInput>
    /**
     * In case the Repayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepaymentUpdateInput, RepaymentUncheckedUpdateInput>
  }

  /**
   * Repayment delete
   */
  export type RepaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
    /**
     * Filter which Repayment to delete.
     */
    where: RepaymentWhereUniqueInput
  }

  /**
   * Repayment deleteMany
   */
  export type RepaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repayments to delete
     */
    where?: RepaymentWhereInput
    /**
     * Limit how many Repayments to delete.
     */
    limit?: number
  }

  /**
   * Repayment without action
   */
  export type RepaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repayment
     */
    select?: RepaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repayment
     */
    omit?: RepaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepaymentInclude<ExtArgs> | null
  }


  /**
   * Model NonPerformingLoan
   */

  export type AggregateNonPerformingLoan = {
    _count: NonPerformingLoanCountAggregateOutputType | null
    _avg: NonPerformingLoanAvgAggregateOutputType | null
    _sum: NonPerformingLoanSumAggregateOutputType | null
    _min: NonPerformingLoanMinAggregateOutputType | null
    _max: NonPerformingLoanMaxAggregateOutputType | null
  }

  export type NonPerformingLoanAvgAggregateOutputType = {
    capitalizedAmount: Decimal | null
  }

  export type NonPerformingLoanSumAggregateOutputType = {
    capitalizedAmount: Decimal | null
  }

  export type NonPerformingLoanMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    capitalizedAmount: Decimal | null
    flaggedAt: Date | null
    createdAt: Date | null
  }

  export type NonPerformingLoanMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    capitalizedAmount: Decimal | null
    flaggedAt: Date | null
    createdAt: Date | null
  }

  export type NonPerformingLoanCountAggregateOutputType = {
    id: number
    loanId: number
    capitalizedAmount: number
    flaggedAt: number
    createdAt: number
    _all: number
  }


  export type NonPerformingLoanAvgAggregateInputType = {
    capitalizedAmount?: true
  }

  export type NonPerformingLoanSumAggregateInputType = {
    capitalizedAmount?: true
  }

  export type NonPerformingLoanMinAggregateInputType = {
    id?: true
    loanId?: true
    capitalizedAmount?: true
    flaggedAt?: true
    createdAt?: true
  }

  export type NonPerformingLoanMaxAggregateInputType = {
    id?: true
    loanId?: true
    capitalizedAmount?: true
    flaggedAt?: true
    createdAt?: true
  }

  export type NonPerformingLoanCountAggregateInputType = {
    id?: true
    loanId?: true
    capitalizedAmount?: true
    flaggedAt?: true
    createdAt?: true
    _all?: true
  }

  export type NonPerformingLoanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonPerformingLoan to aggregate.
     */
    where?: NonPerformingLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonPerformingLoans to fetch.
     */
    orderBy?: NonPerformingLoanOrderByWithRelationInput | NonPerformingLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NonPerformingLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonPerformingLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonPerformingLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NonPerformingLoans
    **/
    _count?: true | NonPerformingLoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NonPerformingLoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NonPerformingLoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NonPerformingLoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NonPerformingLoanMaxAggregateInputType
  }

  export type GetNonPerformingLoanAggregateType<T extends NonPerformingLoanAggregateArgs> = {
        [P in keyof T & keyof AggregateNonPerformingLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNonPerformingLoan[P]>
      : GetScalarType<T[P], AggregateNonPerformingLoan[P]>
  }




  export type NonPerformingLoanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonPerformingLoanWhereInput
    orderBy?: NonPerformingLoanOrderByWithAggregationInput | NonPerformingLoanOrderByWithAggregationInput[]
    by: NonPerformingLoanScalarFieldEnum[] | NonPerformingLoanScalarFieldEnum
    having?: NonPerformingLoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NonPerformingLoanCountAggregateInputType | true
    _avg?: NonPerformingLoanAvgAggregateInputType
    _sum?: NonPerformingLoanSumAggregateInputType
    _min?: NonPerformingLoanMinAggregateInputType
    _max?: NonPerformingLoanMaxAggregateInputType
  }

  export type NonPerformingLoanGroupByOutputType = {
    id: string
    loanId: string
    capitalizedAmount: Decimal
    flaggedAt: Date
    createdAt: Date
    _count: NonPerformingLoanCountAggregateOutputType | null
    _avg: NonPerformingLoanAvgAggregateOutputType | null
    _sum: NonPerformingLoanSumAggregateOutputType | null
    _min: NonPerformingLoanMinAggregateOutputType | null
    _max: NonPerformingLoanMaxAggregateOutputType | null
  }

  type GetNonPerformingLoanGroupByPayload<T extends NonPerformingLoanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NonPerformingLoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NonPerformingLoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NonPerformingLoanGroupByOutputType[P]>
            : GetScalarType<T[P], NonPerformingLoanGroupByOutputType[P]>
        }
      >
    >


  export type NonPerformingLoanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    capitalizedAmount?: boolean
    flaggedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nonPerformingLoan"]>

  export type NonPerformingLoanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    capitalizedAmount?: boolean
    flaggedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nonPerformingLoan"]>

  export type NonPerformingLoanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    capitalizedAmount?: boolean
    flaggedAt?: boolean
    createdAt?: boolean
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nonPerformingLoan"]>

  export type NonPerformingLoanSelectScalar = {
    id?: boolean
    loanId?: boolean
    capitalizedAmount?: boolean
    flaggedAt?: boolean
    createdAt?: boolean
  }

  export type NonPerformingLoanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "capitalizedAmount" | "flaggedAt" | "createdAt", ExtArgs["result"]["nonPerformingLoan"]>
  export type NonPerformingLoanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type NonPerformingLoanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type NonPerformingLoanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $NonPerformingLoanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NonPerformingLoan"
    objects: {
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      capitalizedAmount: Prisma.Decimal
      flaggedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["nonPerformingLoan"]>
    composites: {}
  }

  type NonPerformingLoanGetPayload<S extends boolean | null | undefined | NonPerformingLoanDefaultArgs> = $Result.GetResult<Prisma.$NonPerformingLoanPayload, S>

  type NonPerformingLoanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NonPerformingLoanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NonPerformingLoanCountAggregateInputType | true
    }

  export interface NonPerformingLoanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NonPerformingLoan'], meta: { name: 'NonPerformingLoan' } }
    /**
     * Find zero or one NonPerformingLoan that matches the filter.
     * @param {NonPerformingLoanFindUniqueArgs} args - Arguments to find a NonPerformingLoan
     * @example
     * // Get one NonPerformingLoan
     * const nonPerformingLoan = await prisma.nonPerformingLoan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NonPerformingLoanFindUniqueArgs>(args: SelectSubset<T, NonPerformingLoanFindUniqueArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NonPerformingLoan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NonPerformingLoanFindUniqueOrThrowArgs} args - Arguments to find a NonPerformingLoan
     * @example
     * // Get one NonPerformingLoan
     * const nonPerformingLoan = await prisma.nonPerformingLoan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NonPerformingLoanFindUniqueOrThrowArgs>(args: SelectSubset<T, NonPerformingLoanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NonPerformingLoan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonPerformingLoanFindFirstArgs} args - Arguments to find a NonPerformingLoan
     * @example
     * // Get one NonPerformingLoan
     * const nonPerformingLoan = await prisma.nonPerformingLoan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NonPerformingLoanFindFirstArgs>(args?: SelectSubset<T, NonPerformingLoanFindFirstArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NonPerformingLoan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonPerformingLoanFindFirstOrThrowArgs} args - Arguments to find a NonPerformingLoan
     * @example
     * // Get one NonPerformingLoan
     * const nonPerformingLoan = await prisma.nonPerformingLoan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NonPerformingLoanFindFirstOrThrowArgs>(args?: SelectSubset<T, NonPerformingLoanFindFirstOrThrowArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NonPerformingLoans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonPerformingLoanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NonPerformingLoans
     * const nonPerformingLoans = await prisma.nonPerformingLoan.findMany()
     * 
     * // Get first 10 NonPerformingLoans
     * const nonPerformingLoans = await prisma.nonPerformingLoan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nonPerformingLoanWithIdOnly = await prisma.nonPerformingLoan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NonPerformingLoanFindManyArgs>(args?: SelectSubset<T, NonPerformingLoanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NonPerformingLoan.
     * @param {NonPerformingLoanCreateArgs} args - Arguments to create a NonPerformingLoan.
     * @example
     * // Create one NonPerformingLoan
     * const NonPerformingLoan = await prisma.nonPerformingLoan.create({
     *   data: {
     *     // ... data to create a NonPerformingLoan
     *   }
     * })
     * 
     */
    create<T extends NonPerformingLoanCreateArgs>(args: SelectSubset<T, NonPerformingLoanCreateArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NonPerformingLoans.
     * @param {NonPerformingLoanCreateManyArgs} args - Arguments to create many NonPerformingLoans.
     * @example
     * // Create many NonPerformingLoans
     * const nonPerformingLoan = await prisma.nonPerformingLoan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NonPerformingLoanCreateManyArgs>(args?: SelectSubset<T, NonPerformingLoanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NonPerformingLoans and returns the data saved in the database.
     * @param {NonPerformingLoanCreateManyAndReturnArgs} args - Arguments to create many NonPerformingLoans.
     * @example
     * // Create many NonPerformingLoans
     * const nonPerformingLoan = await prisma.nonPerformingLoan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NonPerformingLoans and only return the `id`
     * const nonPerformingLoanWithIdOnly = await prisma.nonPerformingLoan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NonPerformingLoanCreateManyAndReturnArgs>(args?: SelectSubset<T, NonPerformingLoanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NonPerformingLoan.
     * @param {NonPerformingLoanDeleteArgs} args - Arguments to delete one NonPerformingLoan.
     * @example
     * // Delete one NonPerformingLoan
     * const NonPerformingLoan = await prisma.nonPerformingLoan.delete({
     *   where: {
     *     // ... filter to delete one NonPerformingLoan
     *   }
     * })
     * 
     */
    delete<T extends NonPerformingLoanDeleteArgs>(args: SelectSubset<T, NonPerformingLoanDeleteArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NonPerformingLoan.
     * @param {NonPerformingLoanUpdateArgs} args - Arguments to update one NonPerformingLoan.
     * @example
     * // Update one NonPerformingLoan
     * const nonPerformingLoan = await prisma.nonPerformingLoan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NonPerformingLoanUpdateArgs>(args: SelectSubset<T, NonPerformingLoanUpdateArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NonPerformingLoans.
     * @param {NonPerformingLoanDeleteManyArgs} args - Arguments to filter NonPerformingLoans to delete.
     * @example
     * // Delete a few NonPerformingLoans
     * const { count } = await prisma.nonPerformingLoan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NonPerformingLoanDeleteManyArgs>(args?: SelectSubset<T, NonPerformingLoanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NonPerformingLoans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonPerformingLoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NonPerformingLoans
     * const nonPerformingLoan = await prisma.nonPerformingLoan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NonPerformingLoanUpdateManyArgs>(args: SelectSubset<T, NonPerformingLoanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NonPerformingLoans and returns the data updated in the database.
     * @param {NonPerformingLoanUpdateManyAndReturnArgs} args - Arguments to update many NonPerformingLoans.
     * @example
     * // Update many NonPerformingLoans
     * const nonPerformingLoan = await prisma.nonPerformingLoan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NonPerformingLoans and only return the `id`
     * const nonPerformingLoanWithIdOnly = await prisma.nonPerformingLoan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NonPerformingLoanUpdateManyAndReturnArgs>(args: SelectSubset<T, NonPerformingLoanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NonPerformingLoan.
     * @param {NonPerformingLoanUpsertArgs} args - Arguments to update or create a NonPerformingLoan.
     * @example
     * // Update or create a NonPerformingLoan
     * const nonPerformingLoan = await prisma.nonPerformingLoan.upsert({
     *   create: {
     *     // ... data to create a NonPerformingLoan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NonPerformingLoan we want to update
     *   }
     * })
     */
    upsert<T extends NonPerformingLoanUpsertArgs>(args: SelectSubset<T, NonPerformingLoanUpsertArgs<ExtArgs>>): Prisma__NonPerformingLoanClient<$Result.GetResult<Prisma.$NonPerformingLoanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NonPerformingLoans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonPerformingLoanCountArgs} args - Arguments to filter NonPerformingLoans to count.
     * @example
     * // Count the number of NonPerformingLoans
     * const count = await prisma.nonPerformingLoan.count({
     *   where: {
     *     // ... the filter for the NonPerformingLoans we want to count
     *   }
     * })
    **/
    count<T extends NonPerformingLoanCountArgs>(
      args?: Subset<T, NonPerformingLoanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NonPerformingLoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NonPerformingLoan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonPerformingLoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NonPerformingLoanAggregateArgs>(args: Subset<T, NonPerformingLoanAggregateArgs>): Prisma.PrismaPromise<GetNonPerformingLoanAggregateType<T>>

    /**
     * Group by NonPerformingLoan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonPerformingLoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NonPerformingLoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NonPerformingLoanGroupByArgs['orderBy'] }
        : { orderBy?: NonPerformingLoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NonPerformingLoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNonPerformingLoanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NonPerformingLoan model
   */
  readonly fields: NonPerformingLoanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NonPerformingLoan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NonPerformingLoanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NonPerformingLoan model
   */
  interface NonPerformingLoanFieldRefs {
    readonly id: FieldRef<"NonPerformingLoan", 'String'>
    readonly loanId: FieldRef<"NonPerformingLoan", 'String'>
    readonly capitalizedAmount: FieldRef<"NonPerformingLoan", 'Decimal'>
    readonly flaggedAt: FieldRef<"NonPerformingLoan", 'DateTime'>
    readonly createdAt: FieldRef<"NonPerformingLoan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NonPerformingLoan findUnique
   */
  export type NonPerformingLoanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * Filter, which NonPerformingLoan to fetch.
     */
    where: NonPerformingLoanWhereUniqueInput
  }

  /**
   * NonPerformingLoan findUniqueOrThrow
   */
  export type NonPerformingLoanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * Filter, which NonPerformingLoan to fetch.
     */
    where: NonPerformingLoanWhereUniqueInput
  }

  /**
   * NonPerformingLoan findFirst
   */
  export type NonPerformingLoanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * Filter, which NonPerformingLoan to fetch.
     */
    where?: NonPerformingLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonPerformingLoans to fetch.
     */
    orderBy?: NonPerformingLoanOrderByWithRelationInput | NonPerformingLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonPerformingLoans.
     */
    cursor?: NonPerformingLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonPerformingLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonPerformingLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonPerformingLoans.
     */
    distinct?: NonPerformingLoanScalarFieldEnum | NonPerformingLoanScalarFieldEnum[]
  }

  /**
   * NonPerformingLoan findFirstOrThrow
   */
  export type NonPerformingLoanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * Filter, which NonPerformingLoan to fetch.
     */
    where?: NonPerformingLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonPerformingLoans to fetch.
     */
    orderBy?: NonPerformingLoanOrderByWithRelationInput | NonPerformingLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonPerformingLoans.
     */
    cursor?: NonPerformingLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonPerformingLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonPerformingLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonPerformingLoans.
     */
    distinct?: NonPerformingLoanScalarFieldEnum | NonPerformingLoanScalarFieldEnum[]
  }

  /**
   * NonPerformingLoan findMany
   */
  export type NonPerformingLoanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * Filter, which NonPerformingLoans to fetch.
     */
    where?: NonPerformingLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonPerformingLoans to fetch.
     */
    orderBy?: NonPerformingLoanOrderByWithRelationInput | NonPerformingLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NonPerformingLoans.
     */
    cursor?: NonPerformingLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonPerformingLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonPerformingLoans.
     */
    skip?: number
    distinct?: NonPerformingLoanScalarFieldEnum | NonPerformingLoanScalarFieldEnum[]
  }

  /**
   * NonPerformingLoan create
   */
  export type NonPerformingLoanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * The data needed to create a NonPerformingLoan.
     */
    data: XOR<NonPerformingLoanCreateInput, NonPerformingLoanUncheckedCreateInput>
  }

  /**
   * NonPerformingLoan createMany
   */
  export type NonPerformingLoanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NonPerformingLoans.
     */
    data: NonPerformingLoanCreateManyInput | NonPerformingLoanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NonPerformingLoan createManyAndReturn
   */
  export type NonPerformingLoanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * The data used to create many NonPerformingLoans.
     */
    data: NonPerformingLoanCreateManyInput | NonPerformingLoanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NonPerformingLoan update
   */
  export type NonPerformingLoanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * The data needed to update a NonPerformingLoan.
     */
    data: XOR<NonPerformingLoanUpdateInput, NonPerformingLoanUncheckedUpdateInput>
    /**
     * Choose, which NonPerformingLoan to update.
     */
    where: NonPerformingLoanWhereUniqueInput
  }

  /**
   * NonPerformingLoan updateMany
   */
  export type NonPerformingLoanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NonPerformingLoans.
     */
    data: XOR<NonPerformingLoanUpdateManyMutationInput, NonPerformingLoanUncheckedUpdateManyInput>
    /**
     * Filter which NonPerformingLoans to update
     */
    where?: NonPerformingLoanWhereInput
    /**
     * Limit how many NonPerformingLoans to update.
     */
    limit?: number
  }

  /**
   * NonPerformingLoan updateManyAndReturn
   */
  export type NonPerformingLoanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * The data used to update NonPerformingLoans.
     */
    data: XOR<NonPerformingLoanUpdateManyMutationInput, NonPerformingLoanUncheckedUpdateManyInput>
    /**
     * Filter which NonPerformingLoans to update
     */
    where?: NonPerformingLoanWhereInput
    /**
     * Limit how many NonPerformingLoans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NonPerformingLoan upsert
   */
  export type NonPerformingLoanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * The filter to search for the NonPerformingLoan to update in case it exists.
     */
    where: NonPerformingLoanWhereUniqueInput
    /**
     * In case the NonPerformingLoan found by the `where` argument doesn't exist, create a new NonPerformingLoan with this data.
     */
    create: XOR<NonPerformingLoanCreateInput, NonPerformingLoanUncheckedCreateInput>
    /**
     * In case the NonPerformingLoan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NonPerformingLoanUpdateInput, NonPerformingLoanUncheckedUpdateInput>
  }

  /**
   * NonPerformingLoan delete
   */
  export type NonPerformingLoanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
    /**
     * Filter which NonPerformingLoan to delete.
     */
    where: NonPerformingLoanWhereUniqueInput
  }

  /**
   * NonPerformingLoan deleteMany
   */
  export type NonPerformingLoanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonPerformingLoans to delete
     */
    where?: NonPerformingLoanWhereInput
    /**
     * Limit how many NonPerformingLoans to delete.
     */
    limit?: number
  }

  /**
   * NonPerformingLoan without action
   */
  export type NonPerformingLoanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonPerformingLoan
     */
    select?: NonPerformingLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonPerformingLoan
     */
    omit?: NonPerformingLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonPerformingLoanInclude<ExtArgs> | null
  }


  /**
   * Model RecoveryAgent
   */

  export type AggregateRecoveryAgent = {
    _count: RecoveryAgentCountAggregateOutputType | null
    _min: RecoveryAgentMinAggregateOutputType | null
    _max: RecoveryAgentMaxAggregateOutputType | null
  }

  export type RecoveryAgentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecoveryAgentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecoveryAgentCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    phone: number
    email: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecoveryAgentMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecoveryAgentMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecoveryAgentCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecoveryAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryAgent to aggregate.
     */
    where?: RecoveryAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryAgents to fetch.
     */
    orderBy?: RecoveryAgentOrderByWithRelationInput | RecoveryAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryAgents
    **/
    _count?: true | RecoveryAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryAgentMaxAggregateInputType
  }

  export type GetRecoveryAgentAggregateType<T extends RecoveryAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryAgent[P]>
      : GetScalarType<T[P], AggregateRecoveryAgent[P]>
  }




  export type RecoveryAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryAgentWhereInput
    orderBy?: RecoveryAgentOrderByWithAggregationInput | RecoveryAgentOrderByWithAggregationInput[]
    by: RecoveryAgentScalarFieldEnum[] | RecoveryAgentScalarFieldEnum
    having?: RecoveryAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryAgentCountAggregateInputType | true
    _min?: RecoveryAgentMinAggregateInputType
    _max?: RecoveryAgentMaxAggregateInputType
  }

  export type RecoveryAgentGroupByOutputType = {
    id: string
    userId: string | null
    name: string
    phone: string
    email: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RecoveryAgentCountAggregateOutputType | null
    _min: RecoveryAgentMinAggregateOutputType | null
    _max: RecoveryAgentMaxAggregateOutputType | null
  }

  type GetRecoveryAgentGroupByPayload<T extends RecoveryAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryAgentGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryAgentGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | RecoveryAgent$userArgs<ExtArgs>
    records?: boolean | RecoveryAgent$recordsArgs<ExtArgs>
    _count?: boolean | RecoveryAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryAgent"]>

  export type RecoveryAgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | RecoveryAgent$userArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryAgent"]>

  export type RecoveryAgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | RecoveryAgent$userArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryAgent"]>

  export type RecoveryAgentSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecoveryAgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "phone" | "email" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["recoveryAgent"]>
  export type RecoveryAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RecoveryAgent$userArgs<ExtArgs>
    records?: boolean | RecoveryAgent$recordsArgs<ExtArgs>
    _count?: boolean | RecoveryAgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecoveryAgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RecoveryAgent$userArgs<ExtArgs>
  }
  export type RecoveryAgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RecoveryAgent$userArgs<ExtArgs>
  }

  export type $RecoveryAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryAgent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      records: Prisma.$RecoveryRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      name: string
      phone: string
      email: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recoveryAgent"]>
    composites: {}
  }

  type RecoveryAgentGetPayload<S extends boolean | null | undefined | RecoveryAgentDefaultArgs> = $Result.GetResult<Prisma.$RecoveryAgentPayload, S>

  type RecoveryAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecoveryAgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecoveryAgentCountAggregateInputType | true
    }

  export interface RecoveryAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryAgent'], meta: { name: 'RecoveryAgent' } }
    /**
     * Find zero or one RecoveryAgent that matches the filter.
     * @param {RecoveryAgentFindUniqueArgs} args - Arguments to find a RecoveryAgent
     * @example
     * // Get one RecoveryAgent
     * const recoveryAgent = await prisma.recoveryAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryAgentFindUniqueArgs>(args: SelectSubset<T, RecoveryAgentFindUniqueArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecoveryAgent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecoveryAgentFindUniqueOrThrowArgs} args - Arguments to find a RecoveryAgent
     * @example
     * // Get one RecoveryAgent
     * const recoveryAgent = await prisma.recoveryAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryAgentFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryAgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryAgentFindFirstArgs} args - Arguments to find a RecoveryAgent
     * @example
     * // Get one RecoveryAgent
     * const recoveryAgent = await prisma.recoveryAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryAgentFindFirstArgs>(args?: SelectSubset<T, RecoveryAgentFindFirstArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryAgentFindFirstOrThrowArgs} args - Arguments to find a RecoveryAgent
     * @example
     * // Get one RecoveryAgent
     * const recoveryAgent = await prisma.recoveryAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryAgentFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryAgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecoveryAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryAgents
     * const recoveryAgents = await prisma.recoveryAgent.findMany()
     * 
     * // Get first 10 RecoveryAgents
     * const recoveryAgents = await prisma.recoveryAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recoveryAgentWithIdOnly = await prisma.recoveryAgent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecoveryAgentFindManyArgs>(args?: SelectSubset<T, RecoveryAgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecoveryAgent.
     * @param {RecoveryAgentCreateArgs} args - Arguments to create a RecoveryAgent.
     * @example
     * // Create one RecoveryAgent
     * const RecoveryAgent = await prisma.recoveryAgent.create({
     *   data: {
     *     // ... data to create a RecoveryAgent
     *   }
     * })
     * 
     */
    create<T extends RecoveryAgentCreateArgs>(args: SelectSubset<T, RecoveryAgentCreateArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecoveryAgents.
     * @param {RecoveryAgentCreateManyArgs} args - Arguments to create many RecoveryAgents.
     * @example
     * // Create many RecoveryAgents
     * const recoveryAgent = await prisma.recoveryAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryAgentCreateManyArgs>(args?: SelectSubset<T, RecoveryAgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecoveryAgents and returns the data saved in the database.
     * @param {RecoveryAgentCreateManyAndReturnArgs} args - Arguments to create many RecoveryAgents.
     * @example
     * // Create many RecoveryAgents
     * const recoveryAgent = await prisma.recoveryAgent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecoveryAgents and only return the `id`
     * const recoveryAgentWithIdOnly = await prisma.recoveryAgent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecoveryAgentCreateManyAndReturnArgs>(args?: SelectSubset<T, RecoveryAgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecoveryAgent.
     * @param {RecoveryAgentDeleteArgs} args - Arguments to delete one RecoveryAgent.
     * @example
     * // Delete one RecoveryAgent
     * const RecoveryAgent = await prisma.recoveryAgent.delete({
     *   where: {
     *     // ... filter to delete one RecoveryAgent
     *   }
     * })
     * 
     */
    delete<T extends RecoveryAgentDeleteArgs>(args: SelectSubset<T, RecoveryAgentDeleteArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecoveryAgent.
     * @param {RecoveryAgentUpdateArgs} args - Arguments to update one RecoveryAgent.
     * @example
     * // Update one RecoveryAgent
     * const recoveryAgent = await prisma.recoveryAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryAgentUpdateArgs>(args: SelectSubset<T, RecoveryAgentUpdateArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecoveryAgents.
     * @param {RecoveryAgentDeleteManyArgs} args - Arguments to filter RecoveryAgents to delete.
     * @example
     * // Delete a few RecoveryAgents
     * const { count } = await prisma.recoveryAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryAgentDeleteManyArgs>(args?: SelectSubset<T, RecoveryAgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryAgents
     * const recoveryAgent = await prisma.recoveryAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryAgentUpdateManyArgs>(args: SelectSubset<T, RecoveryAgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryAgents and returns the data updated in the database.
     * @param {RecoveryAgentUpdateManyAndReturnArgs} args - Arguments to update many RecoveryAgents.
     * @example
     * // Update many RecoveryAgents
     * const recoveryAgent = await prisma.recoveryAgent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecoveryAgents and only return the `id`
     * const recoveryAgentWithIdOnly = await prisma.recoveryAgent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecoveryAgentUpdateManyAndReturnArgs>(args: SelectSubset<T, RecoveryAgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecoveryAgent.
     * @param {RecoveryAgentUpsertArgs} args - Arguments to update or create a RecoveryAgent.
     * @example
     * // Update or create a RecoveryAgent
     * const recoveryAgent = await prisma.recoveryAgent.upsert({
     *   create: {
     *     // ... data to create a RecoveryAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryAgent we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryAgentUpsertArgs>(args: SelectSubset<T, RecoveryAgentUpsertArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecoveryAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryAgentCountArgs} args - Arguments to filter RecoveryAgents to count.
     * @example
     * // Count the number of RecoveryAgents
     * const count = await prisma.recoveryAgent.count({
     *   where: {
     *     // ... the filter for the RecoveryAgents we want to count
     *   }
     * })
    **/
    count<T extends RecoveryAgentCountArgs>(
      args?: Subset<T, RecoveryAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryAgentAggregateArgs>(args: Subset<T, RecoveryAgentAggregateArgs>): Prisma.PrismaPromise<GetRecoveryAgentAggregateType<T>>

    /**
     * Group by RecoveryAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryAgentGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryAgent model
   */
  readonly fields: RecoveryAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends RecoveryAgent$userArgs<ExtArgs> = {}>(args?: Subset<T, RecoveryAgent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    records<T extends RecoveryAgent$recordsArgs<ExtArgs> = {}>(args?: Subset<T, RecoveryAgent$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryAgent model
   */
  interface RecoveryAgentFieldRefs {
    readonly id: FieldRef<"RecoveryAgent", 'String'>
    readonly userId: FieldRef<"RecoveryAgent", 'String'>
    readonly name: FieldRef<"RecoveryAgent", 'String'>
    readonly phone: FieldRef<"RecoveryAgent", 'String'>
    readonly email: FieldRef<"RecoveryAgent", 'String'>
    readonly isActive: FieldRef<"RecoveryAgent", 'Boolean'>
    readonly createdAt: FieldRef<"RecoveryAgent", 'DateTime'>
    readonly updatedAt: FieldRef<"RecoveryAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryAgent findUnique
   */
  export type RecoveryAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryAgent to fetch.
     */
    where: RecoveryAgentWhereUniqueInput
  }

  /**
   * RecoveryAgent findUniqueOrThrow
   */
  export type RecoveryAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryAgent to fetch.
     */
    where: RecoveryAgentWhereUniqueInput
  }

  /**
   * RecoveryAgent findFirst
   */
  export type RecoveryAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryAgent to fetch.
     */
    where?: RecoveryAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryAgents to fetch.
     */
    orderBy?: RecoveryAgentOrderByWithRelationInput | RecoveryAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryAgents.
     */
    cursor?: RecoveryAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryAgents.
     */
    distinct?: RecoveryAgentScalarFieldEnum | RecoveryAgentScalarFieldEnum[]
  }

  /**
   * RecoveryAgent findFirstOrThrow
   */
  export type RecoveryAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryAgent to fetch.
     */
    where?: RecoveryAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryAgents to fetch.
     */
    orderBy?: RecoveryAgentOrderByWithRelationInput | RecoveryAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryAgents.
     */
    cursor?: RecoveryAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryAgents.
     */
    distinct?: RecoveryAgentScalarFieldEnum | RecoveryAgentScalarFieldEnum[]
  }

  /**
   * RecoveryAgent findMany
   */
  export type RecoveryAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryAgents to fetch.
     */
    where?: RecoveryAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryAgents to fetch.
     */
    orderBy?: RecoveryAgentOrderByWithRelationInput | RecoveryAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryAgents.
     */
    cursor?: RecoveryAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryAgents.
     */
    skip?: number
    distinct?: RecoveryAgentScalarFieldEnum | RecoveryAgentScalarFieldEnum[]
  }

  /**
   * RecoveryAgent create
   */
  export type RecoveryAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryAgent.
     */
    data: XOR<RecoveryAgentCreateInput, RecoveryAgentUncheckedCreateInput>
  }

  /**
   * RecoveryAgent createMany
   */
  export type RecoveryAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryAgents.
     */
    data: RecoveryAgentCreateManyInput | RecoveryAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecoveryAgent createManyAndReturn
   */
  export type RecoveryAgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * The data used to create many RecoveryAgents.
     */
    data: RecoveryAgentCreateManyInput | RecoveryAgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryAgent update
   */
  export type RecoveryAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryAgent.
     */
    data: XOR<RecoveryAgentUpdateInput, RecoveryAgentUncheckedUpdateInput>
    /**
     * Choose, which RecoveryAgent to update.
     */
    where: RecoveryAgentWhereUniqueInput
  }

  /**
   * RecoveryAgent updateMany
   */
  export type RecoveryAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryAgents.
     */
    data: XOR<RecoveryAgentUpdateManyMutationInput, RecoveryAgentUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryAgents to update
     */
    where?: RecoveryAgentWhereInput
    /**
     * Limit how many RecoveryAgents to update.
     */
    limit?: number
  }

  /**
   * RecoveryAgent updateManyAndReturn
   */
  export type RecoveryAgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * The data used to update RecoveryAgents.
     */
    data: XOR<RecoveryAgentUpdateManyMutationInput, RecoveryAgentUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryAgents to update
     */
    where?: RecoveryAgentWhereInput
    /**
     * Limit how many RecoveryAgents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryAgent upsert
   */
  export type RecoveryAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryAgent to update in case it exists.
     */
    where: RecoveryAgentWhereUniqueInput
    /**
     * In case the RecoveryAgent found by the `where` argument doesn't exist, create a new RecoveryAgent with this data.
     */
    create: XOR<RecoveryAgentCreateInput, RecoveryAgentUncheckedCreateInput>
    /**
     * In case the RecoveryAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryAgentUpdateInput, RecoveryAgentUncheckedUpdateInput>
  }

  /**
   * RecoveryAgent delete
   */
  export type RecoveryAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
    /**
     * Filter which RecoveryAgent to delete.
     */
    where: RecoveryAgentWhereUniqueInput
  }

  /**
   * RecoveryAgent deleteMany
   */
  export type RecoveryAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryAgents to delete
     */
    where?: RecoveryAgentWhereInput
    /**
     * Limit how many RecoveryAgents to delete.
     */
    limit?: number
  }

  /**
   * RecoveryAgent.user
   */
  export type RecoveryAgent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RecoveryAgent.records
   */
  export type RecoveryAgent$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    where?: RecoveryRecordWhereInput
    orderBy?: RecoveryRecordOrderByWithRelationInput | RecoveryRecordOrderByWithRelationInput[]
    cursor?: RecoveryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecoveryRecordScalarFieldEnum | RecoveryRecordScalarFieldEnum[]
  }

  /**
   * RecoveryAgent without action
   */
  export type RecoveryAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryAgent
     */
    select?: RecoveryAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryAgent
     */
    omit?: RecoveryAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryAgentInclude<ExtArgs> | null
  }


  /**
   * Model RecoveryRecord
   */

  export type AggregateRecoveryRecord = {
    _count: RecoveryRecordCountAggregateOutputType | null
    _min: RecoveryRecordMinAggregateOutputType | null
    _max: RecoveryRecordMaxAggregateOutputType | null
  }

  export type RecoveryRecordMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    agentId: string | null
    actionTaken: string | null
    outcome: string | null
    recordedAt: Date | null
    createdAt: Date | null
  }

  export type RecoveryRecordMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    agentId: string | null
    actionTaken: string | null
    outcome: string | null
    recordedAt: Date | null
    createdAt: Date | null
  }

  export type RecoveryRecordCountAggregateOutputType = {
    id: number
    loanId: number
    agentId: number
    actionTaken: number
    outcome: number
    recordedAt: number
    createdAt: number
    _all: number
  }


  export type RecoveryRecordMinAggregateInputType = {
    id?: true
    loanId?: true
    agentId?: true
    actionTaken?: true
    outcome?: true
    recordedAt?: true
    createdAt?: true
  }

  export type RecoveryRecordMaxAggregateInputType = {
    id?: true
    loanId?: true
    agentId?: true
    actionTaken?: true
    outcome?: true
    recordedAt?: true
    createdAt?: true
  }

  export type RecoveryRecordCountAggregateInputType = {
    id?: true
    loanId?: true
    agentId?: true
    actionTaken?: true
    outcome?: true
    recordedAt?: true
    createdAt?: true
    _all?: true
  }

  export type RecoveryRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryRecord to aggregate.
     */
    where?: RecoveryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRecords to fetch.
     */
    orderBy?: RecoveryRecordOrderByWithRelationInput | RecoveryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryRecords
    **/
    _count?: true | RecoveryRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryRecordMaxAggregateInputType
  }

  export type GetRecoveryRecordAggregateType<T extends RecoveryRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryRecord[P]>
      : GetScalarType<T[P], AggregateRecoveryRecord[P]>
  }




  export type RecoveryRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryRecordWhereInput
    orderBy?: RecoveryRecordOrderByWithAggregationInput | RecoveryRecordOrderByWithAggregationInput[]
    by: RecoveryRecordScalarFieldEnum[] | RecoveryRecordScalarFieldEnum
    having?: RecoveryRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryRecordCountAggregateInputType | true
    _min?: RecoveryRecordMinAggregateInputType
    _max?: RecoveryRecordMaxAggregateInputType
  }

  export type RecoveryRecordGroupByOutputType = {
    id: string
    loanId: string
    agentId: string
    actionTaken: string
    outcome: string | null
    recordedAt: Date
    createdAt: Date
    _count: RecoveryRecordCountAggregateOutputType | null
    _min: RecoveryRecordMinAggregateOutputType | null
    _max: RecoveryRecordMaxAggregateOutputType | null
  }

  type GetRecoveryRecordGroupByPayload<T extends RecoveryRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryRecordGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    agentId?: boolean
    actionTaken?: boolean
    outcome?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    agent?: boolean | RecoveryAgentDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryRecord"]>

  export type RecoveryRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    agentId?: boolean
    actionTaken?: boolean
    outcome?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    agent?: boolean | RecoveryAgentDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryRecord"]>

  export type RecoveryRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    agentId?: boolean
    actionTaken?: boolean
    outcome?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    agent?: boolean | RecoveryAgentDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryRecord"]>

  export type RecoveryRecordSelectScalar = {
    id?: boolean
    loanId?: boolean
    agentId?: boolean
    actionTaken?: boolean
    outcome?: boolean
    recordedAt?: boolean
    createdAt?: boolean
  }

  export type RecoveryRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "agentId" | "actionTaken" | "outcome" | "recordedAt" | "createdAt", ExtArgs["result"]["recoveryRecord"]>
  export type RecoveryRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | RecoveryAgentDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type RecoveryRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | RecoveryAgentDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type RecoveryRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | RecoveryAgentDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $RecoveryRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryRecord"
    objects: {
      agent: Prisma.$RecoveryAgentPayload<ExtArgs>
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      agentId: string
      actionTaken: string
      outcome: string | null
      recordedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["recoveryRecord"]>
    composites: {}
  }

  type RecoveryRecordGetPayload<S extends boolean | null | undefined | RecoveryRecordDefaultArgs> = $Result.GetResult<Prisma.$RecoveryRecordPayload, S>

  type RecoveryRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecoveryRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecoveryRecordCountAggregateInputType | true
    }

  export interface RecoveryRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryRecord'], meta: { name: 'RecoveryRecord' } }
    /**
     * Find zero or one RecoveryRecord that matches the filter.
     * @param {RecoveryRecordFindUniqueArgs} args - Arguments to find a RecoveryRecord
     * @example
     * // Get one RecoveryRecord
     * const recoveryRecord = await prisma.recoveryRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryRecordFindUniqueArgs>(args: SelectSubset<T, RecoveryRecordFindUniqueArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecoveryRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecoveryRecordFindUniqueOrThrowArgs} args - Arguments to find a RecoveryRecord
     * @example
     * // Get one RecoveryRecord
     * const recoveryRecord = await prisma.recoveryRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRecordFindFirstArgs} args - Arguments to find a RecoveryRecord
     * @example
     * // Get one RecoveryRecord
     * const recoveryRecord = await prisma.recoveryRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryRecordFindFirstArgs>(args?: SelectSubset<T, RecoveryRecordFindFirstArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRecordFindFirstOrThrowArgs} args - Arguments to find a RecoveryRecord
     * @example
     * // Get one RecoveryRecord
     * const recoveryRecord = await prisma.recoveryRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecoveryRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryRecords
     * const recoveryRecords = await prisma.recoveryRecord.findMany()
     * 
     * // Get first 10 RecoveryRecords
     * const recoveryRecords = await prisma.recoveryRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recoveryRecordWithIdOnly = await prisma.recoveryRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecoveryRecordFindManyArgs>(args?: SelectSubset<T, RecoveryRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecoveryRecord.
     * @param {RecoveryRecordCreateArgs} args - Arguments to create a RecoveryRecord.
     * @example
     * // Create one RecoveryRecord
     * const RecoveryRecord = await prisma.recoveryRecord.create({
     *   data: {
     *     // ... data to create a RecoveryRecord
     *   }
     * })
     * 
     */
    create<T extends RecoveryRecordCreateArgs>(args: SelectSubset<T, RecoveryRecordCreateArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecoveryRecords.
     * @param {RecoveryRecordCreateManyArgs} args - Arguments to create many RecoveryRecords.
     * @example
     * // Create many RecoveryRecords
     * const recoveryRecord = await prisma.recoveryRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryRecordCreateManyArgs>(args?: SelectSubset<T, RecoveryRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecoveryRecords and returns the data saved in the database.
     * @param {RecoveryRecordCreateManyAndReturnArgs} args - Arguments to create many RecoveryRecords.
     * @example
     * // Create many RecoveryRecords
     * const recoveryRecord = await prisma.recoveryRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecoveryRecords and only return the `id`
     * const recoveryRecordWithIdOnly = await prisma.recoveryRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecoveryRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, RecoveryRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecoveryRecord.
     * @param {RecoveryRecordDeleteArgs} args - Arguments to delete one RecoveryRecord.
     * @example
     * // Delete one RecoveryRecord
     * const RecoveryRecord = await prisma.recoveryRecord.delete({
     *   where: {
     *     // ... filter to delete one RecoveryRecord
     *   }
     * })
     * 
     */
    delete<T extends RecoveryRecordDeleteArgs>(args: SelectSubset<T, RecoveryRecordDeleteArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecoveryRecord.
     * @param {RecoveryRecordUpdateArgs} args - Arguments to update one RecoveryRecord.
     * @example
     * // Update one RecoveryRecord
     * const recoveryRecord = await prisma.recoveryRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryRecordUpdateArgs>(args: SelectSubset<T, RecoveryRecordUpdateArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecoveryRecords.
     * @param {RecoveryRecordDeleteManyArgs} args - Arguments to filter RecoveryRecords to delete.
     * @example
     * // Delete a few RecoveryRecords
     * const { count } = await prisma.recoveryRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryRecordDeleteManyArgs>(args?: SelectSubset<T, RecoveryRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryRecords
     * const recoveryRecord = await prisma.recoveryRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryRecordUpdateManyArgs>(args: SelectSubset<T, RecoveryRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryRecords and returns the data updated in the database.
     * @param {RecoveryRecordUpdateManyAndReturnArgs} args - Arguments to update many RecoveryRecords.
     * @example
     * // Update many RecoveryRecords
     * const recoveryRecord = await prisma.recoveryRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecoveryRecords and only return the `id`
     * const recoveryRecordWithIdOnly = await prisma.recoveryRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecoveryRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, RecoveryRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecoveryRecord.
     * @param {RecoveryRecordUpsertArgs} args - Arguments to update or create a RecoveryRecord.
     * @example
     * // Update or create a RecoveryRecord
     * const recoveryRecord = await prisma.recoveryRecord.upsert({
     *   create: {
     *     // ... data to create a RecoveryRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryRecord we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryRecordUpsertArgs>(args: SelectSubset<T, RecoveryRecordUpsertArgs<ExtArgs>>): Prisma__RecoveryRecordClient<$Result.GetResult<Prisma.$RecoveryRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecoveryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRecordCountArgs} args - Arguments to filter RecoveryRecords to count.
     * @example
     * // Count the number of RecoveryRecords
     * const count = await prisma.recoveryRecord.count({
     *   where: {
     *     // ... the filter for the RecoveryRecords we want to count
     *   }
     * })
    **/
    count<T extends RecoveryRecordCountArgs>(
      args?: Subset<T, RecoveryRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryRecordAggregateArgs>(args: Subset<T, RecoveryRecordAggregateArgs>): Prisma.PrismaPromise<GetRecoveryRecordAggregateType<T>>

    /**
     * Group by RecoveryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryRecordGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryRecord model
   */
  readonly fields: RecoveryRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends RecoveryAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecoveryAgentDefaultArgs<ExtArgs>>): Prisma__RecoveryAgentClient<$Result.GetResult<Prisma.$RecoveryAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryRecord model
   */
  interface RecoveryRecordFieldRefs {
    readonly id: FieldRef<"RecoveryRecord", 'String'>
    readonly loanId: FieldRef<"RecoveryRecord", 'String'>
    readonly agentId: FieldRef<"RecoveryRecord", 'String'>
    readonly actionTaken: FieldRef<"RecoveryRecord", 'String'>
    readonly outcome: FieldRef<"RecoveryRecord", 'String'>
    readonly recordedAt: FieldRef<"RecoveryRecord", 'DateTime'>
    readonly createdAt: FieldRef<"RecoveryRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryRecord findUnique
   */
  export type RecoveryRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryRecord to fetch.
     */
    where: RecoveryRecordWhereUniqueInput
  }

  /**
   * RecoveryRecord findUniqueOrThrow
   */
  export type RecoveryRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryRecord to fetch.
     */
    where: RecoveryRecordWhereUniqueInput
  }

  /**
   * RecoveryRecord findFirst
   */
  export type RecoveryRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryRecord to fetch.
     */
    where?: RecoveryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRecords to fetch.
     */
    orderBy?: RecoveryRecordOrderByWithRelationInput | RecoveryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryRecords.
     */
    cursor?: RecoveryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryRecords.
     */
    distinct?: RecoveryRecordScalarFieldEnum | RecoveryRecordScalarFieldEnum[]
  }

  /**
   * RecoveryRecord findFirstOrThrow
   */
  export type RecoveryRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryRecord to fetch.
     */
    where?: RecoveryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRecords to fetch.
     */
    orderBy?: RecoveryRecordOrderByWithRelationInput | RecoveryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryRecords.
     */
    cursor?: RecoveryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryRecords.
     */
    distinct?: RecoveryRecordScalarFieldEnum | RecoveryRecordScalarFieldEnum[]
  }

  /**
   * RecoveryRecord findMany
   */
  export type RecoveryRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryRecords to fetch.
     */
    where?: RecoveryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRecords to fetch.
     */
    orderBy?: RecoveryRecordOrderByWithRelationInput | RecoveryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryRecords.
     */
    cursor?: RecoveryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRecords.
     */
    skip?: number
    distinct?: RecoveryRecordScalarFieldEnum | RecoveryRecordScalarFieldEnum[]
  }

  /**
   * RecoveryRecord create
   */
  export type RecoveryRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryRecord.
     */
    data: XOR<RecoveryRecordCreateInput, RecoveryRecordUncheckedCreateInput>
  }

  /**
   * RecoveryRecord createMany
   */
  export type RecoveryRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryRecords.
     */
    data: RecoveryRecordCreateManyInput | RecoveryRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecoveryRecord createManyAndReturn
   */
  export type RecoveryRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * The data used to create many RecoveryRecords.
     */
    data: RecoveryRecordCreateManyInput | RecoveryRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryRecord update
   */
  export type RecoveryRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryRecord.
     */
    data: XOR<RecoveryRecordUpdateInput, RecoveryRecordUncheckedUpdateInput>
    /**
     * Choose, which RecoveryRecord to update.
     */
    where: RecoveryRecordWhereUniqueInput
  }

  /**
   * RecoveryRecord updateMany
   */
  export type RecoveryRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryRecords.
     */
    data: XOR<RecoveryRecordUpdateManyMutationInput, RecoveryRecordUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryRecords to update
     */
    where?: RecoveryRecordWhereInput
    /**
     * Limit how many RecoveryRecords to update.
     */
    limit?: number
  }

  /**
   * RecoveryRecord updateManyAndReturn
   */
  export type RecoveryRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * The data used to update RecoveryRecords.
     */
    data: XOR<RecoveryRecordUpdateManyMutationInput, RecoveryRecordUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryRecords to update
     */
    where?: RecoveryRecordWhereInput
    /**
     * Limit how many RecoveryRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryRecord upsert
   */
  export type RecoveryRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryRecord to update in case it exists.
     */
    where: RecoveryRecordWhereUniqueInput
    /**
     * In case the RecoveryRecord found by the `where` argument doesn't exist, create a new RecoveryRecord with this data.
     */
    create: XOR<RecoveryRecordCreateInput, RecoveryRecordUncheckedCreateInput>
    /**
     * In case the RecoveryRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryRecordUpdateInput, RecoveryRecordUncheckedUpdateInput>
  }

  /**
   * RecoveryRecord delete
   */
  export type RecoveryRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
    /**
     * Filter which RecoveryRecord to delete.
     */
    where: RecoveryRecordWhereUniqueInput
  }

  /**
   * RecoveryRecord deleteMany
   */
  export type RecoveryRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryRecords to delete
     */
    where?: RecoveryRecordWhereInput
    /**
     * Limit how many RecoveryRecords to delete.
     */
    limit?: number
  }

  /**
   * RecoveryRecord without action
   */
  export type RecoveryRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRecord
     */
    select?: RecoveryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRecord
     */
    omit?: RecoveryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryRecordInclude<ExtArgs> | null
  }


  /**
   * Model Investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorAvgAggregateOutputType = {
    investedAmount: Decimal | null
  }

  export type InvestorSumAggregateOutputType = {
    investedAmount: Decimal | null
  }

  export type InvestorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    contact: string | null
    email: string | null
    investedAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    contact: string | null
    email: string | null
    investedAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    contact: number
    email: number
    investedAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorAvgAggregateInputType = {
    investedAmount?: true
  }

  export type InvestorSumAggregateInputType = {
    investedAmount?: true
  }

  export type InvestorMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contact?: true
    email?: true
    investedAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contact?: true
    email?: true
    investedAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contact?: true
    email?: true
    investedAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investor to aggregate.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type InvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithAggregationInput | InvestorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: InvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _avg?: InvestorAvgAggregateInputType
    _sum?: InvestorSumAggregateInputType
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: string
    userId: string | null
    name: string
    contact: string
    email: string | null
    investedAmount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends InvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type InvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    investedAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    allocations?: boolean | Investor$allocationsArgs<ExtArgs>
    payouts?: boolean | Investor$payoutsArgs<ExtArgs>
    user?: boolean | Investor$userArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    investedAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Investor$userArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    investedAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Investor$userArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    investedAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "contact" | "email" | "investedAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["investor"]>
  export type InvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | Investor$allocationsArgs<ExtArgs>
    payouts?: boolean | Investor$payoutsArgs<ExtArgs>
    user?: boolean | Investor$userArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvestorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Investor$userArgs<ExtArgs>
  }
  export type InvestorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Investor$userArgs<ExtArgs>
  }

  export type $InvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investor"
    objects: {
      allocations: Prisma.$InvestorAllocationPayload<ExtArgs>[]
      payouts: Prisma.$InvestorPayoutPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      name: string
      contact: string
      email: string | null
      investedAmount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }

  type InvestorGetPayload<S extends boolean | null | undefined | InvestorDefaultArgs> = $Result.GetResult<Prisma.$InvestorPayload, S>

  type InvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface InvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investor'], meta: { name: 'Investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {InvestorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorFindUniqueArgs>(args: SelectSubset<T, InvestorFindUniqueArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Investor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorFindFirstArgs>(args?: SelectSubset<T, InvestorFindFirstArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorFindManyArgs>(args?: SelectSubset<T, InvestorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Investor.
     * @param {InvestorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
     */
    create<T extends InvestorCreateArgs>(args: SelectSubset<T, InvestorCreateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Investors.
     * @param {InvestorCreateManyArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorCreateManyArgs>(args?: SelectSubset<T, InvestorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Investors and returns the data saved in the database.
     * @param {InvestorCreateManyAndReturnArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Investors and only return the `id`
     * const investorWithIdOnly = await prisma.investor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Investor.
     * @param {InvestorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
     */
    delete<T extends InvestorDeleteArgs>(args: SelectSubset<T, InvestorDeleteArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Investor.
     * @param {InvestorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorUpdateArgs>(args: SelectSubset<T, InvestorUpdateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Investors.
     * @param {InvestorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorDeleteManyArgs>(args?: SelectSubset<T, InvestorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorUpdateManyArgs>(args: SelectSubset<T, InvestorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors and returns the data updated in the database.
     * @param {InvestorUpdateManyAndReturnArgs} args - Arguments to update many Investors.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Investors and only return the `id`
     * const investorWithIdOnly = await prisma.investor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestorUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Investor.
     * @param {InvestorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
     */
    upsert<T extends InvestorUpsertArgs>(args: SelectSubset<T, InvestorUpsertArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends InvestorCountArgs>(
      args?: Subset<T, InvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorGroupByArgs['orderBy'] }
        : { orderBy?: InvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investor model
   */
  readonly fields: InvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    allocations<T extends Investor$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payouts<T extends Investor$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Investor$userArgs<ExtArgs> = {}>(args?: Subset<T, Investor$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investor model
   */
  interface InvestorFieldRefs {
    readonly id: FieldRef<"Investor", 'String'>
    readonly userId: FieldRef<"Investor", 'String'>
    readonly name: FieldRef<"Investor", 'String'>
    readonly contact: FieldRef<"Investor", 'String'>
    readonly email: FieldRef<"Investor", 'String'>
    readonly investedAmount: FieldRef<"Investor", 'Decimal'>
    readonly createdAt: FieldRef<"Investor", 'DateTime'>
    readonly updatedAt: FieldRef<"Investor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Investor findUnique
   */
  export type InvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findUniqueOrThrow
   */
  export type InvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findFirst
   */
  export type InvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findFirstOrThrow
   */
  export type InvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findMany
   */
  export type InvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investors to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor create
   */
  export type InvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a Investor.
     */
    data: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
  }

  /**
   * Investor createMany
   */
  export type InvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Investor createManyAndReturn
   */
  export type InvestorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investor update
   */
  export type InvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a Investor.
     */
    data: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
    /**
     * Choose, which Investor to update.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor updateMany
   */
  export type InvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to update.
     */
    limit?: number
  }

  /**
   * Investor updateManyAndReturn
   */
  export type InvestorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investor upsert
   */
  export type InvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the Investor to update in case it exists.
     */
    where: InvestorWhereUniqueInput
    /**
     * In case the Investor found by the `where` argument doesn't exist, create a new Investor with this data.
     */
    create: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
    /**
     * In case the Investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
  }

  /**
   * Investor delete
   */
  export type InvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter which Investor to delete.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor deleteMany
   */
  export type InvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investors to delete
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to delete.
     */
    limit?: number
  }

  /**
   * Investor.allocations
   */
  export type Investor$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    where?: InvestorAllocationWhereInput
    orderBy?: InvestorAllocationOrderByWithRelationInput | InvestorAllocationOrderByWithRelationInput[]
    cursor?: InvestorAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorAllocationScalarFieldEnum | InvestorAllocationScalarFieldEnum[]
  }

  /**
   * Investor.payouts
   */
  export type Investor$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    where?: InvestorPayoutWhereInput
    orderBy?: InvestorPayoutOrderByWithRelationInput | InvestorPayoutOrderByWithRelationInput[]
    cursor?: InvestorPayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorPayoutScalarFieldEnum | InvestorPayoutScalarFieldEnum[]
  }

  /**
   * Investor.user
   */
  export type Investor$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Investor without action
   */
  export type InvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
  }


  /**
   * Model InvestorAllocation
   */

  export type AggregateInvestorAllocation = {
    _count: InvestorAllocationCountAggregateOutputType | null
    _avg: InvestorAllocationAvgAggregateOutputType | null
    _sum: InvestorAllocationSumAggregateOutputType | null
    _min: InvestorAllocationMinAggregateOutputType | null
    _max: InvestorAllocationMaxAggregateOutputType | null
  }

  export type InvestorAllocationAvgAggregateOutputType = {
    allocatedAmount: Decimal | null
    expectedReturn: Decimal | null
    actualReturn: Decimal | null
  }

  export type InvestorAllocationSumAggregateOutputType = {
    allocatedAmount: Decimal | null
    expectedReturn: Decimal | null
    actualReturn: Decimal | null
  }

  export type InvestorAllocationMinAggregateOutputType = {
    id: string | null
    investorId: string | null
    loanId: string | null
    allocatedAmount: Decimal | null
    expectedReturn: Decimal | null
    actualReturn: Decimal | null
    allocationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorAllocationMaxAggregateOutputType = {
    id: string | null
    investorId: string | null
    loanId: string | null
    allocatedAmount: Decimal | null
    expectedReturn: Decimal | null
    actualReturn: Decimal | null
    allocationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorAllocationCountAggregateOutputType = {
    id: number
    investorId: number
    loanId: number
    allocatedAmount: number
    expectedReturn: number
    actualReturn: number
    allocationDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorAllocationAvgAggregateInputType = {
    allocatedAmount?: true
    expectedReturn?: true
    actualReturn?: true
  }

  export type InvestorAllocationSumAggregateInputType = {
    allocatedAmount?: true
    expectedReturn?: true
    actualReturn?: true
  }

  export type InvestorAllocationMinAggregateInputType = {
    id?: true
    investorId?: true
    loanId?: true
    allocatedAmount?: true
    expectedReturn?: true
    actualReturn?: true
    allocationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorAllocationMaxAggregateInputType = {
    id?: true
    investorId?: true
    loanId?: true
    allocatedAmount?: true
    expectedReturn?: true
    actualReturn?: true
    allocationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorAllocationCountAggregateInputType = {
    id?: true
    investorId?: true
    loanId?: true
    allocatedAmount?: true
    expectedReturn?: true
    actualReturn?: true
    allocationDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorAllocation to aggregate.
     */
    where?: InvestorAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorAllocations to fetch.
     */
    orderBy?: InvestorAllocationOrderByWithRelationInput | InvestorAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestorAllocations
    **/
    _count?: true | InvestorAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorAllocationMaxAggregateInputType
  }

  export type GetInvestorAllocationAggregateType<T extends InvestorAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestorAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestorAllocation[P]>
      : GetScalarType<T[P], AggregateInvestorAllocation[P]>
  }




  export type InvestorAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorAllocationWhereInput
    orderBy?: InvestorAllocationOrderByWithAggregationInput | InvestorAllocationOrderByWithAggregationInput[]
    by: InvestorAllocationScalarFieldEnum[] | InvestorAllocationScalarFieldEnum
    having?: InvestorAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorAllocationCountAggregateInputType | true
    _avg?: InvestorAllocationAvgAggregateInputType
    _sum?: InvestorAllocationSumAggregateInputType
    _min?: InvestorAllocationMinAggregateInputType
    _max?: InvestorAllocationMaxAggregateInputType
  }

  export type InvestorAllocationGroupByOutputType = {
    id: string
    investorId: string
    loanId: string
    allocatedAmount: Decimal
    expectedReturn: Decimal | null
    actualReturn: Decimal
    allocationDate: Date
    createdAt: Date
    updatedAt: Date
    _count: InvestorAllocationCountAggregateOutputType | null
    _avg: InvestorAllocationAvgAggregateOutputType | null
    _sum: InvestorAllocationSumAggregateOutputType | null
    _min: InvestorAllocationMinAggregateOutputType | null
    _max: InvestorAllocationMaxAggregateOutputType | null
  }

  type GetInvestorAllocationGroupByPayload<T extends InvestorAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorAllocationGroupByOutputType[P]>
        }
      >
    >


  export type InvestorAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    loanId?: boolean
    allocatedAmount?: boolean
    expectedReturn?: boolean
    actualReturn?: boolean
    allocationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorAllocation"]>

  export type InvestorAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    loanId?: boolean
    allocatedAmount?: boolean
    expectedReturn?: boolean
    actualReturn?: boolean
    allocationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorAllocation"]>

  export type InvestorAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    loanId?: boolean
    allocatedAmount?: boolean
    expectedReturn?: boolean
    actualReturn?: boolean
    allocationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorAllocation"]>

  export type InvestorAllocationSelectScalar = {
    id?: boolean
    investorId?: boolean
    loanId?: boolean
    allocatedAmount?: boolean
    expectedReturn?: boolean
    actualReturn?: boolean
    allocationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "investorId" | "loanId" | "allocatedAmount" | "expectedReturn" | "actualReturn" | "allocationDate" | "createdAt" | "updatedAt", ExtArgs["result"]["investorAllocation"]>
  export type InvestorAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type InvestorAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }
  export type InvestorAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    loan?: boolean | LoanApplicationDefaultArgs<ExtArgs>
  }

  export type $InvestorAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestorAllocation"
    objects: {
      investor: Prisma.$InvestorPayload<ExtArgs>
      loan: Prisma.$LoanApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investorId: string
      loanId: string
      allocatedAmount: Prisma.Decimal
      expectedReturn: Prisma.Decimal | null
      actualReturn: Prisma.Decimal
      allocationDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investorAllocation"]>
    composites: {}
  }

  type InvestorAllocationGetPayload<S extends boolean | null | undefined | InvestorAllocationDefaultArgs> = $Result.GetResult<Prisma.$InvestorAllocationPayload, S>

  type InvestorAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorAllocationCountAggregateInputType | true
    }

  export interface InvestorAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestorAllocation'], meta: { name: 'InvestorAllocation' } }
    /**
     * Find zero or one InvestorAllocation that matches the filter.
     * @param {InvestorAllocationFindUniqueArgs} args - Arguments to find a InvestorAllocation
     * @example
     * // Get one InvestorAllocation
     * const investorAllocation = await prisma.investorAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorAllocationFindUniqueArgs>(args: SelectSubset<T, InvestorAllocationFindUniqueArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvestorAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorAllocationFindUniqueOrThrowArgs} args - Arguments to find a InvestorAllocation
     * @example
     * // Get one InvestorAllocation
     * const investorAllocation = await prisma.investorAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAllocationFindFirstArgs} args - Arguments to find a InvestorAllocation
     * @example
     * // Get one InvestorAllocation
     * const investorAllocation = await prisma.investorAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorAllocationFindFirstArgs>(args?: SelectSubset<T, InvestorAllocationFindFirstArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAllocationFindFirstOrThrowArgs} args - Arguments to find a InvestorAllocation
     * @example
     * // Get one InvestorAllocation
     * const investorAllocation = await prisma.investorAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvestorAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestorAllocations
     * const investorAllocations = await prisma.investorAllocation.findMany()
     * 
     * // Get first 10 InvestorAllocations
     * const investorAllocations = await prisma.investorAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorAllocationWithIdOnly = await prisma.investorAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorAllocationFindManyArgs>(args?: SelectSubset<T, InvestorAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvestorAllocation.
     * @param {InvestorAllocationCreateArgs} args - Arguments to create a InvestorAllocation.
     * @example
     * // Create one InvestorAllocation
     * const InvestorAllocation = await prisma.investorAllocation.create({
     *   data: {
     *     // ... data to create a InvestorAllocation
     *   }
     * })
     * 
     */
    create<T extends InvestorAllocationCreateArgs>(args: SelectSubset<T, InvestorAllocationCreateArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvestorAllocations.
     * @param {InvestorAllocationCreateManyArgs} args - Arguments to create many InvestorAllocations.
     * @example
     * // Create many InvestorAllocations
     * const investorAllocation = await prisma.investorAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorAllocationCreateManyArgs>(args?: SelectSubset<T, InvestorAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestorAllocations and returns the data saved in the database.
     * @param {InvestorAllocationCreateManyAndReturnArgs} args - Arguments to create many InvestorAllocations.
     * @example
     * // Create many InvestorAllocations
     * const investorAllocation = await prisma.investorAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestorAllocations and only return the `id`
     * const investorAllocationWithIdOnly = await prisma.investorAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvestorAllocation.
     * @param {InvestorAllocationDeleteArgs} args - Arguments to delete one InvestorAllocation.
     * @example
     * // Delete one InvestorAllocation
     * const InvestorAllocation = await prisma.investorAllocation.delete({
     *   where: {
     *     // ... filter to delete one InvestorAllocation
     *   }
     * })
     * 
     */
    delete<T extends InvestorAllocationDeleteArgs>(args: SelectSubset<T, InvestorAllocationDeleteArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvestorAllocation.
     * @param {InvestorAllocationUpdateArgs} args - Arguments to update one InvestorAllocation.
     * @example
     * // Update one InvestorAllocation
     * const investorAllocation = await prisma.investorAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorAllocationUpdateArgs>(args: SelectSubset<T, InvestorAllocationUpdateArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvestorAllocations.
     * @param {InvestorAllocationDeleteManyArgs} args - Arguments to filter InvestorAllocations to delete.
     * @example
     * // Delete a few InvestorAllocations
     * const { count } = await prisma.investorAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorAllocationDeleteManyArgs>(args?: SelectSubset<T, InvestorAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestorAllocations
     * const investorAllocation = await prisma.investorAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorAllocationUpdateManyArgs>(args: SelectSubset<T, InvestorAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorAllocations and returns the data updated in the database.
     * @param {InvestorAllocationUpdateManyAndReturnArgs} args - Arguments to update many InvestorAllocations.
     * @example
     * // Update many InvestorAllocations
     * const investorAllocation = await prisma.investorAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvestorAllocations and only return the `id`
     * const investorAllocationWithIdOnly = await prisma.investorAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestorAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestorAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvestorAllocation.
     * @param {InvestorAllocationUpsertArgs} args - Arguments to update or create a InvestorAllocation.
     * @example
     * // Update or create a InvestorAllocation
     * const investorAllocation = await prisma.investorAllocation.upsert({
     *   create: {
     *     // ... data to create a InvestorAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestorAllocation we want to update
     *   }
     * })
     */
    upsert<T extends InvestorAllocationUpsertArgs>(args: SelectSubset<T, InvestorAllocationUpsertArgs<ExtArgs>>): Prisma__InvestorAllocationClient<$Result.GetResult<Prisma.$InvestorAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvestorAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAllocationCountArgs} args - Arguments to filter InvestorAllocations to count.
     * @example
     * // Count the number of InvestorAllocations
     * const count = await prisma.investorAllocation.count({
     *   where: {
     *     // ... the filter for the InvestorAllocations we want to count
     *   }
     * })
    **/
    count<T extends InvestorAllocationCountArgs>(
      args?: Subset<T, InvestorAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestorAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAllocationAggregateArgs>(args: Subset<T, InvestorAllocationAggregateArgs>): Prisma.PrismaPromise<GetInvestorAllocationAggregateType<T>>

    /**
     * Group by InvestorAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorAllocationGroupByArgs['orderBy'] }
        : { orderBy?: InvestorAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestorAllocation model
   */
  readonly fields: InvestorAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestorAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    loan<T extends LoanApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanApplicationDefaultArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestorAllocation model
   */
  interface InvestorAllocationFieldRefs {
    readonly id: FieldRef<"InvestorAllocation", 'String'>
    readonly investorId: FieldRef<"InvestorAllocation", 'String'>
    readonly loanId: FieldRef<"InvestorAllocation", 'String'>
    readonly allocatedAmount: FieldRef<"InvestorAllocation", 'Decimal'>
    readonly expectedReturn: FieldRef<"InvestorAllocation", 'Decimal'>
    readonly actualReturn: FieldRef<"InvestorAllocation", 'Decimal'>
    readonly allocationDate: FieldRef<"InvestorAllocation", 'DateTime'>
    readonly createdAt: FieldRef<"InvestorAllocation", 'DateTime'>
    readonly updatedAt: FieldRef<"InvestorAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvestorAllocation findUnique
   */
  export type InvestorAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorAllocation to fetch.
     */
    where: InvestorAllocationWhereUniqueInput
  }

  /**
   * InvestorAllocation findUniqueOrThrow
   */
  export type InvestorAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorAllocation to fetch.
     */
    where: InvestorAllocationWhereUniqueInput
  }

  /**
   * InvestorAllocation findFirst
   */
  export type InvestorAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorAllocation to fetch.
     */
    where?: InvestorAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorAllocations to fetch.
     */
    orderBy?: InvestorAllocationOrderByWithRelationInput | InvestorAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorAllocations.
     */
    cursor?: InvestorAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorAllocations.
     */
    distinct?: InvestorAllocationScalarFieldEnum | InvestorAllocationScalarFieldEnum[]
  }

  /**
   * InvestorAllocation findFirstOrThrow
   */
  export type InvestorAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorAllocation to fetch.
     */
    where?: InvestorAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorAllocations to fetch.
     */
    orderBy?: InvestorAllocationOrderByWithRelationInput | InvestorAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorAllocations.
     */
    cursor?: InvestorAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorAllocations.
     */
    distinct?: InvestorAllocationScalarFieldEnum | InvestorAllocationScalarFieldEnum[]
  }

  /**
   * InvestorAllocation findMany
   */
  export type InvestorAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorAllocations to fetch.
     */
    where?: InvestorAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorAllocations to fetch.
     */
    orderBy?: InvestorAllocationOrderByWithRelationInput | InvestorAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestorAllocations.
     */
    cursor?: InvestorAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorAllocations.
     */
    skip?: number
    distinct?: InvestorAllocationScalarFieldEnum | InvestorAllocationScalarFieldEnum[]
  }

  /**
   * InvestorAllocation create
   */
  export type InvestorAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestorAllocation.
     */
    data: XOR<InvestorAllocationCreateInput, InvestorAllocationUncheckedCreateInput>
  }

  /**
   * InvestorAllocation createMany
   */
  export type InvestorAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestorAllocations.
     */
    data: InvestorAllocationCreateManyInput | InvestorAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestorAllocation createManyAndReturn
   */
  export type InvestorAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many InvestorAllocations.
     */
    data: InvestorAllocationCreateManyInput | InvestorAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorAllocation update
   */
  export type InvestorAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestorAllocation.
     */
    data: XOR<InvestorAllocationUpdateInput, InvestorAllocationUncheckedUpdateInput>
    /**
     * Choose, which InvestorAllocation to update.
     */
    where: InvestorAllocationWhereUniqueInput
  }

  /**
   * InvestorAllocation updateMany
   */
  export type InvestorAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestorAllocations.
     */
    data: XOR<InvestorAllocationUpdateManyMutationInput, InvestorAllocationUncheckedUpdateManyInput>
    /**
     * Filter which InvestorAllocations to update
     */
    where?: InvestorAllocationWhereInput
    /**
     * Limit how many InvestorAllocations to update.
     */
    limit?: number
  }

  /**
   * InvestorAllocation updateManyAndReturn
   */
  export type InvestorAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * The data used to update InvestorAllocations.
     */
    data: XOR<InvestorAllocationUpdateManyMutationInput, InvestorAllocationUncheckedUpdateManyInput>
    /**
     * Filter which InvestorAllocations to update
     */
    where?: InvestorAllocationWhereInput
    /**
     * Limit how many InvestorAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorAllocation upsert
   */
  export type InvestorAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestorAllocation to update in case it exists.
     */
    where: InvestorAllocationWhereUniqueInput
    /**
     * In case the InvestorAllocation found by the `where` argument doesn't exist, create a new InvestorAllocation with this data.
     */
    create: XOR<InvestorAllocationCreateInput, InvestorAllocationUncheckedCreateInput>
    /**
     * In case the InvestorAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorAllocationUpdateInput, InvestorAllocationUncheckedUpdateInput>
  }

  /**
   * InvestorAllocation delete
   */
  export type InvestorAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
    /**
     * Filter which InvestorAllocation to delete.
     */
    where: InvestorAllocationWhereUniqueInput
  }

  /**
   * InvestorAllocation deleteMany
   */
  export type InvestorAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorAllocations to delete
     */
    where?: InvestorAllocationWhereInput
    /**
     * Limit how many InvestorAllocations to delete.
     */
    limit?: number
  }

  /**
   * InvestorAllocation without action
   */
  export type InvestorAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorAllocation
     */
    select?: InvestorAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorAllocation
     */
    omit?: InvestorAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorAllocationInclude<ExtArgs> | null
  }


  /**
   * Model InvestorPayout
   */

  export type AggregateInvestorPayout = {
    _count: InvestorPayoutCountAggregateOutputType | null
    _avg: InvestorPayoutAvgAggregateOutputType | null
    _sum: InvestorPayoutSumAggregateOutputType | null
    _min: InvestorPayoutMinAggregateOutputType | null
    _max: InvestorPayoutMaxAggregateOutputType | null
  }

  export type InvestorPayoutAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvestorPayoutSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvestorPayoutMinAggregateOutputType = {
    id: string | null
    investorId: string | null
    amount: Decimal | null
    payoutDate: Date | null
    reference: string | null
    createdAt: Date | null
  }

  export type InvestorPayoutMaxAggregateOutputType = {
    id: string | null
    investorId: string | null
    amount: Decimal | null
    payoutDate: Date | null
    reference: string | null
    createdAt: Date | null
  }

  export type InvestorPayoutCountAggregateOutputType = {
    id: number
    investorId: number
    amount: number
    payoutDate: number
    reference: number
    createdAt: number
    _all: number
  }


  export type InvestorPayoutAvgAggregateInputType = {
    amount?: true
  }

  export type InvestorPayoutSumAggregateInputType = {
    amount?: true
  }

  export type InvestorPayoutMinAggregateInputType = {
    id?: true
    investorId?: true
    amount?: true
    payoutDate?: true
    reference?: true
    createdAt?: true
  }

  export type InvestorPayoutMaxAggregateInputType = {
    id?: true
    investorId?: true
    amount?: true
    payoutDate?: true
    reference?: true
    createdAt?: true
  }

  export type InvestorPayoutCountAggregateInputType = {
    id?: true
    investorId?: true
    amount?: true
    payoutDate?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type InvestorPayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorPayout to aggregate.
     */
    where?: InvestorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorPayouts to fetch.
     */
    orderBy?: InvestorPayoutOrderByWithRelationInput | InvestorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestorPayouts
    **/
    _count?: true | InvestorPayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorPayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorPayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorPayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorPayoutMaxAggregateInputType
  }

  export type GetInvestorPayoutAggregateType<T extends InvestorPayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestorPayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestorPayout[P]>
      : GetScalarType<T[P], AggregateInvestorPayout[P]>
  }




  export type InvestorPayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorPayoutWhereInput
    orderBy?: InvestorPayoutOrderByWithAggregationInput | InvestorPayoutOrderByWithAggregationInput[]
    by: InvestorPayoutScalarFieldEnum[] | InvestorPayoutScalarFieldEnum
    having?: InvestorPayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorPayoutCountAggregateInputType | true
    _avg?: InvestorPayoutAvgAggregateInputType
    _sum?: InvestorPayoutSumAggregateInputType
    _min?: InvestorPayoutMinAggregateInputType
    _max?: InvestorPayoutMaxAggregateInputType
  }

  export type InvestorPayoutGroupByOutputType = {
    id: string
    investorId: string
    amount: Decimal
    payoutDate: Date
    reference: string | null
    createdAt: Date
    _count: InvestorPayoutCountAggregateOutputType | null
    _avg: InvestorPayoutAvgAggregateOutputType | null
    _sum: InvestorPayoutSumAggregateOutputType | null
    _min: InvestorPayoutMinAggregateOutputType | null
    _max: InvestorPayoutMaxAggregateOutputType | null
  }

  type GetInvestorPayoutGroupByPayload<T extends InvestorPayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorPayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorPayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorPayoutGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorPayoutGroupByOutputType[P]>
        }
      >
    >


  export type InvestorPayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    amount?: boolean
    payoutDate?: boolean
    reference?: boolean
    createdAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorPayout"]>

  export type InvestorPayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    amount?: boolean
    payoutDate?: boolean
    reference?: boolean
    createdAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorPayout"]>

  export type InvestorPayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    amount?: boolean
    payoutDate?: boolean
    reference?: boolean
    createdAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorPayout"]>

  export type InvestorPayoutSelectScalar = {
    id?: boolean
    investorId?: boolean
    amount?: boolean
    payoutDate?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type InvestorPayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "investorId" | "amount" | "payoutDate" | "reference" | "createdAt", ExtArgs["result"]["investorPayout"]>
  export type InvestorPayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }
  export type InvestorPayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }
  export type InvestorPayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }

  export type $InvestorPayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestorPayout"
    objects: {
      investor: Prisma.$InvestorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investorId: string
      amount: Prisma.Decimal
      payoutDate: Date
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["investorPayout"]>
    composites: {}
  }

  type InvestorPayoutGetPayload<S extends boolean | null | undefined | InvestorPayoutDefaultArgs> = $Result.GetResult<Prisma.$InvestorPayoutPayload, S>

  type InvestorPayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorPayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorPayoutCountAggregateInputType | true
    }

  export interface InvestorPayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestorPayout'], meta: { name: 'InvestorPayout' } }
    /**
     * Find zero or one InvestorPayout that matches the filter.
     * @param {InvestorPayoutFindUniqueArgs} args - Arguments to find a InvestorPayout
     * @example
     * // Get one InvestorPayout
     * const investorPayout = await prisma.investorPayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorPayoutFindUniqueArgs>(args: SelectSubset<T, InvestorPayoutFindUniqueArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvestorPayout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorPayoutFindUniqueOrThrowArgs} args - Arguments to find a InvestorPayout
     * @example
     * // Get one InvestorPayout
     * const investorPayout = await prisma.investorPayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorPayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorPayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorPayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorPayoutFindFirstArgs} args - Arguments to find a InvestorPayout
     * @example
     * // Get one InvestorPayout
     * const investorPayout = await prisma.investorPayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorPayoutFindFirstArgs>(args?: SelectSubset<T, InvestorPayoutFindFirstArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorPayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorPayoutFindFirstOrThrowArgs} args - Arguments to find a InvestorPayout
     * @example
     * // Get one InvestorPayout
     * const investorPayout = await prisma.investorPayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorPayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorPayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvestorPayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorPayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestorPayouts
     * const investorPayouts = await prisma.investorPayout.findMany()
     * 
     * // Get first 10 InvestorPayouts
     * const investorPayouts = await prisma.investorPayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorPayoutWithIdOnly = await prisma.investorPayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorPayoutFindManyArgs>(args?: SelectSubset<T, InvestorPayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvestorPayout.
     * @param {InvestorPayoutCreateArgs} args - Arguments to create a InvestorPayout.
     * @example
     * // Create one InvestorPayout
     * const InvestorPayout = await prisma.investorPayout.create({
     *   data: {
     *     // ... data to create a InvestorPayout
     *   }
     * })
     * 
     */
    create<T extends InvestorPayoutCreateArgs>(args: SelectSubset<T, InvestorPayoutCreateArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvestorPayouts.
     * @param {InvestorPayoutCreateManyArgs} args - Arguments to create many InvestorPayouts.
     * @example
     * // Create many InvestorPayouts
     * const investorPayout = await prisma.investorPayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorPayoutCreateManyArgs>(args?: SelectSubset<T, InvestorPayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestorPayouts and returns the data saved in the database.
     * @param {InvestorPayoutCreateManyAndReturnArgs} args - Arguments to create many InvestorPayouts.
     * @example
     * // Create many InvestorPayouts
     * const investorPayout = await prisma.investorPayout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestorPayouts and only return the `id`
     * const investorPayoutWithIdOnly = await prisma.investorPayout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorPayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorPayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvestorPayout.
     * @param {InvestorPayoutDeleteArgs} args - Arguments to delete one InvestorPayout.
     * @example
     * // Delete one InvestorPayout
     * const InvestorPayout = await prisma.investorPayout.delete({
     *   where: {
     *     // ... filter to delete one InvestorPayout
     *   }
     * })
     * 
     */
    delete<T extends InvestorPayoutDeleteArgs>(args: SelectSubset<T, InvestorPayoutDeleteArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvestorPayout.
     * @param {InvestorPayoutUpdateArgs} args - Arguments to update one InvestorPayout.
     * @example
     * // Update one InvestorPayout
     * const investorPayout = await prisma.investorPayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorPayoutUpdateArgs>(args: SelectSubset<T, InvestorPayoutUpdateArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvestorPayouts.
     * @param {InvestorPayoutDeleteManyArgs} args - Arguments to filter InvestorPayouts to delete.
     * @example
     * // Delete a few InvestorPayouts
     * const { count } = await prisma.investorPayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorPayoutDeleteManyArgs>(args?: SelectSubset<T, InvestorPayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorPayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestorPayouts
     * const investorPayout = await prisma.investorPayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorPayoutUpdateManyArgs>(args: SelectSubset<T, InvestorPayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorPayouts and returns the data updated in the database.
     * @param {InvestorPayoutUpdateManyAndReturnArgs} args - Arguments to update many InvestorPayouts.
     * @example
     * // Update many InvestorPayouts
     * const investorPayout = await prisma.investorPayout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvestorPayouts and only return the `id`
     * const investorPayoutWithIdOnly = await prisma.investorPayout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestorPayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestorPayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvestorPayout.
     * @param {InvestorPayoutUpsertArgs} args - Arguments to update or create a InvestorPayout.
     * @example
     * // Update or create a InvestorPayout
     * const investorPayout = await prisma.investorPayout.upsert({
     *   create: {
     *     // ... data to create a InvestorPayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestorPayout we want to update
     *   }
     * })
     */
    upsert<T extends InvestorPayoutUpsertArgs>(args: SelectSubset<T, InvestorPayoutUpsertArgs<ExtArgs>>): Prisma__InvestorPayoutClient<$Result.GetResult<Prisma.$InvestorPayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvestorPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorPayoutCountArgs} args - Arguments to filter InvestorPayouts to count.
     * @example
     * // Count the number of InvestorPayouts
     * const count = await prisma.investorPayout.count({
     *   where: {
     *     // ... the filter for the InvestorPayouts we want to count
     *   }
     * })
    **/
    count<T extends InvestorPayoutCountArgs>(
      args?: Subset<T, InvestorPayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorPayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestorPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorPayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorPayoutAggregateArgs>(args: Subset<T, InvestorPayoutAggregateArgs>): Prisma.PrismaPromise<GetInvestorPayoutAggregateType<T>>

    /**
     * Group by InvestorPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorPayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorPayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorPayoutGroupByArgs['orderBy'] }
        : { orderBy?: InvestorPayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorPayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestorPayout model
   */
  readonly fields: InvestorPayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestorPayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorPayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestorPayout model
   */
  interface InvestorPayoutFieldRefs {
    readonly id: FieldRef<"InvestorPayout", 'String'>
    readonly investorId: FieldRef<"InvestorPayout", 'String'>
    readonly amount: FieldRef<"InvestorPayout", 'Decimal'>
    readonly payoutDate: FieldRef<"InvestorPayout", 'DateTime'>
    readonly reference: FieldRef<"InvestorPayout", 'String'>
    readonly createdAt: FieldRef<"InvestorPayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvestorPayout findUnique
   */
  export type InvestorPayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which InvestorPayout to fetch.
     */
    where: InvestorPayoutWhereUniqueInput
  }

  /**
   * InvestorPayout findUniqueOrThrow
   */
  export type InvestorPayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which InvestorPayout to fetch.
     */
    where: InvestorPayoutWhereUniqueInput
  }

  /**
   * InvestorPayout findFirst
   */
  export type InvestorPayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which InvestorPayout to fetch.
     */
    where?: InvestorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorPayouts to fetch.
     */
    orderBy?: InvestorPayoutOrderByWithRelationInput | InvestorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorPayouts.
     */
    cursor?: InvestorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorPayouts.
     */
    distinct?: InvestorPayoutScalarFieldEnum | InvestorPayoutScalarFieldEnum[]
  }

  /**
   * InvestorPayout findFirstOrThrow
   */
  export type InvestorPayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which InvestorPayout to fetch.
     */
    where?: InvestorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorPayouts to fetch.
     */
    orderBy?: InvestorPayoutOrderByWithRelationInput | InvestorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorPayouts.
     */
    cursor?: InvestorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorPayouts.
     */
    distinct?: InvestorPayoutScalarFieldEnum | InvestorPayoutScalarFieldEnum[]
  }

  /**
   * InvestorPayout findMany
   */
  export type InvestorPayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * Filter, which InvestorPayouts to fetch.
     */
    where?: InvestorPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorPayouts to fetch.
     */
    orderBy?: InvestorPayoutOrderByWithRelationInput | InvestorPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestorPayouts.
     */
    cursor?: InvestorPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorPayouts.
     */
    skip?: number
    distinct?: InvestorPayoutScalarFieldEnum | InvestorPayoutScalarFieldEnum[]
  }

  /**
   * InvestorPayout create
   */
  export type InvestorPayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestorPayout.
     */
    data: XOR<InvestorPayoutCreateInput, InvestorPayoutUncheckedCreateInput>
  }

  /**
   * InvestorPayout createMany
   */
  export type InvestorPayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestorPayouts.
     */
    data: InvestorPayoutCreateManyInput | InvestorPayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestorPayout createManyAndReturn
   */
  export type InvestorPayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * The data used to create many InvestorPayouts.
     */
    data: InvestorPayoutCreateManyInput | InvestorPayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorPayout update
   */
  export type InvestorPayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestorPayout.
     */
    data: XOR<InvestorPayoutUpdateInput, InvestorPayoutUncheckedUpdateInput>
    /**
     * Choose, which InvestorPayout to update.
     */
    where: InvestorPayoutWhereUniqueInput
  }

  /**
   * InvestorPayout updateMany
   */
  export type InvestorPayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestorPayouts.
     */
    data: XOR<InvestorPayoutUpdateManyMutationInput, InvestorPayoutUncheckedUpdateManyInput>
    /**
     * Filter which InvestorPayouts to update
     */
    where?: InvestorPayoutWhereInput
    /**
     * Limit how many InvestorPayouts to update.
     */
    limit?: number
  }

  /**
   * InvestorPayout updateManyAndReturn
   */
  export type InvestorPayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * The data used to update InvestorPayouts.
     */
    data: XOR<InvestorPayoutUpdateManyMutationInput, InvestorPayoutUncheckedUpdateManyInput>
    /**
     * Filter which InvestorPayouts to update
     */
    where?: InvestorPayoutWhereInput
    /**
     * Limit how many InvestorPayouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorPayout upsert
   */
  export type InvestorPayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestorPayout to update in case it exists.
     */
    where: InvestorPayoutWhereUniqueInput
    /**
     * In case the InvestorPayout found by the `where` argument doesn't exist, create a new InvestorPayout with this data.
     */
    create: XOR<InvestorPayoutCreateInput, InvestorPayoutUncheckedCreateInput>
    /**
     * In case the InvestorPayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorPayoutUpdateInput, InvestorPayoutUncheckedUpdateInput>
  }

  /**
   * InvestorPayout delete
   */
  export type InvestorPayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
    /**
     * Filter which InvestorPayout to delete.
     */
    where: InvestorPayoutWhereUniqueInput
  }

  /**
   * InvestorPayout deleteMany
   */
  export type InvestorPayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorPayouts to delete
     */
    where?: InvestorPayoutWhereInput
    /**
     * Limit how many InvestorPayouts to delete.
     */
    limit?: number
  }

  /**
   * InvestorPayout without action
   */
  export type InvestorPayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorPayout
     */
    select?: InvestorPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorPayout
     */
    omit?: InvestorPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorPayoutInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    loanId: string | null
    documentType: $Enums.DocumentType | null
    filePublicId: string | null
    fileUniqueId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    loanId: string | null
    documentType: $Enums.DocumentType | null
    filePublicId: string | null
    fileUniqueId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    clientId: number
    loanId: number
    documentType: number
    filePublicId: number
    fileUniqueId: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    uploadedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    clientId?: true
    loanId?: true
    documentType?: true
    filePublicId?: true
    fileUniqueId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    clientId?: true
    loanId?: true
    documentType?: true
    filePublicId?: true
    fileUniqueId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    clientId?: true
    loanId?: true
    documentType?: true
    filePublicId?: true
    fileUniqueId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    clientId: string | null
    loanId: string | null
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    loanId?: boolean
    documentType?: boolean
    filePublicId?: boolean
    fileUniqueId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    client?: boolean | Document$clientArgs<ExtArgs>
    loan?: boolean | Document$loanArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    loanId?: boolean
    documentType?: boolean
    filePublicId?: boolean
    fileUniqueId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    client?: boolean | Document$clientArgs<ExtArgs>
    loan?: boolean | Document$loanArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    loanId?: boolean
    documentType?: boolean
    filePublicId?: boolean
    fileUniqueId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    client?: boolean | Document$clientArgs<ExtArgs>
    loan?: boolean | Document$loanArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    clientId?: boolean
    loanId?: boolean
    documentType?: boolean
    filePublicId?: boolean
    fileUniqueId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "loanId" | "documentType" | "filePublicId" | "fileUniqueId" | "fileName" | "filePath" | "fileSize" | "mimeType" | "uploadedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Document$clientArgs<ExtArgs>
    loan?: boolean | Document$loanArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Document$clientArgs<ExtArgs>
    loan?: boolean | Document$loanArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Document$clientArgs<ExtArgs>
    loan?: boolean | Document$loanArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      loan: Prisma.$LoanApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string | null
      loanId: string | null
      documentType: $Enums.DocumentType
      filePublicId: string
      fileUniqueId: string
      fileName: string
      filePath: string
      fileSize: number | null
      mimeType: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Document$clientArgs<ExtArgs> = {}>(args?: Subset<T, Document$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    loan<T extends Document$loanArgs<ExtArgs> = {}>(args?: Subset<T, Document$loanArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly clientId: FieldRef<"Document", 'String'>
    readonly loanId: FieldRef<"Document", 'String'>
    readonly documentType: FieldRef<"Document", 'DocumentType'>
    readonly filePublicId: FieldRef<"Document", 'String'>
    readonly fileUniqueId: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly filePath: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.client
   */
  export type Document$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Document.loan
   */
  export type Document$loanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    expenseType: $Enums.ExpenseType | null
    amount: Decimal | null
    description: string | null
    incurredAt: Date | null
    createdAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    expenseType: $Enums.ExpenseType | null
    amount: Decimal | null
    description: string | null
    incurredAt: Date | null
    createdAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    expenseType: number
    amount: number
    description: number
    incurredAt: number
    createdAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    expenseType?: true
    amount?: true
    description?: true
    incurredAt?: true
    createdAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    expenseType?: true
    amount?: true
    description?: true
    incurredAt?: true
    createdAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    expenseType?: true
    amount?: true
    description?: true
    incurredAt?: true
    createdAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    expenseType: $Enums.ExpenseType
    amount: Decimal
    description: string | null
    incurredAt: Date
    createdAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseType?: boolean
    amount?: boolean
    description?: boolean
    incurredAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseType?: boolean
    amount?: boolean
    description?: boolean
    incurredAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseType?: boolean
    amount?: boolean
    description?: boolean
    incurredAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    expenseType?: boolean
    amount?: boolean
    description?: boolean
    incurredAt?: boolean
    createdAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expenseType" | "amount" | "description" | "incurredAt" | "createdAt", ExtArgs["result"]["expense"]>

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseType: $Enums.ExpenseType
      amount: Prisma.Decimal
      description: string | null
      incurredAt: Date
      createdAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly expenseType: FieldRef<"Expense", 'ExpenseType'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly incurredAt: FieldRef<"Expense", 'DateTime'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
  }


  /**
   * Model SmsLog
   */

  export type AggregateSmsLog = {
    _count: SmsLogCountAggregateOutputType | null
    _avg: SmsLogAvgAggregateOutputType | null
    _sum: SmsLogSumAggregateOutputType | null
    _min: SmsLogMinAggregateOutputType | null
    _max: SmsLogMaxAggregateOutputType | null
  }

  export type SmsLogAvgAggregateOutputType = {
    cost: Decimal | null
  }

  export type SmsLogSumAggregateOutputType = {
    cost: Decimal | null
  }

  export type SmsLogMinAggregateOutputType = {
    id: string | null
    recipient: string | null
    message: string | null
    purpose: $Enums.SmsPurpose | null
    cost: Decimal | null
    sentAt: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type SmsLogMaxAggregateOutputType = {
    id: string | null
    recipient: string | null
    message: string | null
    purpose: $Enums.SmsPurpose | null
    cost: Decimal | null
    sentAt: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type SmsLogCountAggregateOutputType = {
    id: number
    recipient: number
    message: number
    purpose: number
    cost: number
    sentAt: number
    status: number
    createdAt: number
    _all: number
  }


  export type SmsLogAvgAggregateInputType = {
    cost?: true
  }

  export type SmsLogSumAggregateInputType = {
    cost?: true
  }

  export type SmsLogMinAggregateInputType = {
    id?: true
    recipient?: true
    message?: true
    purpose?: true
    cost?: true
    sentAt?: true
    status?: true
    createdAt?: true
  }

  export type SmsLogMaxAggregateInputType = {
    id?: true
    recipient?: true
    message?: true
    purpose?: true
    cost?: true
    sentAt?: true
    status?: true
    createdAt?: true
  }

  export type SmsLogCountAggregateInputType = {
    id?: true
    recipient?: true
    message?: true
    purpose?: true
    cost?: true
    sentAt?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type SmsLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmsLog to aggregate.
     */
    where?: SmsLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsLogs to fetch.
     */
    orderBy?: SmsLogOrderByWithRelationInput | SmsLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SmsLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmsLogs
    **/
    _count?: true | SmsLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SmsLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SmsLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmsLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmsLogMaxAggregateInputType
  }

  export type GetSmsLogAggregateType<T extends SmsLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSmsLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmsLog[P]>
      : GetScalarType<T[P], AggregateSmsLog[P]>
  }




  export type SmsLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmsLogWhereInput
    orderBy?: SmsLogOrderByWithAggregationInput | SmsLogOrderByWithAggregationInput[]
    by: SmsLogScalarFieldEnum[] | SmsLogScalarFieldEnum
    having?: SmsLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmsLogCountAggregateInputType | true
    _avg?: SmsLogAvgAggregateInputType
    _sum?: SmsLogSumAggregateInputType
    _min?: SmsLogMinAggregateInputType
    _max?: SmsLogMaxAggregateInputType
  }

  export type SmsLogGroupByOutputType = {
    id: string
    recipient: string
    message: string
    purpose: $Enums.SmsPurpose
    cost: Decimal | null
    sentAt: Date
    status: string | null
    createdAt: Date
    _count: SmsLogCountAggregateOutputType | null
    _avg: SmsLogAvgAggregateOutputType | null
    _sum: SmsLogSumAggregateOutputType | null
    _min: SmsLogMinAggregateOutputType | null
    _max: SmsLogMaxAggregateOutputType | null
  }

  type GetSmsLogGroupByPayload<T extends SmsLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SmsLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmsLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmsLogGroupByOutputType[P]>
            : GetScalarType<T[P], SmsLogGroupByOutputType[P]>
        }
      >
    >


  export type SmsLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient?: boolean
    message?: boolean
    purpose?: boolean
    cost?: boolean
    sentAt?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["smsLog"]>

  export type SmsLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient?: boolean
    message?: boolean
    purpose?: boolean
    cost?: boolean
    sentAt?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["smsLog"]>

  export type SmsLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient?: boolean
    message?: boolean
    purpose?: boolean
    cost?: boolean
    sentAt?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["smsLog"]>

  export type SmsLogSelectScalar = {
    id?: boolean
    recipient?: boolean
    message?: boolean
    purpose?: boolean
    cost?: boolean
    sentAt?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type SmsLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipient" | "message" | "purpose" | "cost" | "sentAt" | "status" | "createdAt", ExtArgs["result"]["smsLog"]>

  export type $SmsLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SmsLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipient: string
      message: string
      purpose: $Enums.SmsPurpose
      cost: Prisma.Decimal | null
      sentAt: Date
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["smsLog"]>
    composites: {}
  }

  type SmsLogGetPayload<S extends boolean | null | undefined | SmsLogDefaultArgs> = $Result.GetResult<Prisma.$SmsLogPayload, S>

  type SmsLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SmsLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SmsLogCountAggregateInputType | true
    }

  export interface SmsLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SmsLog'], meta: { name: 'SmsLog' } }
    /**
     * Find zero or one SmsLog that matches the filter.
     * @param {SmsLogFindUniqueArgs} args - Arguments to find a SmsLog
     * @example
     * // Get one SmsLog
     * const smsLog = await prisma.smsLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SmsLogFindUniqueArgs>(args: SelectSubset<T, SmsLogFindUniqueArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SmsLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SmsLogFindUniqueOrThrowArgs} args - Arguments to find a SmsLog
     * @example
     * // Get one SmsLog
     * const smsLog = await prisma.smsLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SmsLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SmsLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmsLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsLogFindFirstArgs} args - Arguments to find a SmsLog
     * @example
     * // Get one SmsLog
     * const smsLog = await prisma.smsLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SmsLogFindFirstArgs>(args?: SelectSubset<T, SmsLogFindFirstArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmsLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsLogFindFirstOrThrowArgs} args - Arguments to find a SmsLog
     * @example
     * // Get one SmsLog
     * const smsLog = await prisma.smsLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SmsLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SmsLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SmsLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmsLogs
     * const smsLogs = await prisma.smsLog.findMany()
     * 
     * // Get first 10 SmsLogs
     * const smsLogs = await prisma.smsLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smsLogWithIdOnly = await prisma.smsLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SmsLogFindManyArgs>(args?: SelectSubset<T, SmsLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SmsLog.
     * @param {SmsLogCreateArgs} args - Arguments to create a SmsLog.
     * @example
     * // Create one SmsLog
     * const SmsLog = await prisma.smsLog.create({
     *   data: {
     *     // ... data to create a SmsLog
     *   }
     * })
     * 
     */
    create<T extends SmsLogCreateArgs>(args: SelectSubset<T, SmsLogCreateArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SmsLogs.
     * @param {SmsLogCreateManyArgs} args - Arguments to create many SmsLogs.
     * @example
     * // Create many SmsLogs
     * const smsLog = await prisma.smsLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SmsLogCreateManyArgs>(args?: SelectSubset<T, SmsLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SmsLogs and returns the data saved in the database.
     * @param {SmsLogCreateManyAndReturnArgs} args - Arguments to create many SmsLogs.
     * @example
     * // Create many SmsLogs
     * const smsLog = await prisma.smsLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SmsLogs and only return the `id`
     * const smsLogWithIdOnly = await prisma.smsLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SmsLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SmsLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SmsLog.
     * @param {SmsLogDeleteArgs} args - Arguments to delete one SmsLog.
     * @example
     * // Delete one SmsLog
     * const SmsLog = await prisma.smsLog.delete({
     *   where: {
     *     // ... filter to delete one SmsLog
     *   }
     * })
     * 
     */
    delete<T extends SmsLogDeleteArgs>(args: SelectSubset<T, SmsLogDeleteArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SmsLog.
     * @param {SmsLogUpdateArgs} args - Arguments to update one SmsLog.
     * @example
     * // Update one SmsLog
     * const smsLog = await prisma.smsLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SmsLogUpdateArgs>(args: SelectSubset<T, SmsLogUpdateArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SmsLogs.
     * @param {SmsLogDeleteManyArgs} args - Arguments to filter SmsLogs to delete.
     * @example
     * // Delete a few SmsLogs
     * const { count } = await prisma.smsLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SmsLogDeleteManyArgs>(args?: SelectSubset<T, SmsLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmsLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmsLogs
     * const smsLog = await prisma.smsLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SmsLogUpdateManyArgs>(args: SelectSubset<T, SmsLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmsLogs and returns the data updated in the database.
     * @param {SmsLogUpdateManyAndReturnArgs} args - Arguments to update many SmsLogs.
     * @example
     * // Update many SmsLogs
     * const smsLog = await prisma.smsLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SmsLogs and only return the `id`
     * const smsLogWithIdOnly = await prisma.smsLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SmsLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SmsLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SmsLog.
     * @param {SmsLogUpsertArgs} args - Arguments to update or create a SmsLog.
     * @example
     * // Update or create a SmsLog
     * const smsLog = await prisma.smsLog.upsert({
     *   create: {
     *     // ... data to create a SmsLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmsLog we want to update
     *   }
     * })
     */
    upsert<T extends SmsLogUpsertArgs>(args: SelectSubset<T, SmsLogUpsertArgs<ExtArgs>>): Prisma__SmsLogClient<$Result.GetResult<Prisma.$SmsLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SmsLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsLogCountArgs} args - Arguments to filter SmsLogs to count.
     * @example
     * // Count the number of SmsLogs
     * const count = await prisma.smsLog.count({
     *   where: {
     *     // ... the filter for the SmsLogs we want to count
     *   }
     * })
    **/
    count<T extends SmsLogCountArgs>(
      args?: Subset<T, SmsLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmsLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmsLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmsLogAggregateArgs>(args: Subset<T, SmsLogAggregateArgs>): Prisma.PrismaPromise<GetSmsLogAggregateType<T>>

    /**
     * Group by SmsLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmsLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmsLogGroupByArgs['orderBy'] }
        : { orderBy?: SmsLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmsLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmsLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SmsLog model
   */
  readonly fields: SmsLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SmsLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SmsLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SmsLog model
   */
  interface SmsLogFieldRefs {
    readonly id: FieldRef<"SmsLog", 'String'>
    readonly recipient: FieldRef<"SmsLog", 'String'>
    readonly message: FieldRef<"SmsLog", 'String'>
    readonly purpose: FieldRef<"SmsLog", 'SmsPurpose'>
    readonly cost: FieldRef<"SmsLog", 'Decimal'>
    readonly sentAt: FieldRef<"SmsLog", 'DateTime'>
    readonly status: FieldRef<"SmsLog", 'String'>
    readonly createdAt: FieldRef<"SmsLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SmsLog findUnique
   */
  export type SmsLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * Filter, which SmsLog to fetch.
     */
    where: SmsLogWhereUniqueInput
  }

  /**
   * SmsLog findUniqueOrThrow
   */
  export type SmsLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * Filter, which SmsLog to fetch.
     */
    where: SmsLogWhereUniqueInput
  }

  /**
   * SmsLog findFirst
   */
  export type SmsLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * Filter, which SmsLog to fetch.
     */
    where?: SmsLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsLogs to fetch.
     */
    orderBy?: SmsLogOrderByWithRelationInput | SmsLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmsLogs.
     */
    cursor?: SmsLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmsLogs.
     */
    distinct?: SmsLogScalarFieldEnum | SmsLogScalarFieldEnum[]
  }

  /**
   * SmsLog findFirstOrThrow
   */
  export type SmsLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * Filter, which SmsLog to fetch.
     */
    where?: SmsLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsLogs to fetch.
     */
    orderBy?: SmsLogOrderByWithRelationInput | SmsLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmsLogs.
     */
    cursor?: SmsLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmsLogs.
     */
    distinct?: SmsLogScalarFieldEnum | SmsLogScalarFieldEnum[]
  }

  /**
   * SmsLog findMany
   */
  export type SmsLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * Filter, which SmsLogs to fetch.
     */
    where?: SmsLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsLogs to fetch.
     */
    orderBy?: SmsLogOrderByWithRelationInput | SmsLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmsLogs.
     */
    cursor?: SmsLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsLogs.
     */
    skip?: number
    distinct?: SmsLogScalarFieldEnum | SmsLogScalarFieldEnum[]
  }

  /**
   * SmsLog create
   */
  export type SmsLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SmsLog.
     */
    data: XOR<SmsLogCreateInput, SmsLogUncheckedCreateInput>
  }

  /**
   * SmsLog createMany
   */
  export type SmsLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SmsLogs.
     */
    data: SmsLogCreateManyInput | SmsLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmsLog createManyAndReturn
   */
  export type SmsLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * The data used to create many SmsLogs.
     */
    data: SmsLogCreateManyInput | SmsLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmsLog update
   */
  export type SmsLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SmsLog.
     */
    data: XOR<SmsLogUpdateInput, SmsLogUncheckedUpdateInput>
    /**
     * Choose, which SmsLog to update.
     */
    where: SmsLogWhereUniqueInput
  }

  /**
   * SmsLog updateMany
   */
  export type SmsLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SmsLogs.
     */
    data: XOR<SmsLogUpdateManyMutationInput, SmsLogUncheckedUpdateManyInput>
    /**
     * Filter which SmsLogs to update
     */
    where?: SmsLogWhereInput
    /**
     * Limit how many SmsLogs to update.
     */
    limit?: number
  }

  /**
   * SmsLog updateManyAndReturn
   */
  export type SmsLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * The data used to update SmsLogs.
     */
    data: XOR<SmsLogUpdateManyMutationInput, SmsLogUncheckedUpdateManyInput>
    /**
     * Filter which SmsLogs to update
     */
    where?: SmsLogWhereInput
    /**
     * Limit how many SmsLogs to update.
     */
    limit?: number
  }

  /**
   * SmsLog upsert
   */
  export type SmsLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SmsLog to update in case it exists.
     */
    where: SmsLogWhereUniqueInput
    /**
     * In case the SmsLog found by the `where` argument doesn't exist, create a new SmsLog with this data.
     */
    create: XOR<SmsLogCreateInput, SmsLogUncheckedCreateInput>
    /**
     * In case the SmsLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmsLogUpdateInput, SmsLogUncheckedUpdateInput>
  }

  /**
   * SmsLog delete
   */
  export type SmsLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
    /**
     * Filter which SmsLog to delete.
     */
    where: SmsLogWhereUniqueInput
  }

  /**
   * SmsLog deleteMany
   */
  export type SmsLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmsLogs to delete
     */
    where?: SmsLogWhereInput
    /**
     * Limit how many SmsLogs to delete.
     */
    limit?: number
  }

  /**
   * SmsLog without action
   */
  export type SmsLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmsLog
     */
    select?: SmsLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmsLog
     */
    omit?: SmsLogOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    oldValue: number
    newValue: number
    ipAddress: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entity: string
    entityId: string | null
    oldValue: JsonValue | null
    newValue: JsonValue | null
    ipAddress: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "oldValue" | "newValue" | "ipAddress" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entity: string
      entityId: string | null
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      ipAddress: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'Json'>
    readonly newValue: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ChartOfAccount
   */

  export type AggregateChartOfAccount = {
    _count: ChartOfAccountCountAggregateOutputType | null
    _min: ChartOfAccountMinAggregateOutputType | null
    _max: ChartOfAccountMaxAggregateOutputType | null
  }

  export type ChartOfAccountMinAggregateOutputType = {
    id: string | null
    accountCode: string | null
    accountName: string | null
    accountType: $Enums.AccountType | null
    parentAccountId: string | null
    normalBalance: $Enums.NormalBalance | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChartOfAccountMaxAggregateOutputType = {
    id: string | null
    accountCode: string | null
    accountName: string | null
    accountType: $Enums.AccountType | null
    parentAccountId: string | null
    normalBalance: $Enums.NormalBalance | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChartOfAccountCountAggregateOutputType = {
    id: number
    accountCode: number
    accountName: number
    accountType: number
    parentAccountId: number
    normalBalance: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChartOfAccountMinAggregateInputType = {
    id?: true
    accountCode?: true
    accountName?: true
    accountType?: true
    parentAccountId?: true
    normalBalance?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChartOfAccountMaxAggregateInputType = {
    id?: true
    accountCode?: true
    accountName?: true
    accountType?: true
    parentAccountId?: true
    normalBalance?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChartOfAccountCountAggregateInputType = {
    id?: true
    accountCode?: true
    accountName?: true
    accountType?: true
    parentAccountId?: true
    normalBalance?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChartOfAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartOfAccount to aggregate.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartOfAccounts
    **/
    _count?: true | ChartOfAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartOfAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartOfAccountMaxAggregateInputType
  }

  export type GetChartOfAccountAggregateType<T extends ChartOfAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateChartOfAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartOfAccount[P]>
      : GetScalarType<T[P], AggregateChartOfAccount[P]>
  }




  export type ChartOfAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartOfAccountWhereInput
    orderBy?: ChartOfAccountOrderByWithAggregationInput | ChartOfAccountOrderByWithAggregationInput[]
    by: ChartOfAccountScalarFieldEnum[] | ChartOfAccountScalarFieldEnum
    having?: ChartOfAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartOfAccountCountAggregateInputType | true
    _min?: ChartOfAccountMinAggregateInputType
    _max?: ChartOfAccountMaxAggregateInputType
  }

  export type ChartOfAccountGroupByOutputType = {
    id: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    parentAccountId: string | null
    normalBalance: $Enums.NormalBalance
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChartOfAccountCountAggregateOutputType | null
    _min: ChartOfAccountMinAggregateOutputType | null
    _max: ChartOfAccountMaxAggregateOutputType | null
  }

  type GetChartOfAccountGroupByPayload<T extends ChartOfAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartOfAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartOfAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartOfAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ChartOfAccountGroupByOutputType[P]>
        }
      >
    >


  export type ChartOfAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountCode?: boolean
    accountName?: boolean
    accountType?: boolean
    parentAccountId?: boolean
    normalBalance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentAccount?: boolean | ChartOfAccount$parentAccountArgs<ExtArgs>
    childAccounts?: boolean | ChartOfAccount$childAccountsArgs<ExtArgs>
    _count?: boolean | ChartOfAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartOfAccount"]>

  export type ChartOfAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountCode?: boolean
    accountName?: boolean
    accountType?: boolean
    parentAccountId?: boolean
    normalBalance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentAccount?: boolean | ChartOfAccount$parentAccountArgs<ExtArgs>
  }, ExtArgs["result"]["chartOfAccount"]>

  export type ChartOfAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountCode?: boolean
    accountName?: boolean
    accountType?: boolean
    parentAccountId?: boolean
    normalBalance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentAccount?: boolean | ChartOfAccount$parentAccountArgs<ExtArgs>
  }, ExtArgs["result"]["chartOfAccount"]>

  export type ChartOfAccountSelectScalar = {
    id?: boolean
    accountCode?: boolean
    accountName?: boolean
    accountType?: boolean
    parentAccountId?: boolean
    normalBalance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChartOfAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountCode" | "accountName" | "accountType" | "parentAccountId" | "normalBalance" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["chartOfAccount"]>
  export type ChartOfAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentAccount?: boolean | ChartOfAccount$parentAccountArgs<ExtArgs>
    childAccounts?: boolean | ChartOfAccount$childAccountsArgs<ExtArgs>
    _count?: boolean | ChartOfAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChartOfAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentAccount?: boolean | ChartOfAccount$parentAccountArgs<ExtArgs>
  }
  export type ChartOfAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentAccount?: boolean | ChartOfAccount$parentAccountArgs<ExtArgs>
  }

  export type $ChartOfAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartOfAccount"
    objects: {
      parentAccount: Prisma.$ChartOfAccountPayload<ExtArgs> | null
      childAccounts: Prisma.$ChartOfAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountCode: string
      accountName: string
      accountType: $Enums.AccountType
      parentAccountId: string | null
      normalBalance: $Enums.NormalBalance
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chartOfAccount"]>
    composites: {}
  }

  type ChartOfAccountGetPayload<S extends boolean | null | undefined | ChartOfAccountDefaultArgs> = $Result.GetResult<Prisma.$ChartOfAccountPayload, S>

  type ChartOfAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChartOfAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChartOfAccountCountAggregateInputType | true
    }

  export interface ChartOfAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartOfAccount'], meta: { name: 'ChartOfAccount' } }
    /**
     * Find zero or one ChartOfAccount that matches the filter.
     * @param {ChartOfAccountFindUniqueArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartOfAccountFindUniqueArgs>(args: SelectSubset<T, ChartOfAccountFindUniqueArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChartOfAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChartOfAccountFindUniqueOrThrowArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartOfAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartOfAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChartOfAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountFindFirstArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartOfAccountFindFirstArgs>(args?: SelectSubset<T, ChartOfAccountFindFirstArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChartOfAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountFindFirstOrThrowArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartOfAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartOfAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChartOfAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartOfAccounts
     * const chartOfAccounts = await prisma.chartOfAccount.findMany()
     * 
     * // Get first 10 ChartOfAccounts
     * const chartOfAccounts = await prisma.chartOfAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartOfAccountWithIdOnly = await prisma.chartOfAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartOfAccountFindManyArgs>(args?: SelectSubset<T, ChartOfAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChartOfAccount.
     * @param {ChartOfAccountCreateArgs} args - Arguments to create a ChartOfAccount.
     * @example
     * // Create one ChartOfAccount
     * const ChartOfAccount = await prisma.chartOfAccount.create({
     *   data: {
     *     // ... data to create a ChartOfAccount
     *   }
     * })
     * 
     */
    create<T extends ChartOfAccountCreateArgs>(args: SelectSubset<T, ChartOfAccountCreateArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChartOfAccounts.
     * @param {ChartOfAccountCreateManyArgs} args - Arguments to create many ChartOfAccounts.
     * @example
     * // Create many ChartOfAccounts
     * const chartOfAccount = await prisma.chartOfAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartOfAccountCreateManyArgs>(args?: SelectSubset<T, ChartOfAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartOfAccounts and returns the data saved in the database.
     * @param {ChartOfAccountCreateManyAndReturnArgs} args - Arguments to create many ChartOfAccounts.
     * @example
     * // Create many ChartOfAccounts
     * const chartOfAccount = await prisma.chartOfAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartOfAccounts and only return the `id`
     * const chartOfAccountWithIdOnly = await prisma.chartOfAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartOfAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartOfAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChartOfAccount.
     * @param {ChartOfAccountDeleteArgs} args - Arguments to delete one ChartOfAccount.
     * @example
     * // Delete one ChartOfAccount
     * const ChartOfAccount = await prisma.chartOfAccount.delete({
     *   where: {
     *     // ... filter to delete one ChartOfAccount
     *   }
     * })
     * 
     */
    delete<T extends ChartOfAccountDeleteArgs>(args: SelectSubset<T, ChartOfAccountDeleteArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChartOfAccount.
     * @param {ChartOfAccountUpdateArgs} args - Arguments to update one ChartOfAccount.
     * @example
     * // Update one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartOfAccountUpdateArgs>(args: SelectSubset<T, ChartOfAccountUpdateArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChartOfAccounts.
     * @param {ChartOfAccountDeleteManyArgs} args - Arguments to filter ChartOfAccounts to delete.
     * @example
     * // Delete a few ChartOfAccounts
     * const { count } = await prisma.chartOfAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartOfAccountDeleteManyArgs>(args?: SelectSubset<T, ChartOfAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartOfAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartOfAccounts
     * const chartOfAccount = await prisma.chartOfAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartOfAccountUpdateManyArgs>(args: SelectSubset<T, ChartOfAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartOfAccounts and returns the data updated in the database.
     * @param {ChartOfAccountUpdateManyAndReturnArgs} args - Arguments to update many ChartOfAccounts.
     * @example
     * // Update many ChartOfAccounts
     * const chartOfAccount = await prisma.chartOfAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChartOfAccounts and only return the `id`
     * const chartOfAccountWithIdOnly = await prisma.chartOfAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChartOfAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, ChartOfAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChartOfAccount.
     * @param {ChartOfAccountUpsertArgs} args - Arguments to update or create a ChartOfAccount.
     * @example
     * // Update or create a ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.upsert({
     *   create: {
     *     // ... data to create a ChartOfAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartOfAccount we want to update
     *   }
     * })
     */
    upsert<T extends ChartOfAccountUpsertArgs>(args: SelectSubset<T, ChartOfAccountUpsertArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChartOfAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountCountArgs} args - Arguments to filter ChartOfAccounts to count.
     * @example
     * // Count the number of ChartOfAccounts
     * const count = await prisma.chartOfAccount.count({
     *   where: {
     *     // ... the filter for the ChartOfAccounts we want to count
     *   }
     * })
    **/
    count<T extends ChartOfAccountCountArgs>(
      args?: Subset<T, ChartOfAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartOfAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartOfAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartOfAccountAggregateArgs>(args: Subset<T, ChartOfAccountAggregateArgs>): Prisma.PrismaPromise<GetChartOfAccountAggregateType<T>>

    /**
     * Group by ChartOfAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartOfAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartOfAccountGroupByArgs['orderBy'] }
        : { orderBy?: ChartOfAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartOfAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartOfAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartOfAccount model
   */
  readonly fields: ChartOfAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartOfAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartOfAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentAccount<T extends ChartOfAccount$parentAccountArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$parentAccountArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childAccounts<T extends ChartOfAccount$childAccountsArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$childAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartOfAccount model
   */
  interface ChartOfAccountFieldRefs {
    readonly id: FieldRef<"ChartOfAccount", 'String'>
    readonly accountCode: FieldRef<"ChartOfAccount", 'String'>
    readonly accountName: FieldRef<"ChartOfAccount", 'String'>
    readonly accountType: FieldRef<"ChartOfAccount", 'AccountType'>
    readonly parentAccountId: FieldRef<"ChartOfAccount", 'String'>
    readonly normalBalance: FieldRef<"ChartOfAccount", 'NormalBalance'>
    readonly isActive: FieldRef<"ChartOfAccount", 'Boolean'>
    readonly createdAt: FieldRef<"ChartOfAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"ChartOfAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChartOfAccount findUnique
   */
  export type ChartOfAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount findUniqueOrThrow
   */
  export type ChartOfAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount findFirst
   */
  export type ChartOfAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartOfAccounts.
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartOfAccounts.
     */
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount findFirstOrThrow
   */
  export type ChartOfAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartOfAccounts.
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartOfAccounts.
     */
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount findMany
   */
  export type ChartOfAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccounts to fetch.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartOfAccounts.
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount create
   */
  export type ChartOfAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartOfAccount.
     */
    data: XOR<ChartOfAccountCreateInput, ChartOfAccountUncheckedCreateInput>
  }

  /**
   * ChartOfAccount createMany
   */
  export type ChartOfAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartOfAccounts.
     */
    data: ChartOfAccountCreateManyInput | ChartOfAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartOfAccount createManyAndReturn
   */
  export type ChartOfAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * The data used to create many ChartOfAccounts.
     */
    data: ChartOfAccountCreateManyInput | ChartOfAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartOfAccount update
   */
  export type ChartOfAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartOfAccount.
     */
    data: XOR<ChartOfAccountUpdateInput, ChartOfAccountUncheckedUpdateInput>
    /**
     * Choose, which ChartOfAccount to update.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount updateMany
   */
  export type ChartOfAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartOfAccounts.
     */
    data: XOR<ChartOfAccountUpdateManyMutationInput, ChartOfAccountUncheckedUpdateManyInput>
    /**
     * Filter which ChartOfAccounts to update
     */
    where?: ChartOfAccountWhereInput
    /**
     * Limit how many ChartOfAccounts to update.
     */
    limit?: number
  }

  /**
   * ChartOfAccount updateManyAndReturn
   */
  export type ChartOfAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * The data used to update ChartOfAccounts.
     */
    data: XOR<ChartOfAccountUpdateManyMutationInput, ChartOfAccountUncheckedUpdateManyInput>
    /**
     * Filter which ChartOfAccounts to update
     */
    where?: ChartOfAccountWhereInput
    /**
     * Limit how many ChartOfAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartOfAccount upsert
   */
  export type ChartOfAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartOfAccount to update in case it exists.
     */
    where: ChartOfAccountWhereUniqueInput
    /**
     * In case the ChartOfAccount found by the `where` argument doesn't exist, create a new ChartOfAccount with this data.
     */
    create: XOR<ChartOfAccountCreateInput, ChartOfAccountUncheckedCreateInput>
    /**
     * In case the ChartOfAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartOfAccountUpdateInput, ChartOfAccountUncheckedUpdateInput>
  }

  /**
   * ChartOfAccount delete
   */
  export type ChartOfAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter which ChartOfAccount to delete.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount deleteMany
   */
  export type ChartOfAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartOfAccounts to delete
     */
    where?: ChartOfAccountWhereInput
    /**
     * Limit how many ChartOfAccounts to delete.
     */
    limit?: number
  }

  /**
   * ChartOfAccount.parentAccount
   */
  export type ChartOfAccount$parentAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    where?: ChartOfAccountWhereInput
  }

  /**
   * ChartOfAccount.childAccounts
   */
  export type ChartOfAccount$childAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    where?: ChartOfAccountWhereInput
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    cursor?: ChartOfAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount without action
   */
  export type ChartOfAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartOfAccount
     */
    omit?: ChartOfAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
  }


  /**
   * Model TransactionMatrix
   */

  export type AggregateTransactionMatrix = {
    _count: TransactionMatrixCountAggregateOutputType | null
    _min: TransactionMatrixMinAggregateOutputType | null
    _max: TransactionMatrixMaxAggregateOutputType | null
  }

  export type TransactionMatrixMinAggregateOutputType = {
    id: string | null
    transactionType: $Enums.TransactionType | null
    component: $Enums.ChargeType | null
    debitAccountCode: string | null
    creditAccountCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMatrixMaxAggregateOutputType = {
    id: string | null
    transactionType: $Enums.TransactionType | null
    component: $Enums.ChargeType | null
    debitAccountCode: string | null
    creditAccountCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMatrixCountAggregateOutputType = {
    id: number
    transactionType: number
    component: number
    debitAccountCode: number
    creditAccountCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionMatrixMinAggregateInputType = {
    id?: true
    transactionType?: true
    component?: true
    debitAccountCode?: true
    creditAccountCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMatrixMaxAggregateInputType = {
    id?: true
    transactionType?: true
    component?: true
    debitAccountCode?: true
    creditAccountCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMatrixCountAggregateInputType = {
    id?: true
    transactionType?: true
    component?: true
    debitAccountCode?: true
    creditAccountCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionMatrixAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionMatrix to aggregate.
     */
    where?: TransactionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMatrices to fetch.
     */
    orderBy?: TransactionMatrixOrderByWithRelationInput | TransactionMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionMatrices
    **/
    _count?: true | TransactionMatrixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMatrixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMatrixMaxAggregateInputType
  }

  export type GetTransactionMatrixAggregateType<T extends TransactionMatrixAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionMatrix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionMatrix[P]>
      : GetScalarType<T[P], AggregateTransactionMatrix[P]>
  }




  export type TransactionMatrixGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionMatrixWhereInput
    orderBy?: TransactionMatrixOrderByWithAggregationInput | TransactionMatrixOrderByWithAggregationInput[]
    by: TransactionMatrixScalarFieldEnum[] | TransactionMatrixScalarFieldEnum
    having?: TransactionMatrixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionMatrixCountAggregateInputType | true
    _min?: TransactionMatrixMinAggregateInputType
    _max?: TransactionMatrixMaxAggregateInputType
  }

  export type TransactionMatrixGroupByOutputType = {
    id: string
    transactionType: $Enums.TransactionType
    component: $Enums.ChargeType
    debitAccountCode: string
    creditAccountCode: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TransactionMatrixCountAggregateOutputType | null
    _min: TransactionMatrixMinAggregateOutputType | null
    _max: TransactionMatrixMaxAggregateOutputType | null
  }

  type GetTransactionMatrixGroupByPayload<T extends TransactionMatrixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionMatrixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionMatrixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionMatrixGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionMatrixGroupByOutputType[P]>
        }
      >
    >


  export type TransactionMatrixSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionType?: boolean
    component?: boolean
    debitAccountCode?: boolean
    creditAccountCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transactionMatrix"]>

  export type TransactionMatrixSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionType?: boolean
    component?: boolean
    debitAccountCode?: boolean
    creditAccountCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transactionMatrix"]>

  export type TransactionMatrixSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionType?: boolean
    component?: boolean
    debitAccountCode?: boolean
    creditAccountCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transactionMatrix"]>

  export type TransactionMatrixSelectScalar = {
    id?: boolean
    transactionType?: boolean
    component?: boolean
    debitAccountCode?: boolean
    creditAccountCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionMatrixOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionType" | "component" | "debitAccountCode" | "creditAccountCode" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionMatrix"]>

  export type $TransactionMatrixPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionMatrix"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionType: $Enums.TransactionType
      component: $Enums.ChargeType
      debitAccountCode: string
      creditAccountCode: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionMatrix"]>
    composites: {}
  }

  type TransactionMatrixGetPayload<S extends boolean | null | undefined | TransactionMatrixDefaultArgs> = $Result.GetResult<Prisma.$TransactionMatrixPayload, S>

  type TransactionMatrixCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionMatrixFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionMatrixCountAggregateInputType | true
    }

  export interface TransactionMatrixDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionMatrix'], meta: { name: 'TransactionMatrix' } }
    /**
     * Find zero or one TransactionMatrix that matches the filter.
     * @param {TransactionMatrixFindUniqueArgs} args - Arguments to find a TransactionMatrix
     * @example
     * // Get one TransactionMatrix
     * const transactionMatrix = await prisma.transactionMatrix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionMatrixFindUniqueArgs>(args: SelectSubset<T, TransactionMatrixFindUniqueArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionMatrix that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionMatrixFindUniqueOrThrowArgs} args - Arguments to find a TransactionMatrix
     * @example
     * // Get one TransactionMatrix
     * const transactionMatrix = await prisma.transactionMatrix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionMatrixFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionMatrixFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionMatrix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMatrixFindFirstArgs} args - Arguments to find a TransactionMatrix
     * @example
     * // Get one TransactionMatrix
     * const transactionMatrix = await prisma.transactionMatrix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionMatrixFindFirstArgs>(args?: SelectSubset<T, TransactionMatrixFindFirstArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionMatrix that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMatrixFindFirstOrThrowArgs} args - Arguments to find a TransactionMatrix
     * @example
     * // Get one TransactionMatrix
     * const transactionMatrix = await prisma.transactionMatrix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionMatrixFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionMatrixFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionMatrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMatrixFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionMatrices
     * const transactionMatrices = await prisma.transactionMatrix.findMany()
     * 
     * // Get first 10 TransactionMatrices
     * const transactionMatrices = await prisma.transactionMatrix.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionMatrixWithIdOnly = await prisma.transactionMatrix.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionMatrixFindManyArgs>(args?: SelectSubset<T, TransactionMatrixFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionMatrix.
     * @param {TransactionMatrixCreateArgs} args - Arguments to create a TransactionMatrix.
     * @example
     * // Create one TransactionMatrix
     * const TransactionMatrix = await prisma.transactionMatrix.create({
     *   data: {
     *     // ... data to create a TransactionMatrix
     *   }
     * })
     * 
     */
    create<T extends TransactionMatrixCreateArgs>(args: SelectSubset<T, TransactionMatrixCreateArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionMatrices.
     * @param {TransactionMatrixCreateManyArgs} args - Arguments to create many TransactionMatrices.
     * @example
     * // Create many TransactionMatrices
     * const transactionMatrix = await prisma.transactionMatrix.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionMatrixCreateManyArgs>(args?: SelectSubset<T, TransactionMatrixCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionMatrices and returns the data saved in the database.
     * @param {TransactionMatrixCreateManyAndReturnArgs} args - Arguments to create many TransactionMatrices.
     * @example
     * // Create many TransactionMatrices
     * const transactionMatrix = await prisma.transactionMatrix.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionMatrices and only return the `id`
     * const transactionMatrixWithIdOnly = await prisma.transactionMatrix.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionMatrixCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionMatrixCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionMatrix.
     * @param {TransactionMatrixDeleteArgs} args - Arguments to delete one TransactionMatrix.
     * @example
     * // Delete one TransactionMatrix
     * const TransactionMatrix = await prisma.transactionMatrix.delete({
     *   where: {
     *     // ... filter to delete one TransactionMatrix
     *   }
     * })
     * 
     */
    delete<T extends TransactionMatrixDeleteArgs>(args: SelectSubset<T, TransactionMatrixDeleteArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionMatrix.
     * @param {TransactionMatrixUpdateArgs} args - Arguments to update one TransactionMatrix.
     * @example
     * // Update one TransactionMatrix
     * const transactionMatrix = await prisma.transactionMatrix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionMatrixUpdateArgs>(args: SelectSubset<T, TransactionMatrixUpdateArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionMatrices.
     * @param {TransactionMatrixDeleteManyArgs} args - Arguments to filter TransactionMatrices to delete.
     * @example
     * // Delete a few TransactionMatrices
     * const { count } = await prisma.transactionMatrix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionMatrixDeleteManyArgs>(args?: SelectSubset<T, TransactionMatrixDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMatrixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionMatrices
     * const transactionMatrix = await prisma.transactionMatrix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionMatrixUpdateManyArgs>(args: SelectSubset<T, TransactionMatrixUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionMatrices and returns the data updated in the database.
     * @param {TransactionMatrixUpdateManyAndReturnArgs} args - Arguments to update many TransactionMatrices.
     * @example
     * // Update many TransactionMatrices
     * const transactionMatrix = await prisma.transactionMatrix.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionMatrices and only return the `id`
     * const transactionMatrixWithIdOnly = await prisma.transactionMatrix.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionMatrixUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionMatrixUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionMatrix.
     * @param {TransactionMatrixUpsertArgs} args - Arguments to update or create a TransactionMatrix.
     * @example
     * // Update or create a TransactionMatrix
     * const transactionMatrix = await prisma.transactionMatrix.upsert({
     *   create: {
     *     // ... data to create a TransactionMatrix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionMatrix we want to update
     *   }
     * })
     */
    upsert<T extends TransactionMatrixUpsertArgs>(args: SelectSubset<T, TransactionMatrixUpsertArgs<ExtArgs>>): Prisma__TransactionMatrixClient<$Result.GetResult<Prisma.$TransactionMatrixPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMatrixCountArgs} args - Arguments to filter TransactionMatrices to count.
     * @example
     * // Count the number of TransactionMatrices
     * const count = await prisma.transactionMatrix.count({
     *   where: {
     *     // ... the filter for the TransactionMatrices we want to count
     *   }
     * })
    **/
    count<T extends TransactionMatrixCountArgs>(
      args?: Subset<T, TransactionMatrixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionMatrixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMatrixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionMatrixAggregateArgs>(args: Subset<T, TransactionMatrixAggregateArgs>): Prisma.PrismaPromise<GetTransactionMatrixAggregateType<T>>

    /**
     * Group by TransactionMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMatrixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionMatrixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionMatrixGroupByArgs['orderBy'] }
        : { orderBy?: TransactionMatrixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionMatrixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionMatrixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionMatrix model
   */
  readonly fields: TransactionMatrixFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionMatrix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionMatrixClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionMatrix model
   */
  interface TransactionMatrixFieldRefs {
    readonly id: FieldRef<"TransactionMatrix", 'String'>
    readonly transactionType: FieldRef<"TransactionMatrix", 'TransactionType'>
    readonly component: FieldRef<"TransactionMatrix", 'ChargeType'>
    readonly debitAccountCode: FieldRef<"TransactionMatrix", 'String'>
    readonly creditAccountCode: FieldRef<"TransactionMatrix", 'String'>
    readonly isActive: FieldRef<"TransactionMatrix", 'Boolean'>
    readonly createdAt: FieldRef<"TransactionMatrix", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionMatrix", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionMatrix findUnique
   */
  export type TransactionMatrixFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * Filter, which TransactionMatrix to fetch.
     */
    where: TransactionMatrixWhereUniqueInput
  }

  /**
   * TransactionMatrix findUniqueOrThrow
   */
  export type TransactionMatrixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * Filter, which TransactionMatrix to fetch.
     */
    where: TransactionMatrixWhereUniqueInput
  }

  /**
   * TransactionMatrix findFirst
   */
  export type TransactionMatrixFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * Filter, which TransactionMatrix to fetch.
     */
    where?: TransactionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMatrices to fetch.
     */
    orderBy?: TransactionMatrixOrderByWithRelationInput | TransactionMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionMatrices.
     */
    cursor?: TransactionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionMatrices.
     */
    distinct?: TransactionMatrixScalarFieldEnum | TransactionMatrixScalarFieldEnum[]
  }

  /**
   * TransactionMatrix findFirstOrThrow
   */
  export type TransactionMatrixFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * Filter, which TransactionMatrix to fetch.
     */
    where?: TransactionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMatrices to fetch.
     */
    orderBy?: TransactionMatrixOrderByWithRelationInput | TransactionMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionMatrices.
     */
    cursor?: TransactionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionMatrices.
     */
    distinct?: TransactionMatrixScalarFieldEnum | TransactionMatrixScalarFieldEnum[]
  }

  /**
   * TransactionMatrix findMany
   */
  export type TransactionMatrixFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * Filter, which TransactionMatrices to fetch.
     */
    where?: TransactionMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMatrices to fetch.
     */
    orderBy?: TransactionMatrixOrderByWithRelationInput | TransactionMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionMatrices.
     */
    cursor?: TransactionMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMatrices.
     */
    skip?: number
    distinct?: TransactionMatrixScalarFieldEnum | TransactionMatrixScalarFieldEnum[]
  }

  /**
   * TransactionMatrix create
   */
  export type TransactionMatrixCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * The data needed to create a TransactionMatrix.
     */
    data: XOR<TransactionMatrixCreateInput, TransactionMatrixUncheckedCreateInput>
  }

  /**
   * TransactionMatrix createMany
   */
  export type TransactionMatrixCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionMatrices.
     */
    data: TransactionMatrixCreateManyInput | TransactionMatrixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionMatrix createManyAndReturn
   */
  export type TransactionMatrixCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionMatrices.
     */
    data: TransactionMatrixCreateManyInput | TransactionMatrixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionMatrix update
   */
  export type TransactionMatrixUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * The data needed to update a TransactionMatrix.
     */
    data: XOR<TransactionMatrixUpdateInput, TransactionMatrixUncheckedUpdateInput>
    /**
     * Choose, which TransactionMatrix to update.
     */
    where: TransactionMatrixWhereUniqueInput
  }

  /**
   * TransactionMatrix updateMany
   */
  export type TransactionMatrixUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionMatrices.
     */
    data: XOR<TransactionMatrixUpdateManyMutationInput, TransactionMatrixUncheckedUpdateManyInput>
    /**
     * Filter which TransactionMatrices to update
     */
    where?: TransactionMatrixWhereInput
    /**
     * Limit how many TransactionMatrices to update.
     */
    limit?: number
  }

  /**
   * TransactionMatrix updateManyAndReturn
   */
  export type TransactionMatrixUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * The data used to update TransactionMatrices.
     */
    data: XOR<TransactionMatrixUpdateManyMutationInput, TransactionMatrixUncheckedUpdateManyInput>
    /**
     * Filter which TransactionMatrices to update
     */
    where?: TransactionMatrixWhereInput
    /**
     * Limit how many TransactionMatrices to update.
     */
    limit?: number
  }

  /**
   * TransactionMatrix upsert
   */
  export type TransactionMatrixUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * The filter to search for the TransactionMatrix to update in case it exists.
     */
    where: TransactionMatrixWhereUniqueInput
    /**
     * In case the TransactionMatrix found by the `where` argument doesn't exist, create a new TransactionMatrix with this data.
     */
    create: XOR<TransactionMatrixCreateInput, TransactionMatrixUncheckedCreateInput>
    /**
     * In case the TransactionMatrix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionMatrixUpdateInput, TransactionMatrixUncheckedUpdateInput>
  }

  /**
   * TransactionMatrix delete
   */
  export type TransactionMatrixDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
    /**
     * Filter which TransactionMatrix to delete.
     */
    where: TransactionMatrixWhereUniqueInput
  }

  /**
   * TransactionMatrix deleteMany
   */
  export type TransactionMatrixDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionMatrices to delete
     */
    where?: TransactionMatrixWhereInput
    /**
     * Limit how many TransactionMatrices to delete.
     */
    limit?: number
  }

  /**
   * TransactionMatrix without action
   */
  export type TransactionMatrixDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMatrix
     */
    select?: TransactionMatrixSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMatrix
     */
    omit?: TransactionMatrixOmit<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly category: FieldRef<"SystemConfig", 'String'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    token: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    token: string
    ipAddress: string | null
    userAgent: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt" | "expiresAt" | "token" | "ipAddress" | "userAgent", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
      token: string
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    role: 'role',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    image: 'image',
    emailVerified: 'emailVerified',
    name: 'name'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    surname: 'surname',
    otherNames: 'otherNames',
    dateOfBirth: 'dateOfBirth',
    maritalStatus: 'maritalStatus',
    nationality: 'nationality',
    dependents: 'dependents',
    idPassportNo: 'idPassportNo',
    kraPin: 'kraPin',
    phoneWork: 'phoneWork',
    phoneMobile: 'phoneMobile',
    phoneAlternative: 'phoneAlternative',
    emailPersonal: 'emailPersonal',
    emailOfficial: 'emailOfficial',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientAddressScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    postalAddress: 'postalAddress',
    postalCode: 'postalCode',
    townCity: 'townCity',
    residentialAddress: 'residentialAddress',
    location: 'location',
    estate: 'estate',
    building: 'building',
    houseNumber: 'houseNumber',
    landmark: 'landmark',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientAddressScalarFieldEnum = (typeof ClientAddressScalarFieldEnum)[keyof typeof ClientAddressScalarFieldEnum]


  export const EmploymentDetailScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    employerName: 'employerName',
    jobTitle: 'jobTitle',
    department: 'department',
    dateJoined: 'dateJoined',
    periodWorked: 'periodWorked',
    employmentType: 'employmentType',
    contractExpiry: 'contractExpiry',
    onNotice: 'onNotice',
    netSalary: 'netSalary',
    branchLocation: 'branchLocation',
    roadStreet: 'roadStreet',
    building: 'building',
    floorOffice: 'floorOffice',
    telephone: 'telephone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmploymentDetailScalarFieldEnum = (typeof EmploymentDetailScalarFieldEnum)[keyof typeof EmploymentDetailScalarFieldEnum]


  export const RefereeScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    surname: 'surname',
    otherNames: 'otherNames',
    relationship: 'relationship',
    idPassportNo: 'idPassportNo',
    employerName: 'employerName',
    locationStation: 'locationStation',
    phoneWork: 'phoneWork',
    phoneMobile: 'phoneMobile',
    isRelative: 'isRelative',
    createdAt: 'createdAt'
  };

  export type RefereeScalarFieldEnum = (typeof RefereeScalarFieldEnum)[keyof typeof RefereeScalarFieldEnum]


  export const BankDetailScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    bankName: 'bankName',
    branch: 'branch',
    accountName: 'accountName',
    accountNumber: 'accountNumber',
    proofDocument: 'proofDocument',
    proofDocumentUrl: 'proofDocumentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankDetailScalarFieldEnum = (typeof BankDetailScalarFieldEnum)[keyof typeof BankDetailScalarFieldEnum]


  export const LoanApplicationScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    purpose: 'purpose',
    amountRequested: 'amountRequested',
    approvedAmount: 'approvedAmount',
    qualificationType: 'qualificationType',
    interestRate: 'interestRate',
    startDate: 'startDate',
    repaymentPeriod: 'repaymentPeriod',
    status: 'status',
    appliedAt: 'appliedAt',
    reviewedAt: 'reviewedAt',
    reviewedById: 'reviewedById',
    approvedAt: 'approvedAt',
    approvedById: 'approvedById',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanApplicationScalarFieldEnum = (typeof LoanApplicationScalarFieldEnum)[keyof typeof LoanApplicationScalarFieldEnum]


  export const LoanQualificationScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    avgIncome: 'avgIncome',
    eligibilityAmount: 'eligibilityAmount',
    ruleApplied: 'ruleApplied',
    createdAt: 'createdAt'
  };

  export type LoanQualificationScalarFieldEnum = (typeof LoanQualificationScalarFieldEnum)[keyof typeof LoanQualificationScalarFieldEnum]


  export const LoanSecurityScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    idCopy: 'idCopy',
    passportPhoto: 'passportPhoto',
    appointmentLetter: 'appointmentLetter',
    payslips: 'payslips',
    bankStatement: 'bankStatement',
    chequeLeafNo: 'chequeLeafNo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanSecurityScalarFieldEnum = (typeof LoanSecurityScalarFieldEnum)[keyof typeof LoanSecurityScalarFieldEnum]


  export const VehicleSecurityScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    registrationNumber: 'registrationNumber',
    chassisNumber: 'chassisNumber',
    engineNumber: 'engineNumber',
    yearOfManufacture: 'yearOfManufacture',
    make: 'make',
    model: 'model',
    bodyColor: 'bodyColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleSecurityScalarFieldEnum = (typeof VehicleSecurityScalarFieldEnum)[keyof typeof VehicleSecurityScalarFieldEnum]


  export const GuarantorScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    fullName: 'fullName',
    phone: 'phone',
    email: 'email',
    idNumber: 'idNumber',
    relationship: 'relationship',
    confirmationStatus: 'confirmationStatus',
    confirmedAt: 'confirmedAt',
    createdAt: 'createdAt'
  };

  export type GuarantorScalarFieldEnum = (typeof GuarantorScalarFieldEnum)[keyof typeof GuarantorScalarFieldEnum]


  export const LoanDisbursementScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    amount: 'amount',
    method: 'method',
    reference: 'reference',
    disbursedAt: 'disbursedAt',
    createdAt: 'createdAt'
  };

  export type LoanDisbursementScalarFieldEnum = (typeof LoanDisbursementScalarFieldEnum)[keyof typeof LoanDisbursementScalarFieldEnum]


  export const LoanFinancialScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    processingFee: 'processingFee',
    legalFee: 'legalFee',
    penaltyFee: 'penaltyFee',
    interestAmount: 'interestAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanFinancialScalarFieldEnum = (typeof LoanFinancialScalarFieldEnum)[keyof typeof LoanFinancialScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    clientId: 'clientId',
    loanId: 'loanId',
    invoiceType: 'invoiceType',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    totalAmount: 'totalAmount',
    status: 'status',
    issuedBy: 'issuedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    chargeType: 'chargeType',
    description: 'description',
    amount: 'amount',
    glAccount: 'glAccount',
    createdAt: 'createdAt'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const InvoicePaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    transactionId: 'transactionId',
    amountPaid: 'amountPaid',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt'
  };

  export type InvoicePaymentScalarFieldEnum = (typeof InvoicePaymentScalarFieldEnum)[keyof typeof InvoicePaymentScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    transactionCode: 'transactionCode',
    transactionType: 'transactionType',
    referenceType: 'referenceType',
    referenceId: 'referenceId',
    amount: 'amount',
    debitAccount: 'debitAccount',
    creditAccount: 'creditAccount',
    paymentMethod: 'paymentMethod',
    transactionDate: 'transactionDate',
    description: 'description',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const RepaymentScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    paymentDate: 'paymentDate',
    category: 'category',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type RepaymentScalarFieldEnum = (typeof RepaymentScalarFieldEnum)[keyof typeof RepaymentScalarFieldEnum]


  export const NonPerformingLoanScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    capitalizedAmount: 'capitalizedAmount',
    flaggedAt: 'flaggedAt',
    createdAt: 'createdAt'
  };

  export type NonPerformingLoanScalarFieldEnum = (typeof NonPerformingLoanScalarFieldEnum)[keyof typeof NonPerformingLoanScalarFieldEnum]


  export const RecoveryAgentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    phone: 'phone',
    email: 'email',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecoveryAgentScalarFieldEnum = (typeof RecoveryAgentScalarFieldEnum)[keyof typeof RecoveryAgentScalarFieldEnum]


  export const RecoveryRecordScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    agentId: 'agentId',
    actionTaken: 'actionTaken',
    outcome: 'outcome',
    recordedAt: 'recordedAt',
    createdAt: 'createdAt'
  };

  export type RecoveryRecordScalarFieldEnum = (typeof RecoveryRecordScalarFieldEnum)[keyof typeof RecoveryRecordScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    contact: 'contact',
    email: 'email',
    investedAmount: 'investedAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const InvestorAllocationScalarFieldEnum: {
    id: 'id',
    investorId: 'investorId',
    loanId: 'loanId',
    allocatedAmount: 'allocatedAmount',
    expectedReturn: 'expectedReturn',
    actualReturn: 'actualReturn',
    allocationDate: 'allocationDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorAllocationScalarFieldEnum = (typeof InvestorAllocationScalarFieldEnum)[keyof typeof InvestorAllocationScalarFieldEnum]


  export const InvestorPayoutScalarFieldEnum: {
    id: 'id',
    investorId: 'investorId',
    amount: 'amount',
    payoutDate: 'payoutDate',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type InvestorPayoutScalarFieldEnum = (typeof InvestorPayoutScalarFieldEnum)[keyof typeof InvestorPayoutScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    loanId: 'loanId',
    documentType: 'documentType',
    filePublicId: 'filePublicId',
    fileUniqueId: 'fileUniqueId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedAt: 'uploadedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    expenseType: 'expenseType',
    amount: 'amount',
    description: 'description',
    incurredAt: 'incurredAt',
    createdAt: 'createdAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const SmsLogScalarFieldEnum: {
    id: 'id',
    recipient: 'recipient',
    message: 'message',
    purpose: 'purpose',
    cost: 'cost',
    sentAt: 'sentAt',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type SmsLogScalarFieldEnum = (typeof SmsLogScalarFieldEnum)[keyof typeof SmsLogScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ipAddress: 'ipAddress',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ChartOfAccountScalarFieldEnum: {
    id: 'id',
    accountCode: 'accountCode',
    accountName: 'accountName',
    accountType: 'accountType',
    parentAccountId: 'parentAccountId',
    normalBalance: 'normalBalance',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChartOfAccountScalarFieldEnum = (typeof ChartOfAccountScalarFieldEnum)[keyof typeof ChartOfAccountScalarFieldEnum]


  export const TransactionMatrixScalarFieldEnum: {
    id: 'id',
    transactionType: 'transactionType',
    component: 'component',
    debitAccountCode: 'debitAccountCode',
    creditAccountCode: 'creditAccountCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionMatrixScalarFieldEnum = (typeof TransactionMatrixScalarFieldEnum)[keyof typeof TransactionMatrixScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Title'
   */
  export type EnumTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Title'>
    


  /**
   * Reference to a field of type 'Title[]'
   */
  export type ListEnumTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Title[]'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ClientStatus'
   */
  export type EnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus'>
    


  /**
   * Reference to a field of type 'ClientStatus[]'
   */
  export type ListEnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus[]'>
    


  /**
   * Reference to a field of type 'EmploymentType'
   */
  export type EnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType'>
    


  /**
   * Reference to a field of type 'EmploymentType[]'
   */
  export type ListEnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'QualificationType'
   */
  export type EnumQualificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QualificationType'>
    


  /**
   * Reference to a field of type 'QualificationType[]'
   */
  export type ListEnumQualificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QualificationType[]'>
    


  /**
   * Reference to a field of type 'LoanApplicationStatus'
   */
  export type EnumLoanApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanApplicationStatus'>
    


  /**
   * Reference to a field of type 'LoanApplicationStatus[]'
   */
  export type ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'GuarantorStatus'
   */
  export type EnumGuarantorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuarantorStatus'>
    


  /**
   * Reference to a field of type 'GuarantorStatus[]'
   */
  export type ListEnumGuarantorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuarantorStatus[]'>
    


  /**
   * Reference to a field of type 'DisbursementMethod'
   */
  export type EnumDisbursementMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisbursementMethod'>
    


  /**
   * Reference to a field of type 'DisbursementMethod[]'
   */
  export type ListEnumDisbursementMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisbursementMethod[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'ChargeType'
   */
  export type EnumChargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChargeType'>
    


  /**
   * Reference to a field of type 'ChargeType[]'
   */
  export type ListEnumChargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChargeType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'ReferenceType'
   */
  export type EnumReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferenceType'>
    


  /**
   * Reference to a field of type 'ReferenceType[]'
   */
  export type ListEnumReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferenceType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'RepaymentCategory'
   */
  export type EnumRepaymentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RepaymentCategory'>
    


  /**
   * Reference to a field of type 'RepaymentCategory[]'
   */
  export type ListEnumRepaymentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RepaymentCategory[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'ExpenseType'
   */
  export type EnumExpenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseType'>
    


  /**
   * Reference to a field of type 'ExpenseType[]'
   */
  export type ListEnumExpenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseType[]'>
    


  /**
   * Reference to a field of type 'SmsPurpose'
   */
  export type EnumSmsPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SmsPurpose'>
    


  /**
   * Reference to a field of type 'SmsPurpose[]'
   */
  export type ListEnumSmsPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SmsPurpose[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'NormalBalance'
   */
  export type EnumNormalBalanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NormalBalance'>
    


  /**
   * Reference to a field of type 'NormalBalance[]'
   */
  export type ListEnumNormalBalanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NormalBalance[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    name?: StringFilter<"User"> | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    investor?: XOR<InvestorNullableScalarRelationFilter, InvestorWhereInput> | null
    approvedLoans?: LoanApplicationListRelationFilter
    reviewedLoans?: LoanApplicationListRelationFilter
    recoveryAgent?: XOR<RecoveryAgentNullableScalarRelationFilter, RecoveryAgentWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    name?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    approvedLoans?: LoanApplicationOrderByRelationAggregateInput
    reviewedLoans?: LoanApplicationOrderByRelationAggregateInput
    recoveryAgent?: RecoveryAgentOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    name?: StringFilter<"User"> | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    investor?: XOR<InvestorNullableScalarRelationFilter, InvestorWhereInput> | null
    approvedLoans?: LoanApplicationListRelationFilter
    reviewedLoans?: LoanApplicationListRelationFilter
    recoveryAgent?: XOR<RecoveryAgentNullableScalarRelationFilter, RecoveryAgentWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    name?: StringWithAggregatesFilter<"User"> | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringNullableFilter<"Client"> | string | null
    title?: EnumTitleFilter<"Client"> | $Enums.Title
    surname?: StringFilter<"Client"> | string
    otherNames?: StringFilter<"Client"> | string
    dateOfBirth?: DateTimeFilter<"Client"> | Date | string
    maritalStatus?: EnumMaritalStatusFilter<"Client"> | $Enums.MaritalStatus
    nationality?: StringFilter<"Client"> | string
    dependents?: IntFilter<"Client"> | number
    idPassportNo?: StringFilter<"Client"> | string
    kraPin?: StringNullableFilter<"Client"> | string | null
    phoneWork?: StringNullableFilter<"Client"> | string | null
    phoneMobile?: StringFilter<"Client"> | string
    phoneAlternative?: StringNullableFilter<"Client"> | string | null
    emailPersonal?: StringNullableFilter<"Client"> | string | null
    emailOfficial?: StringNullableFilter<"Client"> | string | null
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    bankDetails?: BankDetailListRelationFilter
    addresses?: ClientAddressListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    documents?: DocumentListRelationFilter
    employmentDetails?: EmploymentDetailListRelationFilter
    invoices?: InvoiceListRelationFilter
    loanApplications?: LoanApplicationListRelationFilter
    referees?: RefereeListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    dependents?: SortOrder
    idPassportNo?: SortOrder
    kraPin?: SortOrderInput | SortOrder
    phoneWork?: SortOrderInput | SortOrder
    phoneMobile?: SortOrder
    phoneAlternative?: SortOrderInput | SortOrder
    emailPersonal?: SortOrderInput | SortOrder
    emailOfficial?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bankDetails?: BankDetailOrderByRelationAggregateInput
    addresses?: ClientAddressOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    employmentDetails?: EmploymentDetailOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    loanApplications?: LoanApplicationOrderByRelationAggregateInput
    referees?: RefereeOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    idPassportNo?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    title?: EnumTitleFilter<"Client"> | $Enums.Title
    surname?: StringFilter<"Client"> | string
    otherNames?: StringFilter<"Client"> | string
    dateOfBirth?: DateTimeFilter<"Client"> | Date | string
    maritalStatus?: EnumMaritalStatusFilter<"Client"> | $Enums.MaritalStatus
    nationality?: StringFilter<"Client"> | string
    dependents?: IntFilter<"Client"> | number
    kraPin?: StringNullableFilter<"Client"> | string | null
    phoneWork?: StringNullableFilter<"Client"> | string | null
    phoneMobile?: StringFilter<"Client"> | string
    phoneAlternative?: StringNullableFilter<"Client"> | string | null
    emailPersonal?: StringNullableFilter<"Client"> | string | null
    emailOfficial?: StringNullableFilter<"Client"> | string | null
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    bankDetails?: BankDetailListRelationFilter
    addresses?: ClientAddressListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    documents?: DocumentListRelationFilter
    employmentDetails?: EmploymentDetailListRelationFilter
    invoices?: InvoiceListRelationFilter
    loanApplications?: LoanApplicationListRelationFilter
    referees?: RefereeListRelationFilter
  }, "id" | "userId" | "idPassportNo">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    dependents?: SortOrder
    idPassportNo?: SortOrder
    kraPin?: SortOrderInput | SortOrder
    phoneWork?: SortOrderInput | SortOrder
    phoneMobile?: SortOrder
    phoneAlternative?: SortOrderInput | SortOrder
    emailPersonal?: SortOrderInput | SortOrder
    emailOfficial?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    userId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    title?: EnumTitleWithAggregatesFilter<"Client"> | $Enums.Title
    surname?: StringWithAggregatesFilter<"Client"> | string
    otherNames?: StringWithAggregatesFilter<"Client"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    maritalStatus?: EnumMaritalStatusWithAggregatesFilter<"Client"> | $Enums.MaritalStatus
    nationality?: StringWithAggregatesFilter<"Client"> | string
    dependents?: IntWithAggregatesFilter<"Client"> | number
    idPassportNo?: StringWithAggregatesFilter<"Client"> | string
    kraPin?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phoneWork?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phoneMobile?: StringWithAggregatesFilter<"Client"> | string
    phoneAlternative?: StringNullableWithAggregatesFilter<"Client"> | string | null
    emailPersonal?: StringNullableWithAggregatesFilter<"Client"> | string | null
    emailOfficial?: StringNullableWithAggregatesFilter<"Client"> | string | null
    status?: EnumClientStatusWithAggregatesFilter<"Client"> | $Enums.ClientStatus
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ClientAddressWhereInput = {
    AND?: ClientAddressWhereInput | ClientAddressWhereInput[]
    OR?: ClientAddressWhereInput[]
    NOT?: ClientAddressWhereInput | ClientAddressWhereInput[]
    id?: StringFilter<"ClientAddress"> | string
    clientId?: StringFilter<"ClientAddress"> | string
    postalAddress?: StringNullableFilter<"ClientAddress"> | string | null
    postalCode?: StringNullableFilter<"ClientAddress"> | string | null
    townCity?: StringNullableFilter<"ClientAddress"> | string | null
    residentialAddress?: StringNullableFilter<"ClientAddress"> | string | null
    location?: StringNullableFilter<"ClientAddress"> | string | null
    estate?: StringNullableFilter<"ClientAddress"> | string | null
    building?: StringNullableFilter<"ClientAddress"> | string | null
    houseNumber?: StringNullableFilter<"ClientAddress"> | string | null
    landmark?: StringNullableFilter<"ClientAddress"> | string | null
    createdAt?: DateTimeFilter<"ClientAddress"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAddress"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientAddressOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    postalAddress?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    townCity?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    estate?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    houseNumber?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientAddressWhereInput | ClientAddressWhereInput[]
    OR?: ClientAddressWhereInput[]
    NOT?: ClientAddressWhereInput | ClientAddressWhereInput[]
    clientId?: StringFilter<"ClientAddress"> | string
    postalAddress?: StringNullableFilter<"ClientAddress"> | string | null
    postalCode?: StringNullableFilter<"ClientAddress"> | string | null
    townCity?: StringNullableFilter<"ClientAddress"> | string | null
    residentialAddress?: StringNullableFilter<"ClientAddress"> | string | null
    location?: StringNullableFilter<"ClientAddress"> | string | null
    estate?: StringNullableFilter<"ClientAddress"> | string | null
    building?: StringNullableFilter<"ClientAddress"> | string | null
    houseNumber?: StringNullableFilter<"ClientAddress"> | string | null
    landmark?: StringNullableFilter<"ClientAddress"> | string | null
    createdAt?: DateTimeFilter<"ClientAddress"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAddress"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ClientAddressOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    postalAddress?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    townCity?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    estate?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    houseNumber?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientAddressCountOrderByAggregateInput
    _max?: ClientAddressMaxOrderByAggregateInput
    _min?: ClientAddressMinOrderByAggregateInput
  }

  export type ClientAddressScalarWhereWithAggregatesInput = {
    AND?: ClientAddressScalarWhereWithAggregatesInput | ClientAddressScalarWhereWithAggregatesInput[]
    OR?: ClientAddressScalarWhereWithAggregatesInput[]
    NOT?: ClientAddressScalarWhereWithAggregatesInput | ClientAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientAddress"> | string
    clientId?: StringWithAggregatesFilter<"ClientAddress"> | string
    postalAddress?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    townCity?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    residentialAddress?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    location?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    estate?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    building?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    houseNumber?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    landmark?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientAddress"> | Date | string
  }

  export type EmploymentDetailWhereInput = {
    AND?: EmploymentDetailWhereInput | EmploymentDetailWhereInput[]
    OR?: EmploymentDetailWhereInput[]
    NOT?: EmploymentDetailWhereInput | EmploymentDetailWhereInput[]
    id?: StringFilter<"EmploymentDetail"> | string
    clientId?: StringFilter<"EmploymentDetail"> | string
    employerName?: StringFilter<"EmploymentDetail"> | string
    jobTitle?: StringFilter<"EmploymentDetail"> | string
    department?: StringNullableFilter<"EmploymentDetail"> | string | null
    dateJoined?: DateTimeNullableFilter<"EmploymentDetail"> | Date | string | null
    periodWorked?: StringNullableFilter<"EmploymentDetail"> | string | null
    employmentType?: EnumEmploymentTypeFilter<"EmploymentDetail"> | $Enums.EmploymentType
    contractExpiry?: DateTimeNullableFilter<"EmploymentDetail"> | Date | string | null
    onNotice?: BoolFilter<"EmploymentDetail"> | boolean
    netSalary?: DecimalFilter<"EmploymentDetail"> | Decimal | DecimalJsLike | number | string
    branchLocation?: StringNullableFilter<"EmploymentDetail"> | string | null
    roadStreet?: StringNullableFilter<"EmploymentDetail"> | string | null
    building?: StringNullableFilter<"EmploymentDetail"> | string | null
    floorOffice?: StringNullableFilter<"EmploymentDetail"> | string | null
    telephone?: StringNullableFilter<"EmploymentDetail"> | string | null
    createdAt?: DateTimeFilter<"EmploymentDetail"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentDetail"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type EmploymentDetailOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    employerName?: SortOrder
    jobTitle?: SortOrder
    department?: SortOrderInput | SortOrder
    dateJoined?: SortOrderInput | SortOrder
    periodWorked?: SortOrderInput | SortOrder
    employmentType?: SortOrder
    contractExpiry?: SortOrderInput | SortOrder
    onNotice?: SortOrder
    netSalary?: SortOrder
    branchLocation?: SortOrderInput | SortOrder
    roadStreet?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    floorOffice?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type EmploymentDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmploymentDetailWhereInput | EmploymentDetailWhereInput[]
    OR?: EmploymentDetailWhereInput[]
    NOT?: EmploymentDetailWhereInput | EmploymentDetailWhereInput[]
    clientId?: StringFilter<"EmploymentDetail"> | string
    employerName?: StringFilter<"EmploymentDetail"> | string
    jobTitle?: StringFilter<"EmploymentDetail"> | string
    department?: StringNullableFilter<"EmploymentDetail"> | string | null
    dateJoined?: DateTimeNullableFilter<"EmploymentDetail"> | Date | string | null
    periodWorked?: StringNullableFilter<"EmploymentDetail"> | string | null
    employmentType?: EnumEmploymentTypeFilter<"EmploymentDetail"> | $Enums.EmploymentType
    contractExpiry?: DateTimeNullableFilter<"EmploymentDetail"> | Date | string | null
    onNotice?: BoolFilter<"EmploymentDetail"> | boolean
    netSalary?: DecimalFilter<"EmploymentDetail"> | Decimal | DecimalJsLike | number | string
    branchLocation?: StringNullableFilter<"EmploymentDetail"> | string | null
    roadStreet?: StringNullableFilter<"EmploymentDetail"> | string | null
    building?: StringNullableFilter<"EmploymentDetail"> | string | null
    floorOffice?: StringNullableFilter<"EmploymentDetail"> | string | null
    telephone?: StringNullableFilter<"EmploymentDetail"> | string | null
    createdAt?: DateTimeFilter<"EmploymentDetail"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentDetail"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type EmploymentDetailOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    employerName?: SortOrder
    jobTitle?: SortOrder
    department?: SortOrderInput | SortOrder
    dateJoined?: SortOrderInput | SortOrder
    periodWorked?: SortOrderInput | SortOrder
    employmentType?: SortOrder
    contractExpiry?: SortOrderInput | SortOrder
    onNotice?: SortOrder
    netSalary?: SortOrder
    branchLocation?: SortOrderInput | SortOrder
    roadStreet?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    floorOffice?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmploymentDetailCountOrderByAggregateInput
    _avg?: EmploymentDetailAvgOrderByAggregateInput
    _max?: EmploymentDetailMaxOrderByAggregateInput
    _min?: EmploymentDetailMinOrderByAggregateInput
    _sum?: EmploymentDetailSumOrderByAggregateInput
  }

  export type EmploymentDetailScalarWhereWithAggregatesInput = {
    AND?: EmploymentDetailScalarWhereWithAggregatesInput | EmploymentDetailScalarWhereWithAggregatesInput[]
    OR?: EmploymentDetailScalarWhereWithAggregatesInput[]
    NOT?: EmploymentDetailScalarWhereWithAggregatesInput | EmploymentDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmploymentDetail"> | string
    clientId?: StringWithAggregatesFilter<"EmploymentDetail"> | string
    employerName?: StringWithAggregatesFilter<"EmploymentDetail"> | string
    jobTitle?: StringWithAggregatesFilter<"EmploymentDetail"> | string
    department?: StringNullableWithAggregatesFilter<"EmploymentDetail"> | string | null
    dateJoined?: DateTimeNullableWithAggregatesFilter<"EmploymentDetail"> | Date | string | null
    periodWorked?: StringNullableWithAggregatesFilter<"EmploymentDetail"> | string | null
    employmentType?: EnumEmploymentTypeWithAggregatesFilter<"EmploymentDetail"> | $Enums.EmploymentType
    contractExpiry?: DateTimeNullableWithAggregatesFilter<"EmploymentDetail"> | Date | string | null
    onNotice?: BoolWithAggregatesFilter<"EmploymentDetail"> | boolean
    netSalary?: DecimalWithAggregatesFilter<"EmploymentDetail"> | Decimal | DecimalJsLike | number | string
    branchLocation?: StringNullableWithAggregatesFilter<"EmploymentDetail"> | string | null
    roadStreet?: StringNullableWithAggregatesFilter<"EmploymentDetail"> | string | null
    building?: StringNullableWithAggregatesFilter<"EmploymentDetail"> | string | null
    floorOffice?: StringNullableWithAggregatesFilter<"EmploymentDetail"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"EmploymentDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmploymentDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmploymentDetail"> | Date | string
  }

  export type RefereeWhereInput = {
    AND?: RefereeWhereInput | RefereeWhereInput[]
    OR?: RefereeWhereInput[]
    NOT?: RefereeWhereInput | RefereeWhereInput[]
    id?: StringFilter<"Referee"> | string
    clientId?: StringFilter<"Referee"> | string
    surname?: StringFilter<"Referee"> | string
    otherNames?: StringFilter<"Referee"> | string
    relationship?: StringFilter<"Referee"> | string
    idPassportNo?: StringNullableFilter<"Referee"> | string | null
    employerName?: StringNullableFilter<"Referee"> | string | null
    locationStation?: StringNullableFilter<"Referee"> | string | null
    phoneWork?: StringNullableFilter<"Referee"> | string | null
    phoneMobile?: StringFilter<"Referee"> | string
    isRelative?: BoolFilter<"Referee"> | boolean
    createdAt?: DateTimeFilter<"Referee"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type RefereeOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    relationship?: SortOrder
    idPassportNo?: SortOrderInput | SortOrder
    employerName?: SortOrderInput | SortOrder
    locationStation?: SortOrderInput | SortOrder
    phoneWork?: SortOrderInput | SortOrder
    phoneMobile?: SortOrder
    isRelative?: SortOrder
    createdAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type RefereeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefereeWhereInput | RefereeWhereInput[]
    OR?: RefereeWhereInput[]
    NOT?: RefereeWhereInput | RefereeWhereInput[]
    clientId?: StringFilter<"Referee"> | string
    surname?: StringFilter<"Referee"> | string
    otherNames?: StringFilter<"Referee"> | string
    relationship?: StringFilter<"Referee"> | string
    idPassportNo?: StringNullableFilter<"Referee"> | string | null
    employerName?: StringNullableFilter<"Referee"> | string | null
    locationStation?: StringNullableFilter<"Referee"> | string | null
    phoneWork?: StringNullableFilter<"Referee"> | string | null
    phoneMobile?: StringFilter<"Referee"> | string
    isRelative?: BoolFilter<"Referee"> | boolean
    createdAt?: DateTimeFilter<"Referee"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type RefereeOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    relationship?: SortOrder
    idPassportNo?: SortOrderInput | SortOrder
    employerName?: SortOrderInput | SortOrder
    locationStation?: SortOrderInput | SortOrder
    phoneWork?: SortOrderInput | SortOrder
    phoneMobile?: SortOrder
    isRelative?: SortOrder
    createdAt?: SortOrder
    _count?: RefereeCountOrderByAggregateInput
    _max?: RefereeMaxOrderByAggregateInput
    _min?: RefereeMinOrderByAggregateInput
  }

  export type RefereeScalarWhereWithAggregatesInput = {
    AND?: RefereeScalarWhereWithAggregatesInput | RefereeScalarWhereWithAggregatesInput[]
    OR?: RefereeScalarWhereWithAggregatesInput[]
    NOT?: RefereeScalarWhereWithAggregatesInput | RefereeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referee"> | string
    clientId?: StringWithAggregatesFilter<"Referee"> | string
    surname?: StringWithAggregatesFilter<"Referee"> | string
    otherNames?: StringWithAggregatesFilter<"Referee"> | string
    relationship?: StringWithAggregatesFilter<"Referee"> | string
    idPassportNo?: StringNullableWithAggregatesFilter<"Referee"> | string | null
    employerName?: StringNullableWithAggregatesFilter<"Referee"> | string | null
    locationStation?: StringNullableWithAggregatesFilter<"Referee"> | string | null
    phoneWork?: StringNullableWithAggregatesFilter<"Referee"> | string | null
    phoneMobile?: StringWithAggregatesFilter<"Referee"> | string
    isRelative?: BoolWithAggregatesFilter<"Referee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Referee"> | Date | string
  }

  export type BankDetailWhereInput = {
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    id?: StringFilter<"BankDetail"> | string
    clientId?: StringFilter<"BankDetail"> | string
    bankName?: StringFilter<"BankDetail"> | string
    branch?: StringFilter<"BankDetail"> | string
    accountName?: StringFilter<"BankDetail"> | string
    accountNumber?: StringFilter<"BankDetail"> | string
    proofDocument?: StringNullableFilter<"BankDetail"> | string | null
    proofDocumentUrl?: StringNullableFilter<"BankDetail"> | string | null
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type BankDetailOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    bankName?: SortOrder
    branch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    proofDocument?: SortOrderInput | SortOrder
    proofDocumentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type BankDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    clientId?: StringFilter<"BankDetail"> | string
    bankName?: StringFilter<"BankDetail"> | string
    branch?: StringFilter<"BankDetail"> | string
    accountName?: StringFilter<"BankDetail"> | string
    accountNumber?: StringFilter<"BankDetail"> | string
    proofDocument?: StringNullableFilter<"BankDetail"> | string | null
    proofDocumentUrl?: StringNullableFilter<"BankDetail"> | string | null
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type BankDetailOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    bankName?: SortOrder
    branch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    proofDocument?: SortOrderInput | SortOrder
    proofDocumentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankDetailCountOrderByAggregateInput
    _max?: BankDetailMaxOrderByAggregateInput
    _min?: BankDetailMinOrderByAggregateInput
  }

  export type BankDetailScalarWhereWithAggregatesInput = {
    AND?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    OR?: BankDetailScalarWhereWithAggregatesInput[]
    NOT?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankDetail"> | string
    clientId?: StringWithAggregatesFilter<"BankDetail"> | string
    bankName?: StringWithAggregatesFilter<"BankDetail"> | string
    branch?: StringWithAggregatesFilter<"BankDetail"> | string
    accountName?: StringWithAggregatesFilter<"BankDetail"> | string
    accountNumber?: StringWithAggregatesFilter<"BankDetail"> | string
    proofDocument?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    proofDocumentUrl?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
  }

  export type LoanApplicationWhereInput = {
    AND?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    OR?: LoanApplicationWhereInput[]
    NOT?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    id?: StringFilter<"LoanApplication"> | string
    clientId?: StringFilter<"LoanApplication"> | string
    purpose?: StringFilter<"LoanApplication"> | string
    amountRequested?: DecimalFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string | null
    qualificationType?: EnumQualificationTypeNullableFilter<"LoanApplication"> | $Enums.QualificationType | null
    interestRate?: DecimalFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    repaymentPeriod?: IntFilter<"LoanApplication"> | number
    status?: EnumLoanApplicationStatusFilter<"LoanApplication"> | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFilter<"LoanApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    reviewedById?: StringNullableFilter<"LoanApplication"> | string | null
    approvedAt?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    approvedById?: StringNullableFilter<"LoanApplication"> | string | null
    rejectionReason?: StringNullableFilter<"LoanApplication"> | string | null
    createdAt?: DateTimeFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LoanApplication"> | Date | string
    documents?: DocumentListRelationFilter
    guarantors?: GuarantorListRelationFilter
    investorAllocations?: InvestorAllocationListRelationFilter
    invoices?: InvoiceListRelationFilter
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    reviewedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    disbursement?: XOR<LoanDisbursementNullableScalarRelationFilter, LoanDisbursementWhereInput> | null
    financials?: XOR<LoanFinancialNullableScalarRelationFilter, LoanFinancialWhereInput> | null
    qualification?: XOR<LoanQualificationNullableScalarRelationFilter, LoanQualificationWhereInput> | null
    security?: XOR<LoanSecurityNullableScalarRelationFilter, LoanSecurityWhereInput> | null
    npl?: XOR<NonPerformingLoanNullableScalarRelationFilter, NonPerformingLoanWhereInput> | null
    recoveryRecords?: RecoveryRecordListRelationFilter
    repayments?: RepaymentListRelationFilter
    vehicleSecurity?: XOR<VehicleSecurityNullableScalarRelationFilter, VehicleSecurityWhereInput> | null
  }

  export type LoanApplicationOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    purpose?: SortOrder
    amountRequested?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    qualificationType?: SortOrderInput | SortOrder
    interestRate?: SortOrder
    startDate?: SortOrderInput | SortOrder
    repaymentPeriod?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documents?: DocumentOrderByRelationAggregateInput
    guarantors?: GuarantorOrderByRelationAggregateInput
    investorAllocations?: InvestorAllocationOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    approvedBy?: UserOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    reviewedBy?: UserOrderByWithRelationInput
    disbursement?: LoanDisbursementOrderByWithRelationInput
    financials?: LoanFinancialOrderByWithRelationInput
    qualification?: LoanQualificationOrderByWithRelationInput
    security?: LoanSecurityOrderByWithRelationInput
    npl?: NonPerformingLoanOrderByWithRelationInput
    recoveryRecords?: RecoveryRecordOrderByRelationAggregateInput
    repayments?: RepaymentOrderByRelationAggregateInput
    vehicleSecurity?: VehicleSecurityOrderByWithRelationInput
  }

  export type LoanApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    OR?: LoanApplicationWhereInput[]
    NOT?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    clientId?: StringFilter<"LoanApplication"> | string
    purpose?: StringFilter<"LoanApplication"> | string
    amountRequested?: DecimalFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string | null
    qualificationType?: EnumQualificationTypeNullableFilter<"LoanApplication"> | $Enums.QualificationType | null
    interestRate?: DecimalFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    repaymentPeriod?: IntFilter<"LoanApplication"> | number
    status?: EnumLoanApplicationStatusFilter<"LoanApplication"> | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFilter<"LoanApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    reviewedById?: StringNullableFilter<"LoanApplication"> | string | null
    approvedAt?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    approvedById?: StringNullableFilter<"LoanApplication"> | string | null
    rejectionReason?: StringNullableFilter<"LoanApplication"> | string | null
    createdAt?: DateTimeFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LoanApplication"> | Date | string
    documents?: DocumentListRelationFilter
    guarantors?: GuarantorListRelationFilter
    investorAllocations?: InvestorAllocationListRelationFilter
    invoices?: InvoiceListRelationFilter
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    reviewedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    disbursement?: XOR<LoanDisbursementNullableScalarRelationFilter, LoanDisbursementWhereInput> | null
    financials?: XOR<LoanFinancialNullableScalarRelationFilter, LoanFinancialWhereInput> | null
    qualification?: XOR<LoanQualificationNullableScalarRelationFilter, LoanQualificationWhereInput> | null
    security?: XOR<LoanSecurityNullableScalarRelationFilter, LoanSecurityWhereInput> | null
    npl?: XOR<NonPerformingLoanNullableScalarRelationFilter, NonPerformingLoanWhereInput> | null
    recoveryRecords?: RecoveryRecordListRelationFilter
    repayments?: RepaymentListRelationFilter
    vehicleSecurity?: XOR<VehicleSecurityNullableScalarRelationFilter, VehicleSecurityWhereInput> | null
  }, "id">

  export type LoanApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    purpose?: SortOrder
    amountRequested?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    qualificationType?: SortOrderInput | SortOrder
    interestRate?: SortOrder
    startDate?: SortOrderInput | SortOrder
    repaymentPeriod?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanApplicationCountOrderByAggregateInput
    _avg?: LoanApplicationAvgOrderByAggregateInput
    _max?: LoanApplicationMaxOrderByAggregateInput
    _min?: LoanApplicationMinOrderByAggregateInput
    _sum?: LoanApplicationSumOrderByAggregateInput
  }

  export type LoanApplicationScalarWhereWithAggregatesInput = {
    AND?: LoanApplicationScalarWhereWithAggregatesInput | LoanApplicationScalarWhereWithAggregatesInput[]
    OR?: LoanApplicationScalarWhereWithAggregatesInput[]
    NOT?: LoanApplicationScalarWhereWithAggregatesInput | LoanApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanApplication"> | string
    clientId?: StringWithAggregatesFilter<"LoanApplication"> | string
    purpose?: StringWithAggregatesFilter<"LoanApplication"> | string
    amountRequested?: DecimalWithAggregatesFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableWithAggregatesFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string | null
    qualificationType?: EnumQualificationTypeNullableWithAggregatesFilter<"LoanApplication"> | $Enums.QualificationType | null
    interestRate?: DecimalWithAggregatesFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeNullableWithAggregatesFilter<"LoanApplication"> | Date | string | null
    repaymentPeriod?: IntWithAggregatesFilter<"LoanApplication"> | number
    status?: EnumLoanApplicationStatusWithAggregatesFilter<"LoanApplication"> | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeWithAggregatesFilter<"LoanApplication"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"LoanApplication"> | Date | string | null
    reviewedById?: StringNullableWithAggregatesFilter<"LoanApplication"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"LoanApplication"> | Date | string | null
    approvedById?: StringNullableWithAggregatesFilter<"LoanApplication"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"LoanApplication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoanApplication"> | Date | string
  }

  export type LoanQualificationWhereInput = {
    AND?: LoanQualificationWhereInput | LoanQualificationWhereInput[]
    OR?: LoanQualificationWhereInput[]
    NOT?: LoanQualificationWhereInput | LoanQualificationWhereInput[]
    id?: StringFilter<"LoanQualification"> | string
    loanId?: StringFilter<"LoanQualification"> | string
    avgIncome?: DecimalFilter<"LoanQualification"> | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFilter<"LoanQualification"> | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFilter<"LoanQualification"> | $Enums.QualificationType
    createdAt?: DateTimeFilter<"LoanQualification"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type LoanQualificationOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    avgIncome?: SortOrder
    eligibilityAmount?: SortOrder
    ruleApplied?: SortOrder
    createdAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type LoanQualificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanId?: string
    AND?: LoanQualificationWhereInput | LoanQualificationWhereInput[]
    OR?: LoanQualificationWhereInput[]
    NOT?: LoanQualificationWhereInput | LoanQualificationWhereInput[]
    avgIncome?: DecimalFilter<"LoanQualification"> | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFilter<"LoanQualification"> | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFilter<"LoanQualification"> | $Enums.QualificationType
    createdAt?: DateTimeFilter<"LoanQualification"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id" | "loanId">

  export type LoanQualificationOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    avgIncome?: SortOrder
    eligibilityAmount?: SortOrder
    ruleApplied?: SortOrder
    createdAt?: SortOrder
    _count?: LoanQualificationCountOrderByAggregateInput
    _avg?: LoanQualificationAvgOrderByAggregateInput
    _max?: LoanQualificationMaxOrderByAggregateInput
    _min?: LoanQualificationMinOrderByAggregateInput
    _sum?: LoanQualificationSumOrderByAggregateInput
  }

  export type LoanQualificationScalarWhereWithAggregatesInput = {
    AND?: LoanQualificationScalarWhereWithAggregatesInput | LoanQualificationScalarWhereWithAggregatesInput[]
    OR?: LoanQualificationScalarWhereWithAggregatesInput[]
    NOT?: LoanQualificationScalarWhereWithAggregatesInput | LoanQualificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanQualification"> | string
    loanId?: StringWithAggregatesFilter<"LoanQualification"> | string
    avgIncome?: DecimalWithAggregatesFilter<"LoanQualification"> | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalWithAggregatesFilter<"LoanQualification"> | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeWithAggregatesFilter<"LoanQualification"> | $Enums.QualificationType
    createdAt?: DateTimeWithAggregatesFilter<"LoanQualification"> | Date | string
  }

  export type LoanSecurityWhereInput = {
    AND?: LoanSecurityWhereInput | LoanSecurityWhereInput[]
    OR?: LoanSecurityWhereInput[]
    NOT?: LoanSecurityWhereInput | LoanSecurityWhereInput[]
    id?: StringFilter<"LoanSecurity"> | string
    loanId?: StringFilter<"LoanSecurity"> | string
    idCopy?: BoolFilter<"LoanSecurity"> | boolean
    passportPhoto?: BoolFilter<"LoanSecurity"> | boolean
    appointmentLetter?: BoolFilter<"LoanSecurity"> | boolean
    payslips?: BoolFilter<"LoanSecurity"> | boolean
    bankStatement?: BoolFilter<"LoanSecurity"> | boolean
    chequeLeafNo?: StringNullableFilter<"LoanSecurity"> | string | null
    createdAt?: DateTimeFilter<"LoanSecurity"> | Date | string
    updatedAt?: DateTimeFilter<"LoanSecurity"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type LoanSecurityOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    idCopy?: SortOrder
    passportPhoto?: SortOrder
    appointmentLetter?: SortOrder
    payslips?: SortOrder
    bankStatement?: SortOrder
    chequeLeafNo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type LoanSecurityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanId?: string
    AND?: LoanSecurityWhereInput | LoanSecurityWhereInput[]
    OR?: LoanSecurityWhereInput[]
    NOT?: LoanSecurityWhereInput | LoanSecurityWhereInput[]
    idCopy?: BoolFilter<"LoanSecurity"> | boolean
    passportPhoto?: BoolFilter<"LoanSecurity"> | boolean
    appointmentLetter?: BoolFilter<"LoanSecurity"> | boolean
    payslips?: BoolFilter<"LoanSecurity"> | boolean
    bankStatement?: BoolFilter<"LoanSecurity"> | boolean
    chequeLeafNo?: StringNullableFilter<"LoanSecurity"> | string | null
    createdAt?: DateTimeFilter<"LoanSecurity"> | Date | string
    updatedAt?: DateTimeFilter<"LoanSecurity"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id" | "loanId">

  export type LoanSecurityOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    idCopy?: SortOrder
    passportPhoto?: SortOrder
    appointmentLetter?: SortOrder
    payslips?: SortOrder
    bankStatement?: SortOrder
    chequeLeafNo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanSecurityCountOrderByAggregateInput
    _max?: LoanSecurityMaxOrderByAggregateInput
    _min?: LoanSecurityMinOrderByAggregateInput
  }

  export type LoanSecurityScalarWhereWithAggregatesInput = {
    AND?: LoanSecurityScalarWhereWithAggregatesInput | LoanSecurityScalarWhereWithAggregatesInput[]
    OR?: LoanSecurityScalarWhereWithAggregatesInput[]
    NOT?: LoanSecurityScalarWhereWithAggregatesInput | LoanSecurityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanSecurity"> | string
    loanId?: StringWithAggregatesFilter<"LoanSecurity"> | string
    idCopy?: BoolWithAggregatesFilter<"LoanSecurity"> | boolean
    passportPhoto?: BoolWithAggregatesFilter<"LoanSecurity"> | boolean
    appointmentLetter?: BoolWithAggregatesFilter<"LoanSecurity"> | boolean
    payslips?: BoolWithAggregatesFilter<"LoanSecurity"> | boolean
    bankStatement?: BoolWithAggregatesFilter<"LoanSecurity"> | boolean
    chequeLeafNo?: StringNullableWithAggregatesFilter<"LoanSecurity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoanSecurity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoanSecurity"> | Date | string
  }

  export type VehicleSecurityWhereInput = {
    AND?: VehicleSecurityWhereInput | VehicleSecurityWhereInput[]
    OR?: VehicleSecurityWhereInput[]
    NOT?: VehicleSecurityWhereInput | VehicleSecurityWhereInput[]
    id?: StringFilter<"VehicleSecurity"> | string
    loanId?: StringFilter<"VehicleSecurity"> | string
    registrationNumber?: StringFilter<"VehicleSecurity"> | string
    chassisNumber?: StringFilter<"VehicleSecurity"> | string
    engineNumber?: StringFilter<"VehicleSecurity"> | string
    yearOfManufacture?: IntFilter<"VehicleSecurity"> | number
    make?: StringFilter<"VehicleSecurity"> | string
    model?: StringFilter<"VehicleSecurity"> | string
    bodyColor?: StringFilter<"VehicleSecurity"> | string
    createdAt?: DateTimeFilter<"VehicleSecurity"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleSecurity"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type VehicleSecurityOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    registrationNumber?: SortOrder
    chassisNumber?: SortOrder
    engineNumber?: SortOrder
    yearOfManufacture?: SortOrder
    make?: SortOrder
    model?: SortOrder
    bodyColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type VehicleSecurityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanId?: string
    AND?: VehicleSecurityWhereInput | VehicleSecurityWhereInput[]
    OR?: VehicleSecurityWhereInput[]
    NOT?: VehicleSecurityWhereInput | VehicleSecurityWhereInput[]
    registrationNumber?: StringFilter<"VehicleSecurity"> | string
    chassisNumber?: StringFilter<"VehicleSecurity"> | string
    engineNumber?: StringFilter<"VehicleSecurity"> | string
    yearOfManufacture?: IntFilter<"VehicleSecurity"> | number
    make?: StringFilter<"VehicleSecurity"> | string
    model?: StringFilter<"VehicleSecurity"> | string
    bodyColor?: StringFilter<"VehicleSecurity"> | string
    createdAt?: DateTimeFilter<"VehicleSecurity"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleSecurity"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id" | "loanId">

  export type VehicleSecurityOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    registrationNumber?: SortOrder
    chassisNumber?: SortOrder
    engineNumber?: SortOrder
    yearOfManufacture?: SortOrder
    make?: SortOrder
    model?: SortOrder
    bodyColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleSecurityCountOrderByAggregateInput
    _avg?: VehicleSecurityAvgOrderByAggregateInput
    _max?: VehicleSecurityMaxOrderByAggregateInput
    _min?: VehicleSecurityMinOrderByAggregateInput
    _sum?: VehicleSecuritySumOrderByAggregateInput
  }

  export type VehicleSecurityScalarWhereWithAggregatesInput = {
    AND?: VehicleSecurityScalarWhereWithAggregatesInput | VehicleSecurityScalarWhereWithAggregatesInput[]
    OR?: VehicleSecurityScalarWhereWithAggregatesInput[]
    NOT?: VehicleSecurityScalarWhereWithAggregatesInput | VehicleSecurityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    loanId?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    registrationNumber?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    chassisNumber?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    engineNumber?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    yearOfManufacture?: IntWithAggregatesFilter<"VehicleSecurity"> | number
    make?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    model?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    bodyColor?: StringWithAggregatesFilter<"VehicleSecurity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VehicleSecurity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VehicleSecurity"> | Date | string
  }

  export type GuarantorWhereInput = {
    AND?: GuarantorWhereInput | GuarantorWhereInput[]
    OR?: GuarantorWhereInput[]
    NOT?: GuarantorWhereInput | GuarantorWhereInput[]
    id?: StringFilter<"Guarantor"> | string
    loanId?: StringFilter<"Guarantor"> | string
    fullName?: StringFilter<"Guarantor"> | string
    phone?: StringFilter<"Guarantor"> | string
    email?: StringNullableFilter<"Guarantor"> | string | null
    idNumber?: StringNullableFilter<"Guarantor"> | string | null
    relationship?: StringNullableFilter<"Guarantor"> | string | null
    confirmationStatus?: EnumGuarantorStatusFilter<"Guarantor"> | $Enums.GuarantorStatus
    confirmedAt?: DateTimeNullableFilter<"Guarantor"> | Date | string | null
    createdAt?: DateTimeFilter<"Guarantor"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type GuarantorOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    confirmationStatus?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type GuarantorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuarantorWhereInput | GuarantorWhereInput[]
    OR?: GuarantorWhereInput[]
    NOT?: GuarantorWhereInput | GuarantorWhereInput[]
    loanId?: StringFilter<"Guarantor"> | string
    fullName?: StringFilter<"Guarantor"> | string
    phone?: StringFilter<"Guarantor"> | string
    email?: StringNullableFilter<"Guarantor"> | string | null
    idNumber?: StringNullableFilter<"Guarantor"> | string | null
    relationship?: StringNullableFilter<"Guarantor"> | string | null
    confirmationStatus?: EnumGuarantorStatusFilter<"Guarantor"> | $Enums.GuarantorStatus
    confirmedAt?: DateTimeNullableFilter<"Guarantor"> | Date | string | null
    createdAt?: DateTimeFilter<"Guarantor"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id">

  export type GuarantorOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    confirmationStatus?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GuarantorCountOrderByAggregateInput
    _max?: GuarantorMaxOrderByAggregateInput
    _min?: GuarantorMinOrderByAggregateInput
  }

  export type GuarantorScalarWhereWithAggregatesInput = {
    AND?: GuarantorScalarWhereWithAggregatesInput | GuarantorScalarWhereWithAggregatesInput[]
    OR?: GuarantorScalarWhereWithAggregatesInput[]
    NOT?: GuarantorScalarWhereWithAggregatesInput | GuarantorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guarantor"> | string
    loanId?: StringWithAggregatesFilter<"Guarantor"> | string
    fullName?: StringWithAggregatesFilter<"Guarantor"> | string
    phone?: StringWithAggregatesFilter<"Guarantor"> | string
    email?: StringNullableWithAggregatesFilter<"Guarantor"> | string | null
    idNumber?: StringNullableWithAggregatesFilter<"Guarantor"> | string | null
    relationship?: StringNullableWithAggregatesFilter<"Guarantor"> | string | null
    confirmationStatus?: EnumGuarantorStatusWithAggregatesFilter<"Guarantor"> | $Enums.GuarantorStatus
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"Guarantor"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Guarantor"> | Date | string
  }

  export type LoanDisbursementWhereInput = {
    AND?: LoanDisbursementWhereInput | LoanDisbursementWhereInput[]
    OR?: LoanDisbursementWhereInput[]
    NOT?: LoanDisbursementWhereInput | LoanDisbursementWhereInput[]
    id?: StringFilter<"LoanDisbursement"> | string
    loanId?: StringFilter<"LoanDisbursement"> | string
    amount?: DecimalFilter<"LoanDisbursement"> | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFilter<"LoanDisbursement"> | $Enums.DisbursementMethod
    reference?: StringNullableFilter<"LoanDisbursement"> | string | null
    disbursedAt?: DateTimeFilter<"LoanDisbursement"> | Date | string
    createdAt?: DateTimeFilter<"LoanDisbursement"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type LoanDisbursementOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    disbursedAt?: SortOrder
    createdAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type LoanDisbursementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanId?: string
    AND?: LoanDisbursementWhereInput | LoanDisbursementWhereInput[]
    OR?: LoanDisbursementWhereInput[]
    NOT?: LoanDisbursementWhereInput | LoanDisbursementWhereInput[]
    amount?: DecimalFilter<"LoanDisbursement"> | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFilter<"LoanDisbursement"> | $Enums.DisbursementMethod
    reference?: StringNullableFilter<"LoanDisbursement"> | string | null
    disbursedAt?: DateTimeFilter<"LoanDisbursement"> | Date | string
    createdAt?: DateTimeFilter<"LoanDisbursement"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id" | "loanId">

  export type LoanDisbursementOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    disbursedAt?: SortOrder
    createdAt?: SortOrder
    _count?: LoanDisbursementCountOrderByAggregateInput
    _avg?: LoanDisbursementAvgOrderByAggregateInput
    _max?: LoanDisbursementMaxOrderByAggregateInput
    _min?: LoanDisbursementMinOrderByAggregateInput
    _sum?: LoanDisbursementSumOrderByAggregateInput
  }

  export type LoanDisbursementScalarWhereWithAggregatesInput = {
    AND?: LoanDisbursementScalarWhereWithAggregatesInput | LoanDisbursementScalarWhereWithAggregatesInput[]
    OR?: LoanDisbursementScalarWhereWithAggregatesInput[]
    NOT?: LoanDisbursementScalarWhereWithAggregatesInput | LoanDisbursementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanDisbursement"> | string
    loanId?: StringWithAggregatesFilter<"LoanDisbursement"> | string
    amount?: DecimalWithAggregatesFilter<"LoanDisbursement"> | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodWithAggregatesFilter<"LoanDisbursement"> | $Enums.DisbursementMethod
    reference?: StringNullableWithAggregatesFilter<"LoanDisbursement"> | string | null
    disbursedAt?: DateTimeWithAggregatesFilter<"LoanDisbursement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"LoanDisbursement"> | Date | string
  }

  export type LoanFinancialWhereInput = {
    AND?: LoanFinancialWhereInput | LoanFinancialWhereInput[]
    OR?: LoanFinancialWhereInput[]
    NOT?: LoanFinancialWhereInput | LoanFinancialWhereInput[]
    id?: StringFilter<"LoanFinancial"> | string
    loanId?: StringFilter<"LoanFinancial"> | string
    processingFee?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LoanFinancial"> | Date | string
    updatedAt?: DateTimeFilter<"LoanFinancial"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type LoanFinancialOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    processingFee?: SortOrder
    legalFee?: SortOrder
    penaltyFee?: SortOrder
    interestAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type LoanFinancialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanId?: string
    AND?: LoanFinancialWhereInput | LoanFinancialWhereInput[]
    OR?: LoanFinancialWhereInput[]
    NOT?: LoanFinancialWhereInput | LoanFinancialWhereInput[]
    processingFee?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LoanFinancial"> | Date | string
    updatedAt?: DateTimeFilter<"LoanFinancial"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id" | "loanId">

  export type LoanFinancialOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    processingFee?: SortOrder
    legalFee?: SortOrder
    penaltyFee?: SortOrder
    interestAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanFinancialCountOrderByAggregateInput
    _avg?: LoanFinancialAvgOrderByAggregateInput
    _max?: LoanFinancialMaxOrderByAggregateInput
    _min?: LoanFinancialMinOrderByAggregateInput
    _sum?: LoanFinancialSumOrderByAggregateInput
  }

  export type LoanFinancialScalarWhereWithAggregatesInput = {
    AND?: LoanFinancialScalarWhereWithAggregatesInput | LoanFinancialScalarWhereWithAggregatesInput[]
    OR?: LoanFinancialScalarWhereWithAggregatesInput[]
    NOT?: LoanFinancialScalarWhereWithAggregatesInput | LoanFinancialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanFinancial"> | string
    loanId?: StringWithAggregatesFilter<"LoanFinancial"> | string
    processingFee?: DecimalWithAggregatesFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalWithAggregatesFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalWithAggregatesFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalWithAggregatesFilter<"LoanFinancial"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"LoanFinancial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoanFinancial"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    loanId?: StringFilter<"Invoice"> | string
    invoiceType?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedBy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    items?: InvoiceItemListRelationFilter
    payments?: InvoicePaymentListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    issuedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: InvoiceItemOrderByRelationAggregateInput
    payments?: InvoicePaymentOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    clientId?: StringFilter<"Invoice"> | string
    loanId?: StringFilter<"Invoice"> | string
    invoiceType?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedBy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    items?: InvoiceItemListRelationFilter
    payments?: InvoicePaymentListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    issuedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    clientId?: StringWithAggregatesFilter<"Invoice"> | string
    loanId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceType?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedBy?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    chargeType?: EnumChargeTypeFilter<"InvoiceItem"> | $Enums.ChargeType
    description?: StringNullableFilter<"InvoiceItem"> | string | null
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    glAccount?: StringNullableFilter<"InvoiceItem"> | string | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    chargeType?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    glAccount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    chargeType?: EnumChargeTypeFilter<"InvoiceItem"> | $Enums.ChargeType
    description?: StringNullableFilter<"InvoiceItem"> | string | null
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    glAccount?: StringNullableFilter<"InvoiceItem"> | string | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    chargeType?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    glAccount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    chargeType?: EnumChargeTypeWithAggregatesFilter<"InvoiceItem"> | $Enums.ChargeType
    description?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    amount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    glAccount?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
  }

  export type InvoicePaymentWhereInput = {
    AND?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    OR?: InvoicePaymentWhereInput[]
    NOT?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    id?: StringFilter<"InvoicePayment"> | string
    invoiceId?: StringFilter<"InvoicePayment"> | string
    transactionId?: StringNullableFilter<"InvoicePayment"> | string | null
    amountPaid?: DecimalFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"InvoicePayment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"InvoicePayment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type InvoicePaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type InvoicePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    OR?: InvoicePaymentWhereInput[]
    NOT?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    invoiceId?: StringFilter<"InvoicePayment"> | string
    transactionId?: StringNullableFilter<"InvoicePayment"> | string | null
    amountPaid?: DecimalFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"InvoicePayment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"InvoicePayment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id">

  export type InvoicePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    _count?: InvoicePaymentCountOrderByAggregateInput
    _avg?: InvoicePaymentAvgOrderByAggregateInput
    _max?: InvoicePaymentMaxOrderByAggregateInput
    _min?: InvoicePaymentMinOrderByAggregateInput
    _sum?: InvoicePaymentSumOrderByAggregateInput
  }

  export type InvoicePaymentScalarWhereWithAggregatesInput = {
    AND?: InvoicePaymentScalarWhereWithAggregatesInput | InvoicePaymentScalarWhereWithAggregatesInput[]
    OR?: InvoicePaymentScalarWhereWithAggregatesInput[]
    NOT?: InvoicePaymentScalarWhereWithAggregatesInput | InvoicePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoicePayment"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoicePayment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    amountPaid?: DecimalWithAggregatesFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeWithAggregatesFilter<"InvoicePayment"> | Date | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"InvoicePayment"> | $Enums.PaymentMethod
    createdAt?: DateTimeWithAggregatesFilter<"InvoicePayment"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    transactionCode?: StringFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFilter<"Transaction"> | $Enums.ReferenceType
    referenceId?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFilter<"Transaction"> | string
    creditAccount?: StringFilter<"Transaction"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    invoicePayments?: InvoicePaymentListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionCode?: SortOrder
    transactionType?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    debitAccount?: SortOrder
    creditAccount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    invoicePayments?: InvoicePaymentOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionCode?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFilter<"Transaction"> | $Enums.ReferenceType
    referenceId?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFilter<"Transaction"> | string
    creditAccount?: StringFilter<"Transaction"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    invoicePayments?: InvoicePaymentListRelationFilter
  }, "id" | "transactionCode">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionCode?: SortOrder
    transactionType?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    debitAccount?: SortOrder
    creditAccount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    transactionCode?: StringWithAggregatesFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    referenceType?: EnumReferenceTypeWithAggregatesFilter<"Transaction"> | $Enums.ReferenceType
    referenceId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    debitAccount?: StringWithAggregatesFilter<"Transaction"> | string
    creditAccount?: StringWithAggregatesFilter<"Transaction"> | string
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod | null
    transactionDate?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    createdBy?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type RepaymentWhereInput = {
    AND?: RepaymentWhereInput | RepaymentWhereInput[]
    OR?: RepaymentWhereInput[]
    NOT?: RepaymentWhereInput | RepaymentWhereInput[]
    id?: StringFilter<"Repayment"> | string
    loanId?: StringFilter<"Repayment"> | string
    amount?: DecimalFilter<"Repayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Repayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"Repayment"> | Date | string
    category?: EnumRepaymentCategoryFilter<"Repayment"> | $Enums.RepaymentCategory
    reference?: StringNullableFilter<"Repayment"> | string | null
    createdAt?: DateTimeFilter<"Repayment"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type RepaymentOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    category?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type RepaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RepaymentWhereInput | RepaymentWhereInput[]
    OR?: RepaymentWhereInput[]
    NOT?: RepaymentWhereInput | RepaymentWhereInput[]
    loanId?: StringFilter<"Repayment"> | string
    amount?: DecimalFilter<"Repayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Repayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"Repayment"> | Date | string
    category?: EnumRepaymentCategoryFilter<"Repayment"> | $Enums.RepaymentCategory
    reference?: StringNullableFilter<"Repayment"> | string | null
    createdAt?: DateTimeFilter<"Repayment"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id">

  export type RepaymentOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    category?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RepaymentCountOrderByAggregateInput
    _avg?: RepaymentAvgOrderByAggregateInput
    _max?: RepaymentMaxOrderByAggregateInput
    _min?: RepaymentMinOrderByAggregateInput
    _sum?: RepaymentSumOrderByAggregateInput
  }

  export type RepaymentScalarWhereWithAggregatesInput = {
    AND?: RepaymentScalarWhereWithAggregatesInput | RepaymentScalarWhereWithAggregatesInput[]
    OR?: RepaymentScalarWhereWithAggregatesInput[]
    NOT?: RepaymentScalarWhereWithAggregatesInput | RepaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Repayment"> | string
    loanId?: StringWithAggregatesFilter<"Repayment"> | string
    amount?: DecimalWithAggregatesFilter<"Repayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Repayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeWithAggregatesFilter<"Repayment"> | Date | string
    category?: EnumRepaymentCategoryWithAggregatesFilter<"Repayment"> | $Enums.RepaymentCategory
    reference?: StringNullableWithAggregatesFilter<"Repayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Repayment"> | Date | string
  }

  export type NonPerformingLoanWhereInput = {
    AND?: NonPerformingLoanWhereInput | NonPerformingLoanWhereInput[]
    OR?: NonPerformingLoanWhereInput[]
    NOT?: NonPerformingLoanWhereInput | NonPerformingLoanWhereInput[]
    id?: StringFilter<"NonPerformingLoan"> | string
    loanId?: StringFilter<"NonPerformingLoan"> | string
    capitalizedAmount?: DecimalFilter<"NonPerformingLoan"> | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFilter<"NonPerformingLoan"> | Date | string
    createdAt?: DateTimeFilter<"NonPerformingLoan"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type NonPerformingLoanOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    capitalizedAmount?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type NonPerformingLoanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanId?: string
    AND?: NonPerformingLoanWhereInput | NonPerformingLoanWhereInput[]
    OR?: NonPerformingLoanWhereInput[]
    NOT?: NonPerformingLoanWhereInput | NonPerformingLoanWhereInput[]
    capitalizedAmount?: DecimalFilter<"NonPerformingLoan"> | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFilter<"NonPerformingLoan"> | Date | string
    createdAt?: DateTimeFilter<"NonPerformingLoan"> | Date | string
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id" | "loanId">

  export type NonPerformingLoanOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    capitalizedAmount?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
    _count?: NonPerformingLoanCountOrderByAggregateInput
    _avg?: NonPerformingLoanAvgOrderByAggregateInput
    _max?: NonPerformingLoanMaxOrderByAggregateInput
    _min?: NonPerformingLoanMinOrderByAggregateInput
    _sum?: NonPerformingLoanSumOrderByAggregateInput
  }

  export type NonPerformingLoanScalarWhereWithAggregatesInput = {
    AND?: NonPerformingLoanScalarWhereWithAggregatesInput | NonPerformingLoanScalarWhereWithAggregatesInput[]
    OR?: NonPerformingLoanScalarWhereWithAggregatesInput[]
    NOT?: NonPerformingLoanScalarWhereWithAggregatesInput | NonPerformingLoanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NonPerformingLoan"> | string
    loanId?: StringWithAggregatesFilter<"NonPerformingLoan"> | string
    capitalizedAmount?: DecimalWithAggregatesFilter<"NonPerformingLoan"> | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeWithAggregatesFilter<"NonPerformingLoan"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"NonPerformingLoan"> | Date | string
  }

  export type RecoveryAgentWhereInput = {
    AND?: RecoveryAgentWhereInput | RecoveryAgentWhereInput[]
    OR?: RecoveryAgentWhereInput[]
    NOT?: RecoveryAgentWhereInput | RecoveryAgentWhereInput[]
    id?: StringFilter<"RecoveryAgent"> | string
    userId?: StringNullableFilter<"RecoveryAgent"> | string | null
    name?: StringFilter<"RecoveryAgent"> | string
    phone?: StringFilter<"RecoveryAgent"> | string
    email?: StringNullableFilter<"RecoveryAgent"> | string | null
    isActive?: BoolFilter<"RecoveryAgent"> | boolean
    createdAt?: DateTimeFilter<"RecoveryAgent"> | Date | string
    updatedAt?: DateTimeFilter<"RecoveryAgent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    records?: RecoveryRecordListRelationFilter
  }

  export type RecoveryAgentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    records?: RecoveryRecordOrderByRelationAggregateInput
  }

  export type RecoveryAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: RecoveryAgentWhereInput | RecoveryAgentWhereInput[]
    OR?: RecoveryAgentWhereInput[]
    NOT?: RecoveryAgentWhereInput | RecoveryAgentWhereInput[]
    name?: StringFilter<"RecoveryAgent"> | string
    phone?: StringFilter<"RecoveryAgent"> | string
    email?: StringNullableFilter<"RecoveryAgent"> | string | null
    isActive?: BoolFilter<"RecoveryAgent"> | boolean
    createdAt?: DateTimeFilter<"RecoveryAgent"> | Date | string
    updatedAt?: DateTimeFilter<"RecoveryAgent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    records?: RecoveryRecordListRelationFilter
  }, "id" | "userId">

  export type RecoveryAgentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecoveryAgentCountOrderByAggregateInput
    _max?: RecoveryAgentMaxOrderByAggregateInput
    _min?: RecoveryAgentMinOrderByAggregateInput
  }

  export type RecoveryAgentScalarWhereWithAggregatesInput = {
    AND?: RecoveryAgentScalarWhereWithAggregatesInput | RecoveryAgentScalarWhereWithAggregatesInput[]
    OR?: RecoveryAgentScalarWhereWithAggregatesInput[]
    NOT?: RecoveryAgentScalarWhereWithAggregatesInput | RecoveryAgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecoveryAgent"> | string
    userId?: StringNullableWithAggregatesFilter<"RecoveryAgent"> | string | null
    name?: StringWithAggregatesFilter<"RecoveryAgent"> | string
    phone?: StringWithAggregatesFilter<"RecoveryAgent"> | string
    email?: StringNullableWithAggregatesFilter<"RecoveryAgent"> | string | null
    isActive?: BoolWithAggregatesFilter<"RecoveryAgent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RecoveryAgent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecoveryAgent"> | Date | string
  }

  export type RecoveryRecordWhereInput = {
    AND?: RecoveryRecordWhereInput | RecoveryRecordWhereInput[]
    OR?: RecoveryRecordWhereInput[]
    NOT?: RecoveryRecordWhereInput | RecoveryRecordWhereInput[]
    id?: StringFilter<"RecoveryRecord"> | string
    loanId?: StringFilter<"RecoveryRecord"> | string
    agentId?: StringFilter<"RecoveryRecord"> | string
    actionTaken?: StringFilter<"RecoveryRecord"> | string
    outcome?: StringNullableFilter<"RecoveryRecord"> | string | null
    recordedAt?: DateTimeFilter<"RecoveryRecord"> | Date | string
    createdAt?: DateTimeFilter<"RecoveryRecord"> | Date | string
    agent?: XOR<RecoveryAgentScalarRelationFilter, RecoveryAgentWhereInput>
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type RecoveryRecordOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    agentId?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    agent?: RecoveryAgentOrderByWithRelationInput
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type RecoveryRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecoveryRecordWhereInput | RecoveryRecordWhereInput[]
    OR?: RecoveryRecordWhereInput[]
    NOT?: RecoveryRecordWhereInput | RecoveryRecordWhereInput[]
    loanId?: StringFilter<"RecoveryRecord"> | string
    agentId?: StringFilter<"RecoveryRecord"> | string
    actionTaken?: StringFilter<"RecoveryRecord"> | string
    outcome?: StringNullableFilter<"RecoveryRecord"> | string | null
    recordedAt?: DateTimeFilter<"RecoveryRecord"> | Date | string
    createdAt?: DateTimeFilter<"RecoveryRecord"> | Date | string
    agent?: XOR<RecoveryAgentScalarRelationFilter, RecoveryAgentWhereInput>
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id">

  export type RecoveryRecordOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    agentId?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    _count?: RecoveryRecordCountOrderByAggregateInput
    _max?: RecoveryRecordMaxOrderByAggregateInput
    _min?: RecoveryRecordMinOrderByAggregateInput
  }

  export type RecoveryRecordScalarWhereWithAggregatesInput = {
    AND?: RecoveryRecordScalarWhereWithAggregatesInput | RecoveryRecordScalarWhereWithAggregatesInput[]
    OR?: RecoveryRecordScalarWhereWithAggregatesInput[]
    NOT?: RecoveryRecordScalarWhereWithAggregatesInput | RecoveryRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecoveryRecord"> | string
    loanId?: StringWithAggregatesFilter<"RecoveryRecord"> | string
    agentId?: StringWithAggregatesFilter<"RecoveryRecord"> | string
    actionTaken?: StringWithAggregatesFilter<"RecoveryRecord"> | string
    outcome?: StringNullableWithAggregatesFilter<"RecoveryRecord"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"RecoveryRecord"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RecoveryRecord"> | Date | string
  }

  export type InvestorWhereInput = {
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    id?: StringFilter<"Investor"> | string
    userId?: StringNullableFilter<"Investor"> | string | null
    name?: StringFilter<"Investor"> | string
    contact?: StringFilter<"Investor"> | string
    email?: StringNullableFilter<"Investor"> | string | null
    investedAmount?: DecimalFilter<"Investor"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    allocations?: InvestorAllocationListRelationFilter
    payouts?: InvestorPayoutListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InvestorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    investedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    allocations?: InvestorAllocationOrderByRelationAggregateInput
    payouts?: InvestorPayoutOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type InvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    name?: StringFilter<"Investor"> | string
    contact?: StringFilter<"Investor"> | string
    email?: StringNullableFilter<"Investor"> | string | null
    investedAmount?: DecimalFilter<"Investor"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    allocations?: InvestorAllocationListRelationFilter
    payouts?: InvestorPayoutListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "userId">

  export type InvestorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    investedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorCountOrderByAggregateInput
    _avg?: InvestorAvgOrderByAggregateInput
    _max?: InvestorMaxOrderByAggregateInput
    _min?: InvestorMinOrderByAggregateInput
    _sum?: InvestorSumOrderByAggregateInput
  }

  export type InvestorScalarWhereWithAggregatesInput = {
    AND?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    OR?: InvestorScalarWhereWithAggregatesInput[]
    NOT?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investor"> | string
    userId?: StringNullableWithAggregatesFilter<"Investor"> | string | null
    name?: StringWithAggregatesFilter<"Investor"> | string
    contact?: StringWithAggregatesFilter<"Investor"> | string
    email?: StringNullableWithAggregatesFilter<"Investor"> | string | null
    investedAmount?: DecimalWithAggregatesFilter<"Investor"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
  }

  export type InvestorAllocationWhereInput = {
    AND?: InvestorAllocationWhereInput | InvestorAllocationWhereInput[]
    OR?: InvestorAllocationWhereInput[]
    NOT?: InvestorAllocationWhereInput | InvestorAllocationWhereInput[]
    id?: StringFilter<"InvestorAllocation"> | string
    investorId?: StringFilter<"InvestorAllocation"> | string
    loanId?: StringFilter<"InvestorAllocation"> | string
    allocatedAmount?: DecimalFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    expectedReturn?: DecimalNullableFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFilter<"InvestorAllocation"> | Date | string
    createdAt?: DateTimeFilter<"InvestorAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorAllocation"> | Date | string
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }

  export type InvestorAllocationOrderByWithRelationInput = {
    id?: SortOrder
    investorId?: SortOrder
    loanId?: SortOrder
    allocatedAmount?: SortOrder
    expectedReturn?: SortOrderInput | SortOrder
    actualReturn?: SortOrder
    allocationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    investor?: InvestorOrderByWithRelationInput
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type InvestorAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestorAllocationWhereInput | InvestorAllocationWhereInput[]
    OR?: InvestorAllocationWhereInput[]
    NOT?: InvestorAllocationWhereInput | InvestorAllocationWhereInput[]
    investorId?: StringFilter<"InvestorAllocation"> | string
    loanId?: StringFilter<"InvestorAllocation"> | string
    allocatedAmount?: DecimalFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    expectedReturn?: DecimalNullableFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFilter<"InvestorAllocation"> | Date | string
    createdAt?: DateTimeFilter<"InvestorAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorAllocation"> | Date | string
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
    loan?: XOR<LoanApplicationScalarRelationFilter, LoanApplicationWhereInput>
  }, "id">

  export type InvestorAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    investorId?: SortOrder
    loanId?: SortOrder
    allocatedAmount?: SortOrder
    expectedReturn?: SortOrderInput | SortOrder
    actualReturn?: SortOrder
    allocationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorAllocationCountOrderByAggregateInput
    _avg?: InvestorAllocationAvgOrderByAggregateInput
    _max?: InvestorAllocationMaxOrderByAggregateInput
    _min?: InvestorAllocationMinOrderByAggregateInput
    _sum?: InvestorAllocationSumOrderByAggregateInput
  }

  export type InvestorAllocationScalarWhereWithAggregatesInput = {
    AND?: InvestorAllocationScalarWhereWithAggregatesInput | InvestorAllocationScalarWhereWithAggregatesInput[]
    OR?: InvestorAllocationScalarWhereWithAggregatesInput[]
    NOT?: InvestorAllocationScalarWhereWithAggregatesInput | InvestorAllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestorAllocation"> | string
    investorId?: StringWithAggregatesFilter<"InvestorAllocation"> | string
    loanId?: StringWithAggregatesFilter<"InvestorAllocation"> | string
    allocatedAmount?: DecimalWithAggregatesFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    expectedReturn?: DecimalNullableWithAggregatesFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalWithAggregatesFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeWithAggregatesFilter<"InvestorAllocation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"InvestorAllocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvestorAllocation"> | Date | string
  }

  export type InvestorPayoutWhereInput = {
    AND?: InvestorPayoutWhereInput | InvestorPayoutWhereInput[]
    OR?: InvestorPayoutWhereInput[]
    NOT?: InvestorPayoutWhereInput | InvestorPayoutWhereInput[]
    id?: StringFilter<"InvestorPayout"> | string
    investorId?: StringFilter<"InvestorPayout"> | string
    amount?: DecimalFilter<"InvestorPayout"> | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFilter<"InvestorPayout"> | Date | string
    reference?: StringNullableFilter<"InvestorPayout"> | string | null
    createdAt?: DateTimeFilter<"InvestorPayout"> | Date | string
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
  }

  export type InvestorPayoutOrderByWithRelationInput = {
    id?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    payoutDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    investor?: InvestorOrderByWithRelationInput
  }

  export type InvestorPayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestorPayoutWhereInput | InvestorPayoutWhereInput[]
    OR?: InvestorPayoutWhereInput[]
    NOT?: InvestorPayoutWhereInput | InvestorPayoutWhereInput[]
    investorId?: StringFilter<"InvestorPayout"> | string
    amount?: DecimalFilter<"InvestorPayout"> | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFilter<"InvestorPayout"> | Date | string
    reference?: StringNullableFilter<"InvestorPayout"> | string | null
    createdAt?: DateTimeFilter<"InvestorPayout"> | Date | string
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
  }, "id">

  export type InvestorPayoutOrderByWithAggregationInput = {
    id?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    payoutDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvestorPayoutCountOrderByAggregateInput
    _avg?: InvestorPayoutAvgOrderByAggregateInput
    _max?: InvestorPayoutMaxOrderByAggregateInput
    _min?: InvestorPayoutMinOrderByAggregateInput
    _sum?: InvestorPayoutSumOrderByAggregateInput
  }

  export type InvestorPayoutScalarWhereWithAggregatesInput = {
    AND?: InvestorPayoutScalarWhereWithAggregatesInput | InvestorPayoutScalarWhereWithAggregatesInput[]
    OR?: InvestorPayoutScalarWhereWithAggregatesInput[]
    NOT?: InvestorPayoutScalarWhereWithAggregatesInput | InvestorPayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestorPayout"> | string
    investorId?: StringWithAggregatesFilter<"InvestorPayout"> | string
    amount?: DecimalWithAggregatesFilter<"InvestorPayout"> | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeWithAggregatesFilter<"InvestorPayout"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"InvestorPayout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvestorPayout"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    clientId?: StringNullableFilter<"Document"> | string | null
    loanId?: StringNullableFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    filePublicId?: StringFilter<"Document"> | string
    fileUniqueId?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    loan?: XOR<LoanApplicationNullableScalarRelationFilter, LoanApplicationWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    loanId?: SortOrderInput | SortOrder
    documentType?: SortOrder
    filePublicId?: SortOrder
    fileUniqueId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    loan?: LoanApplicationOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    clientId?: StringNullableFilter<"Document"> | string | null
    loanId?: StringNullableFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    filePublicId?: StringFilter<"Document"> | string
    fileUniqueId?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    loan?: XOR<LoanApplicationNullableScalarRelationFilter, LoanApplicationWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    loanId?: SortOrderInput | SortOrder
    documentType?: SortOrder
    filePublicId?: SortOrder
    fileUniqueId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    clientId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    loanId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    filePublicId?: StringWithAggregatesFilter<"Document"> | string
    fileUniqueId?: StringWithAggregatesFilter<"Document"> | string
    fileName?: StringWithAggregatesFilter<"Document"> | string
    filePath?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    expenseType?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Expense"> | string | null
    incurredAt?: DateTimeFilter<"Expense"> | Date | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    incurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    expenseType?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Expense"> | string | null
    incurredAt?: DateTimeFilter<"Expense"> | Date | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    incurredAt?: SortOrder
    createdAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    expenseType?: EnumExpenseTypeWithAggregatesFilter<"Expense"> | $Enums.ExpenseType
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    incurredAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type SmsLogWhereInput = {
    AND?: SmsLogWhereInput | SmsLogWhereInput[]
    OR?: SmsLogWhereInput[]
    NOT?: SmsLogWhereInput | SmsLogWhereInput[]
    id?: StringFilter<"SmsLog"> | string
    recipient?: StringFilter<"SmsLog"> | string
    message?: StringFilter<"SmsLog"> | string
    purpose?: EnumSmsPurposeFilter<"SmsLog"> | $Enums.SmsPurpose
    cost?: DecimalNullableFilter<"SmsLog"> | Decimal | DecimalJsLike | number | string | null
    sentAt?: DateTimeFilter<"SmsLog"> | Date | string
    status?: StringNullableFilter<"SmsLog"> | string | null
    createdAt?: DateTimeFilter<"SmsLog"> | Date | string
  }

  export type SmsLogOrderByWithRelationInput = {
    id?: SortOrder
    recipient?: SortOrder
    message?: SortOrder
    purpose?: SortOrder
    cost?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SmsLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SmsLogWhereInput | SmsLogWhereInput[]
    OR?: SmsLogWhereInput[]
    NOT?: SmsLogWhereInput | SmsLogWhereInput[]
    recipient?: StringFilter<"SmsLog"> | string
    message?: StringFilter<"SmsLog"> | string
    purpose?: EnumSmsPurposeFilter<"SmsLog"> | $Enums.SmsPurpose
    cost?: DecimalNullableFilter<"SmsLog"> | Decimal | DecimalJsLike | number | string | null
    sentAt?: DateTimeFilter<"SmsLog"> | Date | string
    status?: StringNullableFilter<"SmsLog"> | string | null
    createdAt?: DateTimeFilter<"SmsLog"> | Date | string
  }, "id">

  export type SmsLogOrderByWithAggregationInput = {
    id?: SortOrder
    recipient?: SortOrder
    message?: SortOrder
    purpose?: SortOrder
    cost?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SmsLogCountOrderByAggregateInput
    _avg?: SmsLogAvgOrderByAggregateInput
    _max?: SmsLogMaxOrderByAggregateInput
    _min?: SmsLogMinOrderByAggregateInput
    _sum?: SmsLogSumOrderByAggregateInput
  }

  export type SmsLogScalarWhereWithAggregatesInput = {
    AND?: SmsLogScalarWhereWithAggregatesInput | SmsLogScalarWhereWithAggregatesInput[]
    OR?: SmsLogScalarWhereWithAggregatesInput[]
    NOT?: SmsLogScalarWhereWithAggregatesInput | SmsLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SmsLog"> | string
    recipient?: StringWithAggregatesFilter<"SmsLog"> | string
    message?: StringWithAggregatesFilter<"SmsLog"> | string
    purpose?: EnumSmsPurposeWithAggregatesFilter<"SmsLog"> | $Enums.SmsPurpose
    cost?: DecimalNullableWithAggregatesFilter<"SmsLog"> | Decimal | DecimalJsLike | number | string | null
    sentAt?: DateTimeWithAggregatesFilter<"SmsLog"> | Date | string
    status?: StringNullableWithAggregatesFilter<"SmsLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SmsLog"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ChartOfAccountWhereInput = {
    AND?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    OR?: ChartOfAccountWhereInput[]
    NOT?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    id?: StringFilter<"ChartOfAccount"> | string
    accountCode?: StringFilter<"ChartOfAccount"> | string
    accountName?: StringFilter<"ChartOfAccount"> | string
    accountType?: EnumAccountTypeFilter<"ChartOfAccount"> | $Enums.AccountType
    parentAccountId?: StringNullableFilter<"ChartOfAccount"> | string | null
    normalBalance?: EnumNormalBalanceFilter<"ChartOfAccount"> | $Enums.NormalBalance
    isActive?: BoolFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
    parentAccount?: XOR<ChartOfAccountNullableScalarRelationFilter, ChartOfAccountWhereInput> | null
    childAccounts?: ChartOfAccountListRelationFilter
  }

  export type ChartOfAccountOrderByWithRelationInput = {
    id?: SortOrder
    accountCode?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    parentAccountId?: SortOrderInput | SortOrder
    normalBalance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentAccount?: ChartOfAccountOrderByWithRelationInput
    childAccounts?: ChartOfAccountOrderByRelationAggregateInput
  }

  export type ChartOfAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountCode?: string
    AND?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    OR?: ChartOfAccountWhereInput[]
    NOT?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    accountName?: StringFilter<"ChartOfAccount"> | string
    accountType?: EnumAccountTypeFilter<"ChartOfAccount"> | $Enums.AccountType
    parentAccountId?: StringNullableFilter<"ChartOfAccount"> | string | null
    normalBalance?: EnumNormalBalanceFilter<"ChartOfAccount"> | $Enums.NormalBalance
    isActive?: BoolFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
    parentAccount?: XOR<ChartOfAccountNullableScalarRelationFilter, ChartOfAccountWhereInput> | null
    childAccounts?: ChartOfAccountListRelationFilter
  }, "id" | "accountCode">

  export type ChartOfAccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountCode?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    parentAccountId?: SortOrderInput | SortOrder
    normalBalance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChartOfAccountCountOrderByAggregateInput
    _max?: ChartOfAccountMaxOrderByAggregateInput
    _min?: ChartOfAccountMinOrderByAggregateInput
  }

  export type ChartOfAccountScalarWhereWithAggregatesInput = {
    AND?: ChartOfAccountScalarWhereWithAggregatesInput | ChartOfAccountScalarWhereWithAggregatesInput[]
    OR?: ChartOfAccountScalarWhereWithAggregatesInput[]
    NOT?: ChartOfAccountScalarWhereWithAggregatesInput | ChartOfAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChartOfAccount"> | string
    accountCode?: StringWithAggregatesFilter<"ChartOfAccount"> | string
    accountName?: StringWithAggregatesFilter<"ChartOfAccount"> | string
    accountType?: EnumAccountTypeWithAggregatesFilter<"ChartOfAccount"> | $Enums.AccountType
    parentAccountId?: StringNullableWithAggregatesFilter<"ChartOfAccount"> | string | null
    normalBalance?: EnumNormalBalanceWithAggregatesFilter<"ChartOfAccount"> | $Enums.NormalBalance
    isActive?: BoolWithAggregatesFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChartOfAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChartOfAccount"> | Date | string
  }

  export type TransactionMatrixWhereInput = {
    AND?: TransactionMatrixWhereInput | TransactionMatrixWhereInput[]
    OR?: TransactionMatrixWhereInput[]
    NOT?: TransactionMatrixWhereInput | TransactionMatrixWhereInput[]
    id?: StringFilter<"TransactionMatrix"> | string
    transactionType?: EnumTransactionTypeFilter<"TransactionMatrix"> | $Enums.TransactionType
    component?: EnumChargeTypeFilter<"TransactionMatrix"> | $Enums.ChargeType
    debitAccountCode?: StringFilter<"TransactionMatrix"> | string
    creditAccountCode?: StringFilter<"TransactionMatrix"> | string
    isActive?: BoolFilter<"TransactionMatrix"> | boolean
    createdAt?: DateTimeFilter<"TransactionMatrix"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionMatrix"> | Date | string
  }

  export type TransactionMatrixOrderByWithRelationInput = {
    id?: SortOrder
    transactionType?: SortOrder
    component?: SortOrder
    debitAccountCode?: SortOrder
    creditAccountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMatrixWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionType_component?: TransactionMatrixTransactionTypeComponentCompoundUniqueInput
    AND?: TransactionMatrixWhereInput | TransactionMatrixWhereInput[]
    OR?: TransactionMatrixWhereInput[]
    NOT?: TransactionMatrixWhereInput | TransactionMatrixWhereInput[]
    transactionType?: EnumTransactionTypeFilter<"TransactionMatrix"> | $Enums.TransactionType
    component?: EnumChargeTypeFilter<"TransactionMatrix"> | $Enums.ChargeType
    debitAccountCode?: StringFilter<"TransactionMatrix"> | string
    creditAccountCode?: StringFilter<"TransactionMatrix"> | string
    isActive?: BoolFilter<"TransactionMatrix"> | boolean
    createdAt?: DateTimeFilter<"TransactionMatrix"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionMatrix"> | Date | string
  }, "id" | "transactionType_component">

  export type TransactionMatrixOrderByWithAggregationInput = {
    id?: SortOrder
    transactionType?: SortOrder
    component?: SortOrder
    debitAccountCode?: SortOrder
    creditAccountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionMatrixCountOrderByAggregateInput
    _max?: TransactionMatrixMaxOrderByAggregateInput
    _min?: TransactionMatrixMinOrderByAggregateInput
  }

  export type TransactionMatrixScalarWhereWithAggregatesInput = {
    AND?: TransactionMatrixScalarWhereWithAggregatesInput | TransactionMatrixScalarWhereWithAggregatesInput[]
    OR?: TransactionMatrixScalarWhereWithAggregatesInput[]
    NOT?: TransactionMatrixScalarWhereWithAggregatesInput | TransactionMatrixScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionMatrix"> | string
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"TransactionMatrix"> | $Enums.TransactionType
    component?: EnumChargeTypeWithAggregatesFilter<"TransactionMatrix"> | $Enums.ChargeType
    debitAccountCode?: StringWithAggregatesFilter<"TransactionMatrix"> | string
    creditAccountCode?: StringWithAggregatesFilter<"TransactionMatrix"> | string
    isActive?: BoolWithAggregatesFilter<"TransactionMatrix"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TransactionMatrix"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionMatrix"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    category?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    category?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    category?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressCreateInput = {
    id?: string
    postalAddress?: string | null
    postalCode?: string | null
    townCity?: string | null
    residentialAddress?: string | null
    location?: string | null
    estate?: string | null
    building?: string | null
    houseNumber?: string | null
    landmark?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutAddressesInput
  }

  export type ClientAddressUncheckedCreateInput = {
    id?: string
    clientId: string
    postalAddress?: string | null
    postalCode?: string | null
    townCity?: string | null
    residentialAddress?: string | null
    location?: string | null
    estate?: string | null
    building?: string | null
    houseNumber?: string | null
    landmark?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    townCity?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    estate?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type ClientAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    townCity?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    estate?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressCreateManyInput = {
    id?: string
    clientId: string
    postalAddress?: string | null
    postalCode?: string | null
    townCity?: string | null
    residentialAddress?: string | null
    location?: string | null
    estate?: string | null
    building?: string | null
    houseNumber?: string | null
    landmark?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    townCity?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    estate?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    townCity?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    estate?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailCreateInput = {
    id?: string
    employerName: string
    jobTitle: string
    department?: string | null
    dateJoined?: Date | string | null
    periodWorked?: string | null
    employmentType: $Enums.EmploymentType
    contractExpiry?: Date | string | null
    onNotice?: boolean
    netSalary: Decimal | DecimalJsLike | number | string
    branchLocation?: string | null
    roadStreet?: string | null
    building?: string | null
    floorOffice?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutEmploymentDetailsInput
  }

  export type EmploymentDetailUncheckedCreateInput = {
    id?: string
    clientId: string
    employerName: string
    jobTitle: string
    department?: string | null
    dateJoined?: Date | string | null
    periodWorked?: string | null
    employmentType: $Enums.EmploymentType
    contractExpiry?: Date | string | null
    onNotice?: boolean
    netSalary: Decimal | DecimalJsLike | number | string
    branchLocation?: string | null
    roadStreet?: string | null
    building?: string | null
    floorOffice?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodWorked?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    contractExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onNotice?: BoolFieldUpdateOperationsInput | boolean
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchLocation?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    floorOffice?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutEmploymentDetailsNestedInput
  }

  export type EmploymentDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodWorked?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    contractExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onNotice?: BoolFieldUpdateOperationsInput | boolean
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchLocation?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    floorOffice?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailCreateManyInput = {
    id?: string
    clientId: string
    employerName: string
    jobTitle: string
    department?: string | null
    dateJoined?: Date | string | null
    periodWorked?: string | null
    employmentType: $Enums.EmploymentType
    contractExpiry?: Date | string | null
    onNotice?: boolean
    netSalary: Decimal | DecimalJsLike | number | string
    branchLocation?: string | null
    roadStreet?: string | null
    building?: string | null
    floorOffice?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodWorked?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    contractExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onNotice?: BoolFieldUpdateOperationsInput | boolean
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchLocation?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    floorOffice?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodWorked?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    contractExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onNotice?: BoolFieldUpdateOperationsInput | boolean
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchLocation?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    floorOffice?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefereeCreateInput = {
    id?: string
    surname: string
    otherNames: string
    relationship: string
    idPassportNo?: string | null
    employerName?: string | null
    locationStation?: string | null
    phoneWork?: string | null
    phoneMobile: string
    isRelative?: boolean
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutRefereesInput
  }

  export type RefereeUncheckedCreateInput = {
    id?: string
    clientId: string
    surname: string
    otherNames: string
    relationship: string
    idPassportNo?: string | null
    employerName?: string | null
    locationStation?: string | null
    phoneWork?: string | null
    phoneMobile: string
    isRelative?: boolean
    createdAt?: Date | string
  }

  export type RefereeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    idPassportNo?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    locationStation?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    isRelative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRefereesNestedInput
  }

  export type RefereeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    idPassportNo?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    locationStation?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    isRelative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefereeCreateManyInput = {
    id?: string
    clientId: string
    surname: string
    otherNames: string
    relationship: string
    idPassportNo?: string | null
    employerName?: string | null
    locationStation?: string | null
    phoneWork?: string | null
    phoneMobile: string
    isRelative?: boolean
    createdAt?: Date | string
  }

  export type RefereeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    idPassportNo?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    locationStation?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    isRelative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefereeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    idPassportNo?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    locationStation?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    isRelative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailCreateInput = {
    id?: string
    bankName: string
    branch: string
    accountName: string
    accountNumber: string
    proofDocument?: string | null
    proofDocumentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailUncheckedCreateInput = {
    id?: string
    clientId: string
    bankName: string
    branch: string
    accountName: string
    accountNumber: string
    proofDocument?: string | null
    proofDocumentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutBankDetailsNestedInput
  }

  export type BankDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailCreateManyInput = {
    id?: string
    clientId: string
    bankName: string
    branch: string
    accountName: string
    accountNumber: string
    proofDocument?: string | null
    proofDocumentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationCreateInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationCreateManyInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanQualificationCreateInput = {
    id?: string
    avgIncome: Decimal | DecimalJsLike | number | string
    eligibilityAmount: Decimal | DecimalJsLike | number | string
    ruleApplied: $Enums.QualificationType
    createdAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutQualificationInput
  }

  export type LoanQualificationUncheckedCreateInput = {
    id?: string
    loanId: string
    avgIncome: Decimal | DecimalJsLike | number | string
    eligibilityAmount: Decimal | DecimalJsLike | number | string
    ruleApplied: $Enums.QualificationType
    createdAt?: Date | string
  }

  export type LoanQualificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avgIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutQualificationNestedInput
  }

  export type LoanQualificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    avgIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanQualificationCreateManyInput = {
    id?: string
    loanId: string
    avgIncome: Decimal | DecimalJsLike | number | string
    eligibilityAmount: Decimal | DecimalJsLike | number | string
    ruleApplied: $Enums.QualificationType
    createdAt?: Date | string
  }

  export type LoanQualificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    avgIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanQualificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    avgIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanSecurityCreateInput = {
    id?: string
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutSecurityInput
  }

  export type LoanSecurityUncheckedCreateInput = {
    id?: string
    loanId: string
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanSecurityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCopy?: BoolFieldUpdateOperationsInput | boolean
    passportPhoto?: BoolFieldUpdateOperationsInput | boolean
    appointmentLetter?: BoolFieldUpdateOperationsInput | boolean
    payslips?: BoolFieldUpdateOperationsInput | boolean
    bankStatement?: BoolFieldUpdateOperationsInput | boolean
    chequeLeafNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutSecurityNestedInput
  }

  export type LoanSecurityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    idCopy?: BoolFieldUpdateOperationsInput | boolean
    passportPhoto?: BoolFieldUpdateOperationsInput | boolean
    appointmentLetter?: BoolFieldUpdateOperationsInput | boolean
    payslips?: BoolFieldUpdateOperationsInput | boolean
    bankStatement?: BoolFieldUpdateOperationsInput | boolean
    chequeLeafNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanSecurityCreateManyInput = {
    id?: string
    loanId: string
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanSecurityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCopy?: BoolFieldUpdateOperationsInput | boolean
    passportPhoto?: BoolFieldUpdateOperationsInput | boolean
    appointmentLetter?: BoolFieldUpdateOperationsInput | boolean
    payslips?: BoolFieldUpdateOperationsInput | boolean
    bankStatement?: BoolFieldUpdateOperationsInput | boolean
    chequeLeafNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanSecurityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    idCopy?: BoolFieldUpdateOperationsInput | boolean
    passportPhoto?: BoolFieldUpdateOperationsInput | boolean
    appointmentLetter?: BoolFieldUpdateOperationsInput | boolean
    payslips?: BoolFieldUpdateOperationsInput | boolean
    bankStatement?: BoolFieldUpdateOperationsInput | boolean
    chequeLeafNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleSecurityCreateInput = {
    id?: string
    registrationNumber: string
    chassisNumber: string
    engineNumber: string
    yearOfManufacture: number
    make: string
    model: string
    bodyColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutVehicleSecurityInput
  }

  export type VehicleSecurityUncheckedCreateInput = {
    id?: string
    loanId: string
    registrationNumber: string
    chassisNumber: string
    engineNumber: string
    yearOfManufacture: number
    make: string
    model: string
    bodyColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleSecurityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    chassisNumber?: StringFieldUpdateOperationsInput | string
    engineNumber?: StringFieldUpdateOperationsInput | string
    yearOfManufacture?: IntFieldUpdateOperationsInput | number
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    bodyColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutVehicleSecurityNestedInput
  }

  export type VehicleSecurityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    chassisNumber?: StringFieldUpdateOperationsInput | string
    engineNumber?: StringFieldUpdateOperationsInput | string
    yearOfManufacture?: IntFieldUpdateOperationsInput | number
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    bodyColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleSecurityCreateManyInput = {
    id?: string
    loanId: string
    registrationNumber: string
    chassisNumber: string
    engineNumber: string
    yearOfManufacture: number
    make: string
    model: string
    bodyColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleSecurityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    chassisNumber?: StringFieldUpdateOperationsInput | string
    engineNumber?: StringFieldUpdateOperationsInput | string
    yearOfManufacture?: IntFieldUpdateOperationsInput | number
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    bodyColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleSecurityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    chassisNumber?: StringFieldUpdateOperationsInput | string
    engineNumber?: StringFieldUpdateOperationsInput | string
    yearOfManufacture?: IntFieldUpdateOperationsInput | number
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    bodyColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuarantorCreateInput = {
    id?: string
    fullName: string
    phone: string
    email?: string | null
    idNumber?: string | null
    relationship?: string | null
    confirmationStatus?: $Enums.GuarantorStatus
    confirmedAt?: Date | string | null
    createdAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutGuarantorsInput
  }

  export type GuarantorUncheckedCreateInput = {
    id?: string
    loanId: string
    fullName: string
    phone: string
    email?: string | null
    idNumber?: string | null
    relationship?: string | null
    confirmationStatus?: $Enums.GuarantorStatus
    confirmedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GuarantorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationStatus?: EnumGuarantorStatusFieldUpdateOperationsInput | $Enums.GuarantorStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutGuarantorsNestedInput
  }

  export type GuarantorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationStatus?: EnumGuarantorStatusFieldUpdateOperationsInput | $Enums.GuarantorStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuarantorCreateManyInput = {
    id?: string
    loanId: string
    fullName: string
    phone: string
    email?: string | null
    idNumber?: string | null
    relationship?: string | null
    confirmationStatus?: $Enums.GuarantorStatus
    confirmedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GuarantorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationStatus?: EnumGuarantorStatusFieldUpdateOperationsInput | $Enums.GuarantorStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuarantorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationStatus?: EnumGuarantorStatusFieldUpdateOperationsInput | $Enums.GuarantorStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanDisbursementCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.DisbursementMethod
    reference?: string | null
    disbursedAt: Date | string
    createdAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutDisbursementInput
  }

  export type LoanDisbursementUncheckedCreateInput = {
    id?: string
    loanId: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.DisbursementMethod
    reference?: string | null
    disbursedAt: Date | string
    createdAt?: Date | string
  }

  export type LoanDisbursementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFieldUpdateOperationsInput | $Enums.DisbursementMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    disbursedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutDisbursementNestedInput
  }

  export type LoanDisbursementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFieldUpdateOperationsInput | $Enums.DisbursementMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    disbursedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanDisbursementCreateManyInput = {
    id?: string
    loanId: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.DisbursementMethod
    reference?: string | null
    disbursedAt: Date | string
    createdAt?: Date | string
  }

  export type LoanDisbursementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFieldUpdateOperationsInput | $Enums.DisbursementMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    disbursedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanDisbursementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFieldUpdateOperationsInput | $Enums.DisbursementMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    disbursedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanFinancialCreateInput = {
    id?: string
    processingFee: Decimal | DecimalJsLike | number | string
    legalFee?: Decimal | DecimalJsLike | number | string
    penaltyFee?: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutFinancialsInput
  }

  export type LoanFinancialUncheckedCreateInput = {
    id?: string
    loanId: string
    processingFee: Decimal | DecimalJsLike | number | string
    legalFee?: Decimal | DecimalJsLike | number | string
    penaltyFee?: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanFinancialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutFinancialsNestedInput
  }

  export type LoanFinancialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanFinancialCreateManyInput = {
    id?: string
    loanId: string
    processingFee: Decimal | DecimalJsLike | number | string
    legalFee?: Decimal | DecimalJsLike | number | string
    penaltyFee?: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanFinancialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanFinancialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    loan: LoanApplicationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    clientId: string
    loanId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    loan?: LoanApplicationUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    clientId: string
    loanId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    chargeType: $Enums.ChargeType
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    glAccount?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    chargeType: $Enums.ChargeType
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    glAccount?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeType?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAccount?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    chargeType?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAccount?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    chargeType: $Enums.ChargeType
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    glAccount?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeType?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAccount?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    chargeType?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAccount?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentCreateInput = {
    id?: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    transaction?: TransactionCreateNestedOneWithoutInvoicePaymentsInput
  }

  export type InvoicePaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    transactionId?: string | null
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
  }

  export type InvoicePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneWithoutInvoicePaymentsNestedInput
  }

  export type InvoicePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentCreateManyInput = {
    id?: string
    invoiceId: string
    transactionId?: string | null
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
  }

  export type InvoicePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    transactionCode: string
    transactionType: $Enums.TransactionType
    referenceType: $Enums.ReferenceType
    referenceId: string
    amount: Decimal | DecimalJsLike | number | string
    debitAccount: string
    creditAccount: string
    paymentMethod?: $Enums.PaymentMethod | null
    transactionDate: Date | string
    description?: string | null
    status?: $Enums.TransactionStatus
    createdBy?: string | null
    createdAt?: Date | string
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    transactionCode: string
    transactionType: $Enums.TransactionType
    referenceType: $Enums.ReferenceType
    referenceId: string
    amount: Decimal | DecimalJsLike | number | string
    debitAccount: string
    creditAccount: string
    paymentMethod?: $Enums.PaymentMethod | null
    transactionDate: Date | string
    description?: string | null
    status?: $Enums.TransactionStatus
    createdBy?: string | null
    createdAt?: Date | string
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionCode?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    referenceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFieldUpdateOperationsInput | string
    creditAccount?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoicePayments?: InvoicePaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionCode?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    referenceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFieldUpdateOperationsInput | string
    creditAccount?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    transactionCode: string
    transactionType: $Enums.TransactionType
    referenceType: $Enums.ReferenceType
    referenceId: string
    amount: Decimal | DecimalJsLike | number | string
    debitAccount: string
    creditAccount: string
    paymentMethod?: $Enums.PaymentMethod | null
    transactionDate: Date | string
    description?: string | null
    status?: $Enums.TransactionStatus
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionCode?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    referenceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFieldUpdateOperationsInput | string
    creditAccount?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionCode?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    referenceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFieldUpdateOperationsInput | string
    creditAccount?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    category: $Enums.RepaymentCategory
    reference?: string | null
    createdAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutRepaymentsInput
  }

  export type RepaymentUncheckedCreateInput = {
    id?: string
    loanId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    category: $Enums.RepaymentCategory
    reference?: string | null
    createdAt?: Date | string
  }

  export type RepaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumRepaymentCategoryFieldUpdateOperationsInput | $Enums.RepaymentCategory
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutRepaymentsNestedInput
  }

  export type RepaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumRepaymentCategoryFieldUpdateOperationsInput | $Enums.RepaymentCategory
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepaymentCreateManyInput = {
    id?: string
    loanId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    category: $Enums.RepaymentCategory
    reference?: string | null
    createdAt?: Date | string
  }

  export type RepaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumRepaymentCategoryFieldUpdateOperationsInput | $Enums.RepaymentCategory
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumRepaymentCategoryFieldUpdateOperationsInput | $Enums.RepaymentCategory
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonPerformingLoanCreateInput = {
    id?: string
    capitalizedAmount: Decimal | DecimalJsLike | number | string
    flaggedAt: Date | string
    createdAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutNplInput
  }

  export type NonPerformingLoanUncheckedCreateInput = {
    id?: string
    loanId: string
    capitalizedAmount: Decimal | DecimalJsLike | number | string
    flaggedAt: Date | string
    createdAt?: Date | string
  }

  export type NonPerformingLoanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    capitalizedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutNplNestedInput
  }

  export type NonPerformingLoanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    capitalizedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonPerformingLoanCreateManyInput = {
    id?: string
    loanId: string
    capitalizedAmount: Decimal | DecimalJsLike | number | string
    flaggedAt: Date | string
    createdAt?: Date | string
  }

  export type NonPerformingLoanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    capitalizedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonPerformingLoanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    capitalizedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryAgentCreateInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRecoveryAgentInput
    records?: RecoveryRecordCreateNestedManyWithoutAgentInput
  }

  export type RecoveryAgentUncheckedCreateInput = {
    id?: string
    userId?: string | null
    name: string
    phone: string
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: RecoveryRecordUncheckedCreateNestedManyWithoutAgentInput
  }

  export type RecoveryAgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRecoveryAgentNestedInput
    records?: RecoveryRecordUpdateManyWithoutAgentNestedInput
  }

  export type RecoveryAgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: RecoveryRecordUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type RecoveryAgentCreateManyInput = {
    id?: string
    userId?: string | null
    name: string
    phone: string
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecoveryAgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryAgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordCreateInput = {
    id?: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
    agent: RecoveryAgentCreateNestedOneWithoutRecordsInput
    loan: LoanApplicationCreateNestedOneWithoutRecoveryRecordsInput
  }

  export type RecoveryRecordUncheckedCreateInput = {
    id?: string
    loanId: string
    agentId: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
  }

  export type RecoveryRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: RecoveryAgentUpdateOneRequiredWithoutRecordsNestedInput
    loan?: LoanApplicationUpdateOneRequiredWithoutRecoveryRecordsNestedInput
  }

  export type RecoveryRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordCreateManyInput = {
    id?: string
    loanId: string
    agentId: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
  }

  export type RecoveryRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorCreateInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: InvestorAllocationCreateNestedManyWithoutInvestorInput
    payouts?: InvestorPayoutCreateNestedManyWithoutInvestorInput
    user?: UserCreateNestedOneWithoutInvestorInput
  }

  export type InvestorUncheckedCreateInput = {
    id?: string
    userId?: string | null
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: InvestorAllocationUncheckedCreateNestedManyWithoutInvestorInput
    payouts?: InvestorPayoutUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: InvestorAllocationUpdateManyWithoutInvestorNestedInput
    payouts?: InvestorPayoutUpdateManyWithoutInvestorNestedInput
    user?: UserUpdateOneWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: InvestorAllocationUncheckedUpdateManyWithoutInvestorNestedInput
    payouts?: InvestorPayoutUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorCreateManyInput = {
    id?: string
    userId?: string | null
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorAllocationCreateInput = {
    id?: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutAllocationsInput
    loan: LoanApplicationCreateNestedOneWithoutInvestorAllocationsInput
  }

  export type InvestorAllocationUncheckedCreateInput = {
    id?: string
    investorId: string
    loanId: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorAllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutAllocationsNestedInput
    loan?: LoanApplicationUpdateOneRequiredWithoutInvestorAllocationsNestedInput
  }

  export type InvestorAllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorAllocationCreateManyInput = {
    id?: string
    investorId: string
    loanId: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorAllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorAllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorPayoutCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payoutDate: Date | string
    reference?: string | null
    createdAt?: Date | string
    investor: InvestorCreateNestedOneWithoutPayoutsInput
  }

  export type InvestorPayoutUncheckedCreateInput = {
    id?: string
    investorId: string
    amount: Decimal | DecimalJsLike | number | string
    payoutDate: Date | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type InvestorPayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type InvestorPayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorPayoutCreateManyInput = {
    id?: string
    investorId: string
    amount: Decimal | DecimalJsLike | number | string
    payoutDate: Date | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type InvestorPayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorPayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    client?: ClientCreateNestedOneWithoutDocumentsInput
    loan?: LoanApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    clientId?: string | null
    loanId?: string | null
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    loan?: LoanApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    clientId?: string | null
    loanId?: string | null
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    expenseType: $Enums.ExpenseType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    incurredAt: Date | string
    createdAt?: Date | string
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    expenseType: $Enums.ExpenseType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    incurredAt: Date | string
    createdAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    incurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    incurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    expenseType: $Enums.ExpenseType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    incurredAt: Date | string
    createdAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    incurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    incurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsLogCreateInput = {
    id?: string
    recipient: string
    message: string
    purpose: $Enums.SmsPurpose
    cost?: Decimal | DecimalJsLike | number | string | null
    sentAt: Date | string
    status?: string | null
    createdAt?: Date | string
  }

  export type SmsLogUncheckedCreateInput = {
    id?: string
    recipient: string
    message: string
    purpose: $Enums.SmsPurpose
    cost?: Decimal | DecimalJsLike | number | string | null
    sentAt: Date | string
    status?: string | null
    createdAt?: Date | string
  }

  export type SmsLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    purpose?: EnumSmsPurposeFieldUpdateOperationsInput | $Enums.SmsPurpose
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    purpose?: EnumSmsPurposeFieldUpdateOperationsInput | $Enums.SmsPurpose
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsLogCreateManyInput = {
    id?: string
    recipient: string
    message: string
    purpose: $Enums.SmsPurpose
    cost?: Decimal | DecimalJsLike | number | string | null
    sentAt: Date | string
    status?: string | null
    createdAt?: Date | string
  }

  export type SmsLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    purpose?: EnumSmsPurposeFieldUpdateOperationsInput | $Enums.SmsPurpose
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    purpose?: EnumSmsPurposeFieldUpdateOperationsInput | $Enums.SmsPurpose
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartOfAccountCreateInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentAccount?: ChartOfAccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: ChartOfAccountCreateNestedManyWithoutParentAccountInput
  }

  export type ChartOfAccountUncheckedCreateInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    parentAccountId?: string | null
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    childAccounts?: ChartOfAccountUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ChartOfAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentAccount?: ChartOfAccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: ChartOfAccountUpdateManyWithoutParentAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childAccounts?: ChartOfAccountUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type ChartOfAccountCreateManyInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    parentAccountId?: string | null
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChartOfAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartOfAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMatrixCreateInput = {
    id?: string
    transactionType: $Enums.TransactionType
    component: $Enums.ChargeType
    debitAccountCode: string
    creditAccountCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionMatrixUncheckedCreateInput = {
    id?: string
    transactionType: $Enums.TransactionType
    component: $Enums.ChargeType
    debitAccountCode: string
    creditAccountCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionMatrixUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    component?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    debitAccountCode?: StringFieldUpdateOperationsInput | string
    creditAccountCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMatrixUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    component?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    debitAccountCode?: StringFieldUpdateOperationsInput | string
    creditAccountCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMatrixCreateManyInput = {
    id?: string
    transactionType: $Enums.TransactionType
    component: $Enums.ChargeType
    debitAccountCode: string
    creditAccountCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionMatrixUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    component?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    debitAccountCode?: StringFieldUpdateOperationsInput | string
    creditAccountCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMatrixUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    component?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    debitAccountCode?: StringFieldUpdateOperationsInput | string
    creditAccountCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type InvestorNullableScalarRelationFilter = {
    is?: InvestorWhereInput | null
    isNot?: InvestorWhereInput | null
  }

  export type LoanApplicationListRelationFilter = {
    every?: LoanApplicationWhereInput
    some?: LoanApplicationWhereInput
    none?: LoanApplicationWhereInput
  }

  export type RecoveryAgentNullableScalarRelationFilter = {
    is?: RecoveryAgentWhereInput | null
    isNot?: RecoveryAgentWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleFilter<$PrismaModel> | $Enums.Title
  }

  export type EnumMaritalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusFilter<$PrismaModel> | $Enums.MaritalStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type BankDetailListRelationFilter = {
    every?: BankDetailWhereInput
    some?: BankDetailWhereInput
    none?: BankDetailWhereInput
  }

  export type ClientAddressListRelationFilter = {
    every?: ClientAddressWhereInput
    some?: ClientAddressWhereInput
    none?: ClientAddressWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type EmploymentDetailListRelationFilter = {
    every?: EmploymentDetailWhereInput
    some?: EmploymentDetailWhereInput
    none?: EmploymentDetailWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type RefereeListRelationFilter = {
    every?: RefereeWhereInput
    some?: RefereeWhereInput
    none?: RefereeWhereInput
  }

  export type BankDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmploymentDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefereeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    dependents?: SortOrder
    idPassportNo?: SortOrder
    kraPin?: SortOrder
    phoneWork?: SortOrder
    phoneMobile?: SortOrder
    phoneAlternative?: SortOrder
    emailPersonal?: SortOrder
    emailOfficial?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    dependents?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    dependents?: SortOrder
    idPassportNo?: SortOrder
    kraPin?: SortOrder
    phoneWork?: SortOrder
    phoneMobile?: SortOrder
    phoneAlternative?: SortOrder
    emailPersonal?: SortOrder
    emailOfficial?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    dateOfBirth?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    dependents?: SortOrder
    idPassportNo?: SortOrder
    kraPin?: SortOrder
    phoneWork?: SortOrder
    phoneMobile?: SortOrder
    phoneAlternative?: SortOrder
    emailPersonal?: SortOrder
    emailOfficial?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    dependents?: SortOrder
  }

  export type EnumTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTitleFilter<$PrismaModel>
    _max?: NestedEnumTitleFilter<$PrismaModel>
  }

  export type EnumMaritalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ClientAddressCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    postalAddress?: SortOrder
    postalCode?: SortOrder
    townCity?: SortOrder
    residentialAddress?: SortOrder
    location?: SortOrder
    estate?: SortOrder
    building?: SortOrder
    houseNumber?: SortOrder
    landmark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    postalAddress?: SortOrder
    postalCode?: SortOrder
    townCity?: SortOrder
    residentialAddress?: SortOrder
    location?: SortOrder
    estate?: SortOrder
    building?: SortOrder
    houseNumber?: SortOrder
    landmark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAddressMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    postalAddress?: SortOrder
    postalCode?: SortOrder
    townCity?: SortOrder
    residentialAddress?: SortOrder
    location?: SortOrder
    estate?: SortOrder
    building?: SortOrder
    houseNumber?: SortOrder
    landmark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EmploymentDetailCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    employerName?: SortOrder
    jobTitle?: SortOrder
    department?: SortOrder
    dateJoined?: SortOrder
    periodWorked?: SortOrder
    employmentType?: SortOrder
    contractExpiry?: SortOrder
    onNotice?: SortOrder
    netSalary?: SortOrder
    branchLocation?: SortOrder
    roadStreet?: SortOrder
    building?: SortOrder
    floorOffice?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmploymentDetailAvgOrderByAggregateInput = {
    netSalary?: SortOrder
  }

  export type EmploymentDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    employerName?: SortOrder
    jobTitle?: SortOrder
    department?: SortOrder
    dateJoined?: SortOrder
    periodWorked?: SortOrder
    employmentType?: SortOrder
    contractExpiry?: SortOrder
    onNotice?: SortOrder
    netSalary?: SortOrder
    branchLocation?: SortOrder
    roadStreet?: SortOrder
    building?: SortOrder
    floorOffice?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmploymentDetailMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    employerName?: SortOrder
    jobTitle?: SortOrder
    department?: SortOrder
    dateJoined?: SortOrder
    periodWorked?: SortOrder
    employmentType?: SortOrder
    contractExpiry?: SortOrder
    onNotice?: SortOrder
    netSalary?: SortOrder
    branchLocation?: SortOrder
    roadStreet?: SortOrder
    building?: SortOrder
    floorOffice?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmploymentDetailSumOrderByAggregateInput = {
    netSalary?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type RefereeCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    relationship?: SortOrder
    idPassportNo?: SortOrder
    employerName?: SortOrder
    locationStation?: SortOrder
    phoneWork?: SortOrder
    phoneMobile?: SortOrder
    isRelative?: SortOrder
    createdAt?: SortOrder
  }

  export type RefereeMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    relationship?: SortOrder
    idPassportNo?: SortOrder
    employerName?: SortOrder
    locationStation?: SortOrder
    phoneWork?: SortOrder
    phoneMobile?: SortOrder
    isRelative?: SortOrder
    createdAt?: SortOrder
  }

  export type RefereeMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    surname?: SortOrder
    otherNames?: SortOrder
    relationship?: SortOrder
    idPassportNo?: SortOrder
    employerName?: SortOrder
    locationStation?: SortOrder
    phoneWork?: SortOrder
    phoneMobile?: SortOrder
    isRelative?: SortOrder
    createdAt?: SortOrder
  }

  export type BankDetailCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    bankName?: SortOrder
    branch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    proofDocument?: SortOrder
    proofDocumentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    bankName?: SortOrder
    branch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    proofDocument?: SortOrder
    proofDocumentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    bankName?: SortOrder
    branch?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    proofDocument?: SortOrder
    proofDocumentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumQualificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQualificationTypeNullableFilter<$PrismaModel> | $Enums.QualificationType | null
  }

  export type EnumLoanApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanApplicationStatus | EnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanApplicationStatusFilter<$PrismaModel> | $Enums.LoanApplicationStatus
  }

  export type GuarantorListRelationFilter = {
    every?: GuarantorWhereInput
    some?: GuarantorWhereInput
    none?: GuarantorWhereInput
  }

  export type InvestorAllocationListRelationFilter = {
    every?: InvestorAllocationWhereInput
    some?: InvestorAllocationWhereInput
    none?: InvestorAllocationWhereInput
  }

  export type LoanDisbursementNullableScalarRelationFilter = {
    is?: LoanDisbursementWhereInput | null
    isNot?: LoanDisbursementWhereInput | null
  }

  export type LoanFinancialNullableScalarRelationFilter = {
    is?: LoanFinancialWhereInput | null
    isNot?: LoanFinancialWhereInput | null
  }

  export type LoanQualificationNullableScalarRelationFilter = {
    is?: LoanQualificationWhereInput | null
    isNot?: LoanQualificationWhereInput | null
  }

  export type LoanSecurityNullableScalarRelationFilter = {
    is?: LoanSecurityWhereInput | null
    isNot?: LoanSecurityWhereInput | null
  }

  export type NonPerformingLoanNullableScalarRelationFilter = {
    is?: NonPerformingLoanWhereInput | null
    isNot?: NonPerformingLoanWhereInput | null
  }

  export type RecoveryRecordListRelationFilter = {
    every?: RecoveryRecordWhereInput
    some?: RecoveryRecordWhereInput
    none?: RecoveryRecordWhereInput
  }

  export type RepaymentListRelationFilter = {
    every?: RepaymentWhereInput
    some?: RepaymentWhereInput
    none?: RepaymentWhereInput
  }

  export type VehicleSecurityNullableScalarRelationFilter = {
    is?: VehicleSecurityWhereInput | null
    isNot?: VehicleSecurityWhereInput | null
  }

  export type GuarantorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecoveryRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    purpose?: SortOrder
    amountRequested?: SortOrder
    approvedAmount?: SortOrder
    qualificationType?: SortOrder
    interestRate?: SortOrder
    startDate?: SortOrder
    repaymentPeriod?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedById?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationAvgOrderByAggregateInput = {
    amountRequested?: SortOrder
    approvedAmount?: SortOrder
    interestRate?: SortOrder
    repaymentPeriod?: SortOrder
  }

  export type LoanApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    purpose?: SortOrder
    amountRequested?: SortOrder
    approvedAmount?: SortOrder
    qualificationType?: SortOrder
    interestRate?: SortOrder
    startDate?: SortOrder
    repaymentPeriod?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedById?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    purpose?: SortOrder
    amountRequested?: SortOrder
    approvedAmount?: SortOrder
    qualificationType?: SortOrder
    interestRate?: SortOrder
    startDate?: SortOrder
    repaymentPeriod?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedById?: SortOrder
    approvedAt?: SortOrder
    approvedById?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationSumOrderByAggregateInput = {
    amountRequested?: SortOrder
    approvedAmount?: SortOrder
    interestRate?: SortOrder
    repaymentPeriod?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumQualificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQualificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.QualificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQualificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumQualificationTypeNullableFilter<$PrismaModel>
  }

  export type EnumLoanApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanApplicationStatus | EnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.LoanApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoanApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumLoanApplicationStatusFilter<$PrismaModel>
  }

  export type EnumQualificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQualificationTypeFilter<$PrismaModel> | $Enums.QualificationType
  }

  export type LoanApplicationScalarRelationFilter = {
    is?: LoanApplicationWhereInput
    isNot?: LoanApplicationWhereInput
  }

  export type LoanQualificationCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    avgIncome?: SortOrder
    eligibilityAmount?: SortOrder
    ruleApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanQualificationAvgOrderByAggregateInput = {
    avgIncome?: SortOrder
    eligibilityAmount?: SortOrder
  }

  export type LoanQualificationMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    avgIncome?: SortOrder
    eligibilityAmount?: SortOrder
    ruleApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanQualificationMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    avgIncome?: SortOrder
    eligibilityAmount?: SortOrder
    ruleApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanQualificationSumOrderByAggregateInput = {
    avgIncome?: SortOrder
    eligibilityAmount?: SortOrder
  }

  export type EnumQualificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQualificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.QualificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQualificationTypeFilter<$PrismaModel>
    _max?: NestedEnumQualificationTypeFilter<$PrismaModel>
  }

  export type LoanSecurityCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    idCopy?: SortOrder
    passportPhoto?: SortOrder
    appointmentLetter?: SortOrder
    payslips?: SortOrder
    bankStatement?: SortOrder
    chequeLeafNo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanSecurityMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    idCopy?: SortOrder
    passportPhoto?: SortOrder
    appointmentLetter?: SortOrder
    payslips?: SortOrder
    bankStatement?: SortOrder
    chequeLeafNo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanSecurityMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    idCopy?: SortOrder
    passportPhoto?: SortOrder
    appointmentLetter?: SortOrder
    payslips?: SortOrder
    bankStatement?: SortOrder
    chequeLeafNo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSecurityCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    registrationNumber?: SortOrder
    chassisNumber?: SortOrder
    engineNumber?: SortOrder
    yearOfManufacture?: SortOrder
    make?: SortOrder
    model?: SortOrder
    bodyColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSecurityAvgOrderByAggregateInput = {
    yearOfManufacture?: SortOrder
  }

  export type VehicleSecurityMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    registrationNumber?: SortOrder
    chassisNumber?: SortOrder
    engineNumber?: SortOrder
    yearOfManufacture?: SortOrder
    make?: SortOrder
    model?: SortOrder
    bodyColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSecurityMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    registrationNumber?: SortOrder
    chassisNumber?: SortOrder
    engineNumber?: SortOrder
    yearOfManufacture?: SortOrder
    make?: SortOrder
    model?: SortOrder
    bodyColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSecuritySumOrderByAggregateInput = {
    yearOfManufacture?: SortOrder
  }

  export type EnumGuarantorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GuarantorStatus | EnumGuarantorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuarantorStatusFilter<$PrismaModel> | $Enums.GuarantorStatus
  }

  export type GuarantorCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    idNumber?: SortOrder
    relationship?: SortOrder
    confirmationStatus?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GuarantorMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    idNumber?: SortOrder
    relationship?: SortOrder
    confirmationStatus?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GuarantorMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    idNumber?: SortOrder
    relationship?: SortOrder
    confirmationStatus?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumGuarantorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuarantorStatus | EnumGuarantorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuarantorStatusWithAggregatesFilter<$PrismaModel> | $Enums.GuarantorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuarantorStatusFilter<$PrismaModel>
    _max?: NestedEnumGuarantorStatusFilter<$PrismaModel>
  }

  export type EnumDisbursementMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DisbursementMethod | EnumDisbursementMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDisbursementMethodFilter<$PrismaModel> | $Enums.DisbursementMethod
  }

  export type LoanDisbursementCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    disbursedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanDisbursementAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type LoanDisbursementMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    disbursedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanDisbursementMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    disbursedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanDisbursementSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDisbursementMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisbursementMethod | EnumDisbursementMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDisbursementMethodWithAggregatesFilter<$PrismaModel> | $Enums.DisbursementMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisbursementMethodFilter<$PrismaModel>
    _max?: NestedEnumDisbursementMethodFilter<$PrismaModel>
  }

  export type LoanFinancialCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    processingFee?: SortOrder
    legalFee?: SortOrder
    penaltyFee?: SortOrder
    interestAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanFinancialAvgOrderByAggregateInput = {
    processingFee?: SortOrder
    legalFee?: SortOrder
    penaltyFee?: SortOrder
    interestAmount?: SortOrder
  }

  export type LoanFinancialMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    processingFee?: SortOrder
    legalFee?: SortOrder
    penaltyFee?: SortOrder
    interestAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanFinancialMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    processingFee?: SortOrder
    legalFee?: SortOrder
    penaltyFee?: SortOrder
    interestAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanFinancialSumOrderByAggregateInput = {
    processingFee?: SortOrder
    legalFee?: SortOrder
    penaltyFee?: SortOrder
    interestAmount?: SortOrder
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoicePaymentListRelationFilter = {
    every?: InvoicePaymentWhereInput
    some?: InvoicePaymentWhereInput
    none?: InvoicePaymentWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoicePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumChargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeFilter<$PrismaModel> | $Enums.ChargeType
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    chargeType?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    glAccount?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    chargeType?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    glAccount?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    chargeType?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    glAccount?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumChargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChargeTypeFilter<$PrismaModel>
    _max?: NestedEnumChargeTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type InvoicePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    transactionId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoicePaymentAvgOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type InvoicePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    transactionId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoicePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    transactionId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoicePaymentSumOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeFilter<$PrismaModel> | $Enums.ReferenceType
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionCode?: SortOrder
    transactionType?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    debitAccount?: SortOrder
    creditAccount?: SortOrder
    paymentMethod?: SortOrder
    transactionDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionCode?: SortOrder
    transactionType?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    debitAccount?: SortOrder
    creditAccount?: SortOrder
    paymentMethod?: SortOrder
    transactionDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionCode?: SortOrder
    transactionType?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    debitAccount?: SortOrder
    creditAccount?: SortOrder
    paymentMethod?: SortOrder
    transactionDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumReferenceTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumRepaymentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.RepaymentCategory | EnumRepaymentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumRepaymentCategoryFilter<$PrismaModel> | $Enums.RepaymentCategory
  }

  export type RepaymentCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type RepaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RepaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type RepaymentMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    category?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type RepaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumRepaymentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RepaymentCategory | EnumRepaymentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumRepaymentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.RepaymentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRepaymentCategoryFilter<$PrismaModel>
    _max?: NestedEnumRepaymentCategoryFilter<$PrismaModel>
  }

  export type NonPerformingLoanCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    capitalizedAmount?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NonPerformingLoanAvgOrderByAggregateInput = {
    capitalizedAmount?: SortOrder
  }

  export type NonPerformingLoanMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    capitalizedAmount?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NonPerformingLoanMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    capitalizedAmount?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NonPerformingLoanSumOrderByAggregateInput = {
    capitalizedAmount?: SortOrder
  }

  export type RecoveryAgentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecoveryAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecoveryAgentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecoveryAgentScalarRelationFilter = {
    is?: RecoveryAgentWhereInput
    isNot?: RecoveryAgentWhereInput
  }

  export type RecoveryRecordCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    agentId?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RecoveryRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    agentId?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RecoveryRecordMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    agentId?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvestorPayoutListRelationFilter = {
    every?: InvestorPayoutWhereInput
    some?: InvestorPayoutWhereInput
    none?: InvestorPayoutWhereInput
  }

  export type InvestorPayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    investedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorAvgOrderByAggregateInput = {
    investedAmount?: SortOrder
  }

  export type InvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    investedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    investedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorSumOrderByAggregateInput = {
    investedAmount?: SortOrder
  }

  export type InvestorScalarRelationFilter = {
    is?: InvestorWhereInput
    isNot?: InvestorWhereInput
  }

  export type InvestorAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    loanId?: SortOrder
    allocatedAmount?: SortOrder
    expectedReturn?: SortOrder
    actualReturn?: SortOrder
    allocationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorAllocationAvgOrderByAggregateInput = {
    allocatedAmount?: SortOrder
    expectedReturn?: SortOrder
    actualReturn?: SortOrder
  }

  export type InvestorAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    loanId?: SortOrder
    allocatedAmount?: SortOrder
    expectedReturn?: SortOrder
    actualReturn?: SortOrder
    allocationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    loanId?: SortOrder
    allocatedAmount?: SortOrder
    expectedReturn?: SortOrder
    actualReturn?: SortOrder
    allocationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorAllocationSumOrderByAggregateInput = {
    allocatedAmount?: SortOrder
    expectedReturn?: SortOrder
    actualReturn?: SortOrder
  }

  export type InvestorPayoutCountOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    payoutDate?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type InvestorPayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvestorPayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    payoutDate?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type InvestorPayoutMinOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    payoutDate?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type InvestorPayoutSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LoanApplicationNullableScalarRelationFilter = {
    is?: LoanApplicationWhereInput | null
    isNot?: LoanApplicationWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    documentType?: SortOrder
    filePublicId?: SortOrder
    fileUniqueId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    documentType?: SortOrder
    filePublicId?: SortOrder
    fileUniqueId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    loanId?: SortOrder
    documentType?: SortOrder
    filePublicId?: SortOrder
    fileUniqueId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    incurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    incurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    incurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type EnumSmsPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.SmsPurpose | EnumSmsPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumSmsPurposeFilter<$PrismaModel> | $Enums.SmsPurpose
  }

  export type SmsLogCountOrderByAggregateInput = {
    id?: SortOrder
    recipient?: SortOrder
    message?: SortOrder
    purpose?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SmsLogAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type SmsLogMaxOrderByAggregateInput = {
    id?: SortOrder
    recipient?: SortOrder
    message?: SortOrder
    purpose?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SmsLogMinOrderByAggregateInput = {
    id?: SortOrder
    recipient?: SortOrder
    message?: SortOrder
    purpose?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SmsLogSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EnumSmsPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SmsPurpose | EnumSmsPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumSmsPurposeWithAggregatesFilter<$PrismaModel> | $Enums.SmsPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSmsPurposeFilter<$PrismaModel>
    _max?: NestedEnumSmsPurposeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumNormalBalanceFilter<$PrismaModel = never> = {
    equals?: $Enums.NormalBalance | EnumNormalBalanceFieldRefInput<$PrismaModel>
    in?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    not?: NestedEnumNormalBalanceFilter<$PrismaModel> | $Enums.NormalBalance
  }

  export type ChartOfAccountNullableScalarRelationFilter = {
    is?: ChartOfAccountWhereInput | null
    isNot?: ChartOfAccountWhereInput | null
  }

  export type ChartOfAccountListRelationFilter = {
    every?: ChartOfAccountWhereInput
    some?: ChartOfAccountWhereInput
    none?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChartOfAccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountCode?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    parentAccountId?: SortOrder
    normalBalance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChartOfAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountCode?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    parentAccountId?: SortOrder
    normalBalance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChartOfAccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountCode?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    parentAccountId?: SortOrder
    normalBalance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumNormalBalanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NormalBalance | EnumNormalBalanceFieldRefInput<$PrismaModel>
    in?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    not?: NestedEnumNormalBalanceWithAggregatesFilter<$PrismaModel> | $Enums.NormalBalance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNormalBalanceFilter<$PrismaModel>
    _max?: NestedEnumNormalBalanceFilter<$PrismaModel>
  }

  export type TransactionMatrixTransactionTypeComponentCompoundUniqueInput = {
    transactionType: $Enums.TransactionType
    component: $Enums.ChargeType
  }

  export type TransactionMatrixCountOrderByAggregateInput = {
    id?: SortOrder
    transactionType?: SortOrder
    component?: SortOrder
    debitAccountCode?: SortOrder
    creditAccountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMatrixMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionType?: SortOrder
    component?: SortOrder
    debitAccountCode?: SortOrder
    creditAccountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMatrixMinOrderByAggregateInput = {
    id?: SortOrder
    transactionType?: SortOrder
    component?: SortOrder
    debitAccountCode?: SortOrder
    creditAccountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type LoanApplicationCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LoanApplicationCreateWithoutApprovedByInput, LoanApplicationUncheckedCreateWithoutApprovedByInput> | LoanApplicationCreateWithoutApprovedByInput[] | LoanApplicationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutApprovedByInput | LoanApplicationCreateOrConnectWithoutApprovedByInput[]
    createMany?: LoanApplicationCreateManyApprovedByInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type LoanApplicationCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<LoanApplicationCreateWithoutReviewedByInput, LoanApplicationUncheckedCreateWithoutReviewedByInput> | LoanApplicationCreateWithoutReviewedByInput[] | LoanApplicationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutReviewedByInput | LoanApplicationCreateOrConnectWithoutReviewedByInput[]
    createMany?: LoanApplicationCreateManyReviewedByInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type RecoveryAgentCreateNestedOneWithoutUserInput = {
    create?: XOR<RecoveryAgentCreateWithoutUserInput, RecoveryAgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RecoveryAgentCreateOrConnectWithoutUserInput
    connect?: RecoveryAgentWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type InvestorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LoanApplicationCreateWithoutApprovedByInput, LoanApplicationUncheckedCreateWithoutApprovedByInput> | LoanApplicationCreateWithoutApprovedByInput[] | LoanApplicationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutApprovedByInput | LoanApplicationCreateOrConnectWithoutApprovedByInput[]
    createMany?: LoanApplicationCreateManyApprovedByInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<LoanApplicationCreateWithoutReviewedByInput, LoanApplicationUncheckedCreateWithoutReviewedByInput> | LoanApplicationCreateWithoutReviewedByInput[] | LoanApplicationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutReviewedByInput | LoanApplicationCreateOrConnectWithoutReviewedByInput[]
    createMany?: LoanApplicationCreateManyReviewedByInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type RecoveryAgentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<RecoveryAgentCreateWithoutUserInput, RecoveryAgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RecoveryAgentCreateOrConnectWithoutUserInput
    connect?: RecoveryAgentWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type LoanApplicationUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutApprovedByInput, LoanApplicationUncheckedCreateWithoutApprovedByInput> | LoanApplicationCreateWithoutApprovedByInput[] | LoanApplicationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutApprovedByInput | LoanApplicationCreateOrConnectWithoutApprovedByInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutApprovedByInput | LoanApplicationUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LoanApplicationCreateManyApprovedByInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutApprovedByInput | LoanApplicationUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutApprovedByInput | LoanApplicationUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type LoanApplicationUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutReviewedByInput, LoanApplicationUncheckedCreateWithoutReviewedByInput> | LoanApplicationCreateWithoutReviewedByInput[] | LoanApplicationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutReviewedByInput | LoanApplicationCreateOrConnectWithoutReviewedByInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutReviewedByInput | LoanApplicationUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: LoanApplicationCreateManyReviewedByInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutReviewedByInput | LoanApplicationUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutReviewedByInput | LoanApplicationUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type RecoveryAgentUpdateOneWithoutUserNestedInput = {
    create?: XOR<RecoveryAgentCreateWithoutUserInput, RecoveryAgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RecoveryAgentCreateOrConnectWithoutUserInput
    upsert?: RecoveryAgentUpsertWithoutUserInput
    disconnect?: RecoveryAgentWhereInput | boolean
    delete?: RecoveryAgentWhereInput | boolean
    connect?: RecoveryAgentWhereUniqueInput
    update?: XOR<XOR<RecoveryAgentUpdateToOneWithWhereWithoutUserInput, RecoveryAgentUpdateWithoutUserInput>, RecoveryAgentUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutApprovedByInput, LoanApplicationUncheckedCreateWithoutApprovedByInput> | LoanApplicationCreateWithoutApprovedByInput[] | LoanApplicationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutApprovedByInput | LoanApplicationCreateOrConnectWithoutApprovedByInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutApprovedByInput | LoanApplicationUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LoanApplicationCreateManyApprovedByInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutApprovedByInput | LoanApplicationUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutApprovedByInput | LoanApplicationUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutReviewedByInput, LoanApplicationUncheckedCreateWithoutReviewedByInput> | LoanApplicationCreateWithoutReviewedByInput[] | LoanApplicationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutReviewedByInput | LoanApplicationCreateOrConnectWithoutReviewedByInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutReviewedByInput | LoanApplicationUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: LoanApplicationCreateManyReviewedByInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutReviewedByInput | LoanApplicationUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutReviewedByInput | LoanApplicationUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<RecoveryAgentCreateWithoutUserInput, RecoveryAgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RecoveryAgentCreateOrConnectWithoutUserInput
    upsert?: RecoveryAgentUpsertWithoutUserInput
    disconnect?: RecoveryAgentWhereInput | boolean
    delete?: RecoveryAgentWhereInput | boolean
    connect?: RecoveryAgentWhereUniqueInput
    update?: XOR<XOR<RecoveryAgentUpdateToOneWithWhereWithoutUserInput, RecoveryAgentUpdateWithoutUserInput>, RecoveryAgentUncheckedUpdateWithoutUserInput>
  }

  export type BankDetailCreateNestedManyWithoutClientInput = {
    create?: XOR<BankDetailCreateWithoutClientInput, BankDetailUncheckedCreateWithoutClientInput> | BankDetailCreateWithoutClientInput[] | BankDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BankDetailCreateOrConnectWithoutClientInput | BankDetailCreateOrConnectWithoutClientInput[]
    createMany?: BankDetailCreateManyClientInputEnvelope
    connect?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
  }

  export type ClientAddressCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EmploymentDetailCreateNestedManyWithoutClientInput = {
    create?: XOR<EmploymentDetailCreateWithoutClientInput, EmploymentDetailUncheckedCreateWithoutClientInput> | EmploymentDetailCreateWithoutClientInput[] | EmploymentDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EmploymentDetailCreateOrConnectWithoutClientInput | EmploymentDetailCreateOrConnectWithoutClientInput[]
    createMany?: EmploymentDetailCreateManyClientInputEnvelope
    connect?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LoanApplicationCreateNestedManyWithoutClientInput = {
    create?: XOR<LoanApplicationCreateWithoutClientInput, LoanApplicationUncheckedCreateWithoutClientInput> | LoanApplicationCreateWithoutClientInput[] | LoanApplicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutClientInput | LoanApplicationCreateOrConnectWithoutClientInput[]
    createMany?: LoanApplicationCreateManyClientInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type RefereeCreateNestedManyWithoutClientInput = {
    create?: XOR<RefereeCreateWithoutClientInput, RefereeUncheckedCreateWithoutClientInput> | RefereeCreateWithoutClientInput[] | RefereeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RefereeCreateOrConnectWithoutClientInput | RefereeCreateOrConnectWithoutClientInput[]
    createMany?: RefereeCreateManyClientInputEnvelope
    connect?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
  }

  export type BankDetailUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<BankDetailCreateWithoutClientInput, BankDetailUncheckedCreateWithoutClientInput> | BankDetailCreateWithoutClientInput[] | BankDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BankDetailCreateOrConnectWithoutClientInput | BankDetailCreateOrConnectWithoutClientInput[]
    createMany?: BankDetailCreateManyClientInputEnvelope
    connect?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
  }

  export type ClientAddressUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EmploymentDetailUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<EmploymentDetailCreateWithoutClientInput, EmploymentDetailUncheckedCreateWithoutClientInput> | EmploymentDetailCreateWithoutClientInput[] | EmploymentDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EmploymentDetailCreateOrConnectWithoutClientInput | EmploymentDetailCreateOrConnectWithoutClientInput[]
    createMany?: EmploymentDetailCreateManyClientInputEnvelope
    connect?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LoanApplicationCreateWithoutClientInput, LoanApplicationUncheckedCreateWithoutClientInput> | LoanApplicationCreateWithoutClientInput[] | LoanApplicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutClientInput | LoanApplicationCreateOrConnectWithoutClientInput[]
    createMany?: LoanApplicationCreateManyClientInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type RefereeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<RefereeCreateWithoutClientInput, RefereeUncheckedCreateWithoutClientInput> | RefereeCreateWithoutClientInput[] | RefereeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RefereeCreateOrConnectWithoutClientInput | RefereeCreateOrConnectWithoutClientInput[]
    createMany?: RefereeCreateManyClientInputEnvelope
    connect?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
  }

  export type EnumTitleFieldUpdateOperationsInput = {
    set?: $Enums.Title
  }

  export type EnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumClientStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClientStatus
  }

  export type BankDetailUpdateManyWithoutClientNestedInput = {
    create?: XOR<BankDetailCreateWithoutClientInput, BankDetailUncheckedCreateWithoutClientInput> | BankDetailCreateWithoutClientInput[] | BankDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BankDetailCreateOrConnectWithoutClientInput | BankDetailCreateOrConnectWithoutClientInput[]
    upsert?: BankDetailUpsertWithWhereUniqueWithoutClientInput | BankDetailUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BankDetailCreateManyClientInputEnvelope
    set?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    disconnect?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    delete?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    connect?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    update?: BankDetailUpdateWithWhereUniqueWithoutClientInput | BankDetailUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BankDetailUpdateManyWithWhereWithoutClientInput | BankDetailUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BankDetailScalarWhereInput | BankDetailScalarWhereInput[]
  }

  export type ClientAddressUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    upsert?: ClientAddressUpsertWithWhereUniqueWithoutClientInput | ClientAddressUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    set?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    disconnect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    delete?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    update?: ClientAddressUpdateWithWhereUniqueWithoutClientInput | ClientAddressUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientAddressUpdateManyWithWhereWithoutClientInput | ClientAddressUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
  }

  export type UserUpdateOneWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientInput, UserUpdateWithoutClientInput>, UserUncheckedUpdateWithoutClientInput>
  }

  export type DocumentUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EmploymentDetailUpdateManyWithoutClientNestedInput = {
    create?: XOR<EmploymentDetailCreateWithoutClientInput, EmploymentDetailUncheckedCreateWithoutClientInput> | EmploymentDetailCreateWithoutClientInput[] | EmploymentDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EmploymentDetailCreateOrConnectWithoutClientInput | EmploymentDetailCreateOrConnectWithoutClientInput[]
    upsert?: EmploymentDetailUpsertWithWhereUniqueWithoutClientInput | EmploymentDetailUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EmploymentDetailCreateManyClientInputEnvelope
    set?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    disconnect?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    delete?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    connect?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    update?: EmploymentDetailUpdateWithWhereUniqueWithoutClientInput | EmploymentDetailUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EmploymentDetailUpdateManyWithWhereWithoutClientInput | EmploymentDetailUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EmploymentDetailScalarWhereInput | EmploymentDetailScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LoanApplicationUpdateManyWithoutClientNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutClientInput, LoanApplicationUncheckedCreateWithoutClientInput> | LoanApplicationCreateWithoutClientInput[] | LoanApplicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutClientInput | LoanApplicationCreateOrConnectWithoutClientInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutClientInput | LoanApplicationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LoanApplicationCreateManyClientInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutClientInput | LoanApplicationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutClientInput | LoanApplicationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type RefereeUpdateManyWithoutClientNestedInput = {
    create?: XOR<RefereeCreateWithoutClientInput, RefereeUncheckedCreateWithoutClientInput> | RefereeCreateWithoutClientInput[] | RefereeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RefereeCreateOrConnectWithoutClientInput | RefereeCreateOrConnectWithoutClientInput[]
    upsert?: RefereeUpsertWithWhereUniqueWithoutClientInput | RefereeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RefereeCreateManyClientInputEnvelope
    set?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    disconnect?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    delete?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    connect?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    update?: RefereeUpdateWithWhereUniqueWithoutClientInput | RefereeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RefereeUpdateManyWithWhereWithoutClientInput | RefereeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RefereeScalarWhereInput | RefereeScalarWhereInput[]
  }

  export type BankDetailUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<BankDetailCreateWithoutClientInput, BankDetailUncheckedCreateWithoutClientInput> | BankDetailCreateWithoutClientInput[] | BankDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BankDetailCreateOrConnectWithoutClientInput | BankDetailCreateOrConnectWithoutClientInput[]
    upsert?: BankDetailUpsertWithWhereUniqueWithoutClientInput | BankDetailUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BankDetailCreateManyClientInputEnvelope
    set?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    disconnect?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    delete?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    connect?: BankDetailWhereUniqueInput | BankDetailWhereUniqueInput[]
    update?: BankDetailUpdateWithWhereUniqueWithoutClientInput | BankDetailUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BankDetailUpdateManyWithWhereWithoutClientInput | BankDetailUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BankDetailScalarWhereInput | BankDetailScalarWhereInput[]
  }

  export type ClientAddressUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    upsert?: ClientAddressUpsertWithWhereUniqueWithoutClientInput | ClientAddressUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    set?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    disconnect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    delete?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    update?: ClientAddressUpdateWithWhereUniqueWithoutClientInput | ClientAddressUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientAddressUpdateManyWithWhereWithoutClientInput | ClientAddressUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<EmploymentDetailCreateWithoutClientInput, EmploymentDetailUncheckedCreateWithoutClientInput> | EmploymentDetailCreateWithoutClientInput[] | EmploymentDetailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EmploymentDetailCreateOrConnectWithoutClientInput | EmploymentDetailCreateOrConnectWithoutClientInput[]
    upsert?: EmploymentDetailUpsertWithWhereUniqueWithoutClientInput | EmploymentDetailUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EmploymentDetailCreateManyClientInputEnvelope
    set?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    disconnect?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    delete?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    connect?: EmploymentDetailWhereUniqueInput | EmploymentDetailWhereUniqueInput[]
    update?: EmploymentDetailUpdateWithWhereUniqueWithoutClientInput | EmploymentDetailUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EmploymentDetailUpdateManyWithWhereWithoutClientInput | EmploymentDetailUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EmploymentDetailScalarWhereInput | EmploymentDetailScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LoanApplicationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutClientInput, LoanApplicationUncheckedCreateWithoutClientInput> | LoanApplicationCreateWithoutClientInput[] | LoanApplicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutClientInput | LoanApplicationCreateOrConnectWithoutClientInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutClientInput | LoanApplicationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LoanApplicationCreateManyClientInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutClientInput | LoanApplicationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutClientInput | LoanApplicationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type RefereeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<RefereeCreateWithoutClientInput, RefereeUncheckedCreateWithoutClientInput> | RefereeCreateWithoutClientInput[] | RefereeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: RefereeCreateOrConnectWithoutClientInput | RefereeCreateOrConnectWithoutClientInput[]
    upsert?: RefereeUpsertWithWhereUniqueWithoutClientInput | RefereeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: RefereeCreateManyClientInputEnvelope
    set?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    disconnect?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    delete?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    connect?: RefereeWhereUniqueInput | RefereeWhereUniqueInput[]
    update?: RefereeUpdateWithWhereUniqueWithoutClientInput | RefereeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: RefereeUpdateManyWithWhereWithoutClientInput | RefereeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: RefereeScalarWhereInput | RefereeScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutAddressesInput = {
    create?: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAddressesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAddressesInput
    upsert?: ClientUpsertWithoutAddressesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAddressesInput, ClientUpdateWithoutAddressesInput>, ClientUncheckedUpdateWithoutAddressesInput>
  }

  export type ClientCreateNestedOneWithoutEmploymentDetailsInput = {
    create?: XOR<ClientCreateWithoutEmploymentDetailsInput, ClientUncheckedCreateWithoutEmploymentDetailsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEmploymentDetailsInput
    connect?: ClientWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumEmploymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentType
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClientUpdateOneRequiredWithoutEmploymentDetailsNestedInput = {
    create?: XOR<ClientCreateWithoutEmploymentDetailsInput, ClientUncheckedCreateWithoutEmploymentDetailsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEmploymentDetailsInput
    upsert?: ClientUpsertWithoutEmploymentDetailsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutEmploymentDetailsInput, ClientUpdateWithoutEmploymentDetailsInput>, ClientUncheckedUpdateWithoutEmploymentDetailsInput>
  }

  export type ClientCreateNestedOneWithoutRefereesInput = {
    create?: XOR<ClientCreateWithoutRefereesInput, ClientUncheckedCreateWithoutRefereesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRefereesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutRefereesNestedInput = {
    create?: XOR<ClientCreateWithoutRefereesInput, ClientUncheckedCreateWithoutRefereesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRefereesInput
    upsert?: ClientUpsertWithoutRefereesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutRefereesInput, ClientUpdateWithoutRefereesInput>, ClientUncheckedUpdateWithoutRefereesInput>
  }

  export type ClientCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<ClientCreateWithoutBankDetailsInput, ClientUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBankDetailsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutBankDetailsNestedInput = {
    create?: XOR<ClientCreateWithoutBankDetailsInput, ClientUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBankDetailsInput
    upsert?: ClientUpsertWithoutBankDetailsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutBankDetailsInput, ClientUpdateWithoutBankDetailsInput>, ClientUncheckedUpdateWithoutBankDetailsInput>
  }

  export type DocumentCreateNestedManyWithoutLoanInput = {
    create?: XOR<DocumentCreateWithoutLoanInput, DocumentUncheckedCreateWithoutLoanInput> | DocumentCreateWithoutLoanInput[] | DocumentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLoanInput | DocumentCreateOrConnectWithoutLoanInput[]
    createMany?: DocumentCreateManyLoanInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GuarantorCreateNestedManyWithoutLoanInput = {
    create?: XOR<GuarantorCreateWithoutLoanInput, GuarantorUncheckedCreateWithoutLoanInput> | GuarantorCreateWithoutLoanInput[] | GuarantorUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: GuarantorCreateOrConnectWithoutLoanInput | GuarantorCreateOrConnectWithoutLoanInput[]
    createMany?: GuarantorCreateManyLoanInputEnvelope
    connect?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
  }

  export type InvestorAllocationCreateNestedManyWithoutLoanInput = {
    create?: XOR<InvestorAllocationCreateWithoutLoanInput, InvestorAllocationUncheckedCreateWithoutLoanInput> | InvestorAllocationCreateWithoutLoanInput[] | InvestorAllocationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutLoanInput | InvestorAllocationCreateOrConnectWithoutLoanInput[]
    createMany?: InvestorAllocationCreateManyLoanInputEnvelope
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutLoanInput = {
    create?: XOR<InvoiceCreateWithoutLoanInput, InvoiceUncheckedCreateWithoutLoanInput> | InvoiceCreateWithoutLoanInput[] | InvoiceUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLoanInput | InvoiceCreateOrConnectWithoutLoanInput[]
    createMany?: InvoiceCreateManyLoanInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutApprovedLoansInput = {
    create?: XOR<UserCreateWithoutApprovedLoansInput, UserUncheckedCreateWithoutApprovedLoansInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLoansInput
    connect?: UserWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutLoanApplicationsInput = {
    create?: XOR<ClientCreateWithoutLoanApplicationsInput, ClientUncheckedCreateWithoutLoanApplicationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLoanApplicationsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedLoansInput = {
    create?: XOR<UserCreateWithoutReviewedLoansInput, UserUncheckedCreateWithoutReviewedLoansInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedLoansInput
    connect?: UserWhereUniqueInput
  }

  export type LoanDisbursementCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanDisbursementCreateWithoutLoanInput, LoanDisbursementUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanDisbursementCreateOrConnectWithoutLoanInput
    connect?: LoanDisbursementWhereUniqueInput
  }

  export type LoanFinancialCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanFinancialCreateWithoutLoanInput, LoanFinancialUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanFinancialCreateOrConnectWithoutLoanInput
    connect?: LoanFinancialWhereUniqueInput
  }

  export type LoanQualificationCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanQualificationCreateWithoutLoanInput, LoanQualificationUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanQualificationCreateOrConnectWithoutLoanInput
    connect?: LoanQualificationWhereUniqueInput
  }

  export type LoanSecurityCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanSecurityCreateWithoutLoanInput, LoanSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanSecurityCreateOrConnectWithoutLoanInput
    connect?: LoanSecurityWhereUniqueInput
  }

  export type NonPerformingLoanCreateNestedOneWithoutLoanInput = {
    create?: XOR<NonPerformingLoanCreateWithoutLoanInput, NonPerformingLoanUncheckedCreateWithoutLoanInput>
    connectOrCreate?: NonPerformingLoanCreateOrConnectWithoutLoanInput
    connect?: NonPerformingLoanWhereUniqueInput
  }

  export type RecoveryRecordCreateNestedManyWithoutLoanInput = {
    create?: XOR<RecoveryRecordCreateWithoutLoanInput, RecoveryRecordUncheckedCreateWithoutLoanInput> | RecoveryRecordCreateWithoutLoanInput[] | RecoveryRecordUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutLoanInput | RecoveryRecordCreateOrConnectWithoutLoanInput[]
    createMany?: RecoveryRecordCreateManyLoanInputEnvelope
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
  }

  export type RepaymentCreateNestedManyWithoutLoanInput = {
    create?: XOR<RepaymentCreateWithoutLoanInput, RepaymentUncheckedCreateWithoutLoanInput> | RepaymentCreateWithoutLoanInput[] | RepaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RepaymentCreateOrConnectWithoutLoanInput | RepaymentCreateOrConnectWithoutLoanInput[]
    createMany?: RepaymentCreateManyLoanInputEnvelope
    connect?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
  }

  export type VehicleSecurityCreateNestedOneWithoutLoanInput = {
    create?: XOR<VehicleSecurityCreateWithoutLoanInput, VehicleSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: VehicleSecurityCreateOrConnectWithoutLoanInput
    connect?: VehicleSecurityWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<DocumentCreateWithoutLoanInput, DocumentUncheckedCreateWithoutLoanInput> | DocumentCreateWithoutLoanInput[] | DocumentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLoanInput | DocumentCreateOrConnectWithoutLoanInput[]
    createMany?: DocumentCreateManyLoanInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GuarantorUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<GuarantorCreateWithoutLoanInput, GuarantorUncheckedCreateWithoutLoanInput> | GuarantorCreateWithoutLoanInput[] | GuarantorUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: GuarantorCreateOrConnectWithoutLoanInput | GuarantorCreateOrConnectWithoutLoanInput[]
    createMany?: GuarantorCreateManyLoanInputEnvelope
    connect?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
  }

  export type InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<InvestorAllocationCreateWithoutLoanInput, InvestorAllocationUncheckedCreateWithoutLoanInput> | InvestorAllocationCreateWithoutLoanInput[] | InvestorAllocationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutLoanInput | InvestorAllocationCreateOrConnectWithoutLoanInput[]
    createMany?: InvestorAllocationCreateManyLoanInputEnvelope
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<InvoiceCreateWithoutLoanInput, InvoiceUncheckedCreateWithoutLoanInput> | InvoiceCreateWithoutLoanInput[] | InvoiceUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLoanInput | InvoiceCreateOrConnectWithoutLoanInput[]
    createMany?: InvoiceCreateManyLoanInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanDisbursementCreateWithoutLoanInput, LoanDisbursementUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanDisbursementCreateOrConnectWithoutLoanInput
    connect?: LoanDisbursementWhereUniqueInput
  }

  export type LoanFinancialUncheckedCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanFinancialCreateWithoutLoanInput, LoanFinancialUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanFinancialCreateOrConnectWithoutLoanInput
    connect?: LoanFinancialWhereUniqueInput
  }

  export type LoanQualificationUncheckedCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanQualificationCreateWithoutLoanInput, LoanQualificationUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanQualificationCreateOrConnectWithoutLoanInput
    connect?: LoanQualificationWhereUniqueInput
  }

  export type LoanSecurityUncheckedCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoanSecurityCreateWithoutLoanInput, LoanSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanSecurityCreateOrConnectWithoutLoanInput
    connect?: LoanSecurityWhereUniqueInput
  }

  export type NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput = {
    create?: XOR<NonPerformingLoanCreateWithoutLoanInput, NonPerformingLoanUncheckedCreateWithoutLoanInput>
    connectOrCreate?: NonPerformingLoanCreateOrConnectWithoutLoanInput
    connect?: NonPerformingLoanWhereUniqueInput
  }

  export type RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<RecoveryRecordCreateWithoutLoanInput, RecoveryRecordUncheckedCreateWithoutLoanInput> | RecoveryRecordCreateWithoutLoanInput[] | RecoveryRecordUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutLoanInput | RecoveryRecordCreateOrConnectWithoutLoanInput[]
    createMany?: RecoveryRecordCreateManyLoanInputEnvelope
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
  }

  export type RepaymentUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<RepaymentCreateWithoutLoanInput, RepaymentUncheckedCreateWithoutLoanInput> | RepaymentCreateWithoutLoanInput[] | RepaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RepaymentCreateOrConnectWithoutLoanInput | RepaymentCreateOrConnectWithoutLoanInput[]
    createMany?: RepaymentCreateManyLoanInputEnvelope
    connect?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
  }

  export type VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput = {
    create?: XOR<VehicleSecurityCreateWithoutLoanInput, VehicleSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: VehicleSecurityCreateOrConnectWithoutLoanInput
    connect?: VehicleSecurityWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumQualificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.QualificationType | null
  }

  export type EnumLoanApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.LoanApplicationStatus
  }

  export type DocumentUpdateManyWithoutLoanNestedInput = {
    create?: XOR<DocumentCreateWithoutLoanInput, DocumentUncheckedCreateWithoutLoanInput> | DocumentCreateWithoutLoanInput[] | DocumentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLoanInput | DocumentCreateOrConnectWithoutLoanInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLoanInput | DocumentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: DocumentCreateManyLoanInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLoanInput | DocumentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLoanInput | DocumentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GuarantorUpdateManyWithoutLoanNestedInput = {
    create?: XOR<GuarantorCreateWithoutLoanInput, GuarantorUncheckedCreateWithoutLoanInput> | GuarantorCreateWithoutLoanInput[] | GuarantorUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: GuarantorCreateOrConnectWithoutLoanInput | GuarantorCreateOrConnectWithoutLoanInput[]
    upsert?: GuarantorUpsertWithWhereUniqueWithoutLoanInput | GuarantorUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: GuarantorCreateManyLoanInputEnvelope
    set?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    disconnect?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    delete?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    connect?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    update?: GuarantorUpdateWithWhereUniqueWithoutLoanInput | GuarantorUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: GuarantorUpdateManyWithWhereWithoutLoanInput | GuarantorUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: GuarantorScalarWhereInput | GuarantorScalarWhereInput[]
  }

  export type InvestorAllocationUpdateManyWithoutLoanNestedInput = {
    create?: XOR<InvestorAllocationCreateWithoutLoanInput, InvestorAllocationUncheckedCreateWithoutLoanInput> | InvestorAllocationCreateWithoutLoanInput[] | InvestorAllocationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutLoanInput | InvestorAllocationCreateOrConnectWithoutLoanInput[]
    upsert?: InvestorAllocationUpsertWithWhereUniqueWithoutLoanInput | InvestorAllocationUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: InvestorAllocationCreateManyLoanInputEnvelope
    set?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    disconnect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    delete?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    update?: InvestorAllocationUpdateWithWhereUniqueWithoutLoanInput | InvestorAllocationUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: InvestorAllocationUpdateManyWithWhereWithoutLoanInput | InvestorAllocationUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: InvestorAllocationScalarWhereInput | InvestorAllocationScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutLoanNestedInput = {
    create?: XOR<InvoiceCreateWithoutLoanInput, InvoiceUncheckedCreateWithoutLoanInput> | InvoiceCreateWithoutLoanInput[] | InvoiceUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLoanInput | InvoiceCreateOrConnectWithoutLoanInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLoanInput | InvoiceUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: InvoiceCreateManyLoanInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLoanInput | InvoiceUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLoanInput | InvoiceUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserUpdateOneWithoutApprovedLoansNestedInput = {
    create?: XOR<UserCreateWithoutApprovedLoansInput, UserUncheckedCreateWithoutApprovedLoansInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLoansInput
    upsert?: UserUpsertWithoutApprovedLoansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedLoansInput, UserUpdateWithoutApprovedLoansInput>, UserUncheckedUpdateWithoutApprovedLoansInput>
  }

  export type ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput = {
    create?: XOR<ClientCreateWithoutLoanApplicationsInput, ClientUncheckedCreateWithoutLoanApplicationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLoanApplicationsInput
    upsert?: ClientUpsertWithoutLoanApplicationsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutLoanApplicationsInput, ClientUpdateWithoutLoanApplicationsInput>, ClientUncheckedUpdateWithoutLoanApplicationsInput>
  }

  export type UserUpdateOneWithoutReviewedLoansNestedInput = {
    create?: XOR<UserCreateWithoutReviewedLoansInput, UserUncheckedCreateWithoutReviewedLoansInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedLoansInput
    upsert?: UserUpsertWithoutReviewedLoansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedLoansInput, UserUpdateWithoutReviewedLoansInput>, UserUncheckedUpdateWithoutReviewedLoansInput>
  }

  export type LoanDisbursementUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanDisbursementCreateWithoutLoanInput, LoanDisbursementUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanDisbursementCreateOrConnectWithoutLoanInput
    upsert?: LoanDisbursementUpsertWithoutLoanInput
    disconnect?: LoanDisbursementWhereInput | boolean
    delete?: LoanDisbursementWhereInput | boolean
    connect?: LoanDisbursementWhereUniqueInput
    update?: XOR<XOR<LoanDisbursementUpdateToOneWithWhereWithoutLoanInput, LoanDisbursementUpdateWithoutLoanInput>, LoanDisbursementUncheckedUpdateWithoutLoanInput>
  }

  export type LoanFinancialUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanFinancialCreateWithoutLoanInput, LoanFinancialUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanFinancialCreateOrConnectWithoutLoanInput
    upsert?: LoanFinancialUpsertWithoutLoanInput
    disconnect?: LoanFinancialWhereInput | boolean
    delete?: LoanFinancialWhereInput | boolean
    connect?: LoanFinancialWhereUniqueInput
    update?: XOR<XOR<LoanFinancialUpdateToOneWithWhereWithoutLoanInput, LoanFinancialUpdateWithoutLoanInput>, LoanFinancialUncheckedUpdateWithoutLoanInput>
  }

  export type LoanQualificationUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanQualificationCreateWithoutLoanInput, LoanQualificationUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanQualificationCreateOrConnectWithoutLoanInput
    upsert?: LoanQualificationUpsertWithoutLoanInput
    disconnect?: LoanQualificationWhereInput | boolean
    delete?: LoanQualificationWhereInput | boolean
    connect?: LoanQualificationWhereUniqueInput
    update?: XOR<XOR<LoanQualificationUpdateToOneWithWhereWithoutLoanInput, LoanQualificationUpdateWithoutLoanInput>, LoanQualificationUncheckedUpdateWithoutLoanInput>
  }

  export type LoanSecurityUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanSecurityCreateWithoutLoanInput, LoanSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanSecurityCreateOrConnectWithoutLoanInput
    upsert?: LoanSecurityUpsertWithoutLoanInput
    disconnect?: LoanSecurityWhereInput | boolean
    delete?: LoanSecurityWhereInput | boolean
    connect?: LoanSecurityWhereUniqueInput
    update?: XOR<XOR<LoanSecurityUpdateToOneWithWhereWithoutLoanInput, LoanSecurityUpdateWithoutLoanInput>, LoanSecurityUncheckedUpdateWithoutLoanInput>
  }

  export type NonPerformingLoanUpdateOneWithoutLoanNestedInput = {
    create?: XOR<NonPerformingLoanCreateWithoutLoanInput, NonPerformingLoanUncheckedCreateWithoutLoanInput>
    connectOrCreate?: NonPerformingLoanCreateOrConnectWithoutLoanInput
    upsert?: NonPerformingLoanUpsertWithoutLoanInput
    disconnect?: NonPerformingLoanWhereInput | boolean
    delete?: NonPerformingLoanWhereInput | boolean
    connect?: NonPerformingLoanWhereUniqueInput
    update?: XOR<XOR<NonPerformingLoanUpdateToOneWithWhereWithoutLoanInput, NonPerformingLoanUpdateWithoutLoanInput>, NonPerformingLoanUncheckedUpdateWithoutLoanInput>
  }

  export type RecoveryRecordUpdateManyWithoutLoanNestedInput = {
    create?: XOR<RecoveryRecordCreateWithoutLoanInput, RecoveryRecordUncheckedCreateWithoutLoanInput> | RecoveryRecordCreateWithoutLoanInput[] | RecoveryRecordUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutLoanInput | RecoveryRecordCreateOrConnectWithoutLoanInput[]
    upsert?: RecoveryRecordUpsertWithWhereUniqueWithoutLoanInput | RecoveryRecordUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: RecoveryRecordCreateManyLoanInputEnvelope
    set?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    disconnect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    delete?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    update?: RecoveryRecordUpdateWithWhereUniqueWithoutLoanInput | RecoveryRecordUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: RecoveryRecordUpdateManyWithWhereWithoutLoanInput | RecoveryRecordUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: RecoveryRecordScalarWhereInput | RecoveryRecordScalarWhereInput[]
  }

  export type RepaymentUpdateManyWithoutLoanNestedInput = {
    create?: XOR<RepaymentCreateWithoutLoanInput, RepaymentUncheckedCreateWithoutLoanInput> | RepaymentCreateWithoutLoanInput[] | RepaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RepaymentCreateOrConnectWithoutLoanInput | RepaymentCreateOrConnectWithoutLoanInput[]
    upsert?: RepaymentUpsertWithWhereUniqueWithoutLoanInput | RepaymentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: RepaymentCreateManyLoanInputEnvelope
    set?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    disconnect?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    delete?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    connect?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    update?: RepaymentUpdateWithWhereUniqueWithoutLoanInput | RepaymentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: RepaymentUpdateManyWithWhereWithoutLoanInput | RepaymentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: RepaymentScalarWhereInput | RepaymentScalarWhereInput[]
  }

  export type VehicleSecurityUpdateOneWithoutLoanNestedInput = {
    create?: XOR<VehicleSecurityCreateWithoutLoanInput, VehicleSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: VehicleSecurityCreateOrConnectWithoutLoanInput
    upsert?: VehicleSecurityUpsertWithoutLoanInput
    disconnect?: VehicleSecurityWhereInput | boolean
    delete?: VehicleSecurityWhereInput | boolean
    connect?: VehicleSecurityWhereUniqueInput
    update?: XOR<XOR<VehicleSecurityUpdateToOneWithWhereWithoutLoanInput, VehicleSecurityUpdateWithoutLoanInput>, VehicleSecurityUncheckedUpdateWithoutLoanInput>
  }

  export type DocumentUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<DocumentCreateWithoutLoanInput, DocumentUncheckedCreateWithoutLoanInput> | DocumentCreateWithoutLoanInput[] | DocumentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLoanInput | DocumentCreateOrConnectWithoutLoanInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLoanInput | DocumentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: DocumentCreateManyLoanInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLoanInput | DocumentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLoanInput | DocumentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GuarantorUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<GuarantorCreateWithoutLoanInput, GuarantorUncheckedCreateWithoutLoanInput> | GuarantorCreateWithoutLoanInput[] | GuarantorUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: GuarantorCreateOrConnectWithoutLoanInput | GuarantorCreateOrConnectWithoutLoanInput[]
    upsert?: GuarantorUpsertWithWhereUniqueWithoutLoanInput | GuarantorUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: GuarantorCreateManyLoanInputEnvelope
    set?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    disconnect?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    delete?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    connect?: GuarantorWhereUniqueInput | GuarantorWhereUniqueInput[]
    update?: GuarantorUpdateWithWhereUniqueWithoutLoanInput | GuarantorUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: GuarantorUpdateManyWithWhereWithoutLoanInput | GuarantorUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: GuarantorScalarWhereInput | GuarantorScalarWhereInput[]
  }

  export type InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<InvestorAllocationCreateWithoutLoanInput, InvestorAllocationUncheckedCreateWithoutLoanInput> | InvestorAllocationCreateWithoutLoanInput[] | InvestorAllocationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutLoanInput | InvestorAllocationCreateOrConnectWithoutLoanInput[]
    upsert?: InvestorAllocationUpsertWithWhereUniqueWithoutLoanInput | InvestorAllocationUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: InvestorAllocationCreateManyLoanInputEnvelope
    set?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    disconnect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    delete?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    update?: InvestorAllocationUpdateWithWhereUniqueWithoutLoanInput | InvestorAllocationUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: InvestorAllocationUpdateManyWithWhereWithoutLoanInput | InvestorAllocationUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: InvestorAllocationScalarWhereInput | InvestorAllocationScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<InvoiceCreateWithoutLoanInput, InvoiceUncheckedCreateWithoutLoanInput> | InvoiceCreateWithoutLoanInput[] | InvoiceUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLoanInput | InvoiceCreateOrConnectWithoutLoanInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLoanInput | InvoiceUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: InvoiceCreateManyLoanInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLoanInput | InvoiceUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLoanInput | InvoiceUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanDisbursementCreateWithoutLoanInput, LoanDisbursementUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanDisbursementCreateOrConnectWithoutLoanInput
    upsert?: LoanDisbursementUpsertWithoutLoanInput
    disconnect?: LoanDisbursementWhereInput | boolean
    delete?: LoanDisbursementWhereInput | boolean
    connect?: LoanDisbursementWhereUniqueInput
    update?: XOR<XOR<LoanDisbursementUpdateToOneWithWhereWithoutLoanInput, LoanDisbursementUpdateWithoutLoanInput>, LoanDisbursementUncheckedUpdateWithoutLoanInput>
  }

  export type LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanFinancialCreateWithoutLoanInput, LoanFinancialUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanFinancialCreateOrConnectWithoutLoanInput
    upsert?: LoanFinancialUpsertWithoutLoanInput
    disconnect?: LoanFinancialWhereInput | boolean
    delete?: LoanFinancialWhereInput | boolean
    connect?: LoanFinancialWhereUniqueInput
    update?: XOR<XOR<LoanFinancialUpdateToOneWithWhereWithoutLoanInput, LoanFinancialUpdateWithoutLoanInput>, LoanFinancialUncheckedUpdateWithoutLoanInput>
  }

  export type LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanQualificationCreateWithoutLoanInput, LoanQualificationUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanQualificationCreateOrConnectWithoutLoanInput
    upsert?: LoanQualificationUpsertWithoutLoanInput
    disconnect?: LoanQualificationWhereInput | boolean
    delete?: LoanQualificationWhereInput | boolean
    connect?: LoanQualificationWhereUniqueInput
    update?: XOR<XOR<LoanQualificationUpdateToOneWithWhereWithoutLoanInput, LoanQualificationUpdateWithoutLoanInput>, LoanQualificationUncheckedUpdateWithoutLoanInput>
  }

  export type LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput = {
    create?: XOR<LoanSecurityCreateWithoutLoanInput, LoanSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoanSecurityCreateOrConnectWithoutLoanInput
    upsert?: LoanSecurityUpsertWithoutLoanInput
    disconnect?: LoanSecurityWhereInput | boolean
    delete?: LoanSecurityWhereInput | boolean
    connect?: LoanSecurityWhereUniqueInput
    update?: XOR<XOR<LoanSecurityUpdateToOneWithWhereWithoutLoanInput, LoanSecurityUpdateWithoutLoanInput>, LoanSecurityUncheckedUpdateWithoutLoanInput>
  }

  export type NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput = {
    create?: XOR<NonPerformingLoanCreateWithoutLoanInput, NonPerformingLoanUncheckedCreateWithoutLoanInput>
    connectOrCreate?: NonPerformingLoanCreateOrConnectWithoutLoanInput
    upsert?: NonPerformingLoanUpsertWithoutLoanInput
    disconnect?: NonPerformingLoanWhereInput | boolean
    delete?: NonPerformingLoanWhereInput | boolean
    connect?: NonPerformingLoanWhereUniqueInput
    update?: XOR<XOR<NonPerformingLoanUpdateToOneWithWhereWithoutLoanInput, NonPerformingLoanUpdateWithoutLoanInput>, NonPerformingLoanUncheckedUpdateWithoutLoanInput>
  }

  export type RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<RecoveryRecordCreateWithoutLoanInput, RecoveryRecordUncheckedCreateWithoutLoanInput> | RecoveryRecordCreateWithoutLoanInput[] | RecoveryRecordUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutLoanInput | RecoveryRecordCreateOrConnectWithoutLoanInput[]
    upsert?: RecoveryRecordUpsertWithWhereUniqueWithoutLoanInput | RecoveryRecordUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: RecoveryRecordCreateManyLoanInputEnvelope
    set?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    disconnect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    delete?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    update?: RecoveryRecordUpdateWithWhereUniqueWithoutLoanInput | RecoveryRecordUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: RecoveryRecordUpdateManyWithWhereWithoutLoanInput | RecoveryRecordUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: RecoveryRecordScalarWhereInput | RecoveryRecordScalarWhereInput[]
  }

  export type RepaymentUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<RepaymentCreateWithoutLoanInput, RepaymentUncheckedCreateWithoutLoanInput> | RepaymentCreateWithoutLoanInput[] | RepaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: RepaymentCreateOrConnectWithoutLoanInput | RepaymentCreateOrConnectWithoutLoanInput[]
    upsert?: RepaymentUpsertWithWhereUniqueWithoutLoanInput | RepaymentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: RepaymentCreateManyLoanInputEnvelope
    set?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    disconnect?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    delete?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    connect?: RepaymentWhereUniqueInput | RepaymentWhereUniqueInput[]
    update?: RepaymentUpdateWithWhereUniqueWithoutLoanInput | RepaymentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: RepaymentUpdateManyWithWhereWithoutLoanInput | RepaymentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: RepaymentScalarWhereInput | RepaymentScalarWhereInput[]
  }

  export type VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput = {
    create?: XOR<VehicleSecurityCreateWithoutLoanInput, VehicleSecurityUncheckedCreateWithoutLoanInput>
    connectOrCreate?: VehicleSecurityCreateOrConnectWithoutLoanInput
    upsert?: VehicleSecurityUpsertWithoutLoanInput
    disconnect?: VehicleSecurityWhereInput | boolean
    delete?: VehicleSecurityWhereInput | boolean
    connect?: VehicleSecurityWhereUniqueInput
    update?: XOR<XOR<VehicleSecurityUpdateToOneWithWhereWithoutLoanInput, VehicleSecurityUpdateWithoutLoanInput>, VehicleSecurityUncheckedUpdateWithoutLoanInput>
  }

  export type LoanApplicationCreateNestedOneWithoutQualificationInput = {
    create?: XOR<LoanApplicationCreateWithoutQualificationInput, LoanApplicationUncheckedCreateWithoutQualificationInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutQualificationInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type EnumQualificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.QualificationType
  }

  export type LoanApplicationUpdateOneRequiredWithoutQualificationNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutQualificationInput, LoanApplicationUncheckedCreateWithoutQualificationInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutQualificationInput
    upsert?: LoanApplicationUpsertWithoutQualificationInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutQualificationInput, LoanApplicationUpdateWithoutQualificationInput>, LoanApplicationUncheckedUpdateWithoutQualificationInput>
  }

  export type LoanApplicationCreateNestedOneWithoutSecurityInput = {
    create?: XOR<LoanApplicationCreateWithoutSecurityInput, LoanApplicationUncheckedCreateWithoutSecurityInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutSecurityInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type LoanApplicationUpdateOneRequiredWithoutSecurityNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutSecurityInput, LoanApplicationUncheckedCreateWithoutSecurityInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutSecurityInput
    upsert?: LoanApplicationUpsertWithoutSecurityInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutSecurityInput, LoanApplicationUpdateWithoutSecurityInput>, LoanApplicationUncheckedUpdateWithoutSecurityInput>
  }

  export type LoanApplicationCreateNestedOneWithoutVehicleSecurityInput = {
    create?: XOR<LoanApplicationCreateWithoutVehicleSecurityInput, LoanApplicationUncheckedCreateWithoutVehicleSecurityInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutVehicleSecurityInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type LoanApplicationUpdateOneRequiredWithoutVehicleSecurityNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutVehicleSecurityInput, LoanApplicationUncheckedCreateWithoutVehicleSecurityInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutVehicleSecurityInput
    upsert?: LoanApplicationUpsertWithoutVehicleSecurityInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutVehicleSecurityInput, LoanApplicationUpdateWithoutVehicleSecurityInput>, LoanApplicationUncheckedUpdateWithoutVehicleSecurityInput>
  }

  export type LoanApplicationCreateNestedOneWithoutGuarantorsInput = {
    create?: XOR<LoanApplicationCreateWithoutGuarantorsInput, LoanApplicationUncheckedCreateWithoutGuarantorsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutGuarantorsInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type EnumGuarantorStatusFieldUpdateOperationsInput = {
    set?: $Enums.GuarantorStatus
  }

  export type LoanApplicationUpdateOneRequiredWithoutGuarantorsNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutGuarantorsInput, LoanApplicationUncheckedCreateWithoutGuarantorsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutGuarantorsInput
    upsert?: LoanApplicationUpsertWithoutGuarantorsInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutGuarantorsInput, LoanApplicationUpdateWithoutGuarantorsInput>, LoanApplicationUncheckedUpdateWithoutGuarantorsInput>
  }

  export type LoanApplicationCreateNestedOneWithoutDisbursementInput = {
    create?: XOR<LoanApplicationCreateWithoutDisbursementInput, LoanApplicationUncheckedCreateWithoutDisbursementInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutDisbursementInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type EnumDisbursementMethodFieldUpdateOperationsInput = {
    set?: $Enums.DisbursementMethod
  }

  export type LoanApplicationUpdateOneRequiredWithoutDisbursementNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutDisbursementInput, LoanApplicationUncheckedCreateWithoutDisbursementInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutDisbursementInput
    upsert?: LoanApplicationUpsertWithoutDisbursementInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutDisbursementInput, LoanApplicationUpdateWithoutDisbursementInput>, LoanApplicationUncheckedUpdateWithoutDisbursementInput>
  }

  export type LoanApplicationCreateNestedOneWithoutFinancialsInput = {
    create?: XOR<LoanApplicationCreateWithoutFinancialsInput, LoanApplicationUncheckedCreateWithoutFinancialsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutFinancialsInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type LoanApplicationUpdateOneRequiredWithoutFinancialsNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutFinancialsInput, LoanApplicationUncheckedCreateWithoutFinancialsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutFinancialsInput
    upsert?: LoanApplicationUpsertWithoutFinancialsInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutFinancialsInput, LoanApplicationUpdateWithoutFinancialsInput>, LoanApplicationUncheckedUpdateWithoutFinancialsInput>
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoicePaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
  }

  export type LoanApplicationCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<LoanApplicationCreateWithoutInvoicesInput, LoanApplicationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutInvoicesInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoicePaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput | InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type ClientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    upsert?: ClientUpsertWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutInvoicesInput, ClientUpdateWithoutInvoicesInput>, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type LoanApplicationUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutInvoicesInput, LoanApplicationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutInvoicesInput
    upsert?: LoanApplicationUpsertWithoutInvoicesInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutInvoicesInput, LoanApplicationUpdateWithoutInvoicesInput>, LoanApplicationUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput | InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumChargeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChargeType
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutInvoicePaymentsInput = {
    create?: XOR<TransactionCreateWithoutInvoicePaymentsInput, TransactionUncheckedCreateWithoutInvoicePaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoicePaymentsInput
    connect?: TransactionWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type TransactionUpdateOneWithoutInvoicePaymentsNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoicePaymentsInput, TransactionUncheckedCreateWithoutInvoicePaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoicePaymentsInput
    upsert?: TransactionUpsertWithoutInvoicePaymentsInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutInvoicePaymentsInput, TransactionUpdateWithoutInvoicePaymentsInput>, TransactionUncheckedUpdateWithoutInvoicePaymentsInput>
  }

  export type InvoicePaymentCreateNestedManyWithoutTransactionInput = {
    create?: XOR<InvoicePaymentCreateWithoutTransactionInput, InvoicePaymentUncheckedCreateWithoutTransactionInput> | InvoicePaymentCreateWithoutTransactionInput[] | InvoicePaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTransactionInput | InvoicePaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: InvoicePaymentCreateManyTransactionInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type InvoicePaymentUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<InvoicePaymentCreateWithoutTransactionInput, InvoicePaymentUncheckedCreateWithoutTransactionInput> | InvoicePaymentCreateWithoutTransactionInput[] | InvoicePaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTransactionInput | InvoicePaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: InvoicePaymentCreateManyTransactionInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumReferenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReferenceType
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type InvoicePaymentUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutTransactionInput, InvoicePaymentUncheckedCreateWithoutTransactionInput> | InvoicePaymentCreateWithoutTransactionInput[] | InvoicePaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTransactionInput | InvoicePaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutTransactionInput | InvoicePaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: InvoicePaymentCreateManyTransactionInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutTransactionInput | InvoicePaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutTransactionInput | InvoicePaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutTransactionInput, InvoicePaymentUncheckedCreateWithoutTransactionInput> | InvoicePaymentCreateWithoutTransactionInput[] | InvoicePaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTransactionInput | InvoicePaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutTransactionInput | InvoicePaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: InvoicePaymentCreateManyTransactionInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutTransactionInput | InvoicePaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutTransactionInput | InvoicePaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type LoanApplicationCreateNestedOneWithoutRepaymentsInput = {
    create?: XOR<LoanApplicationCreateWithoutRepaymentsInput, LoanApplicationUncheckedCreateWithoutRepaymentsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutRepaymentsInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type EnumRepaymentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.RepaymentCategory
  }

  export type LoanApplicationUpdateOneRequiredWithoutRepaymentsNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutRepaymentsInput, LoanApplicationUncheckedCreateWithoutRepaymentsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutRepaymentsInput
    upsert?: LoanApplicationUpsertWithoutRepaymentsInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutRepaymentsInput, LoanApplicationUpdateWithoutRepaymentsInput>, LoanApplicationUncheckedUpdateWithoutRepaymentsInput>
  }

  export type LoanApplicationCreateNestedOneWithoutNplInput = {
    create?: XOR<LoanApplicationCreateWithoutNplInput, LoanApplicationUncheckedCreateWithoutNplInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutNplInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type LoanApplicationUpdateOneRequiredWithoutNplNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutNplInput, LoanApplicationUncheckedCreateWithoutNplInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutNplInput
    upsert?: LoanApplicationUpsertWithoutNplInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutNplInput, LoanApplicationUpdateWithoutNplInput>, LoanApplicationUncheckedUpdateWithoutNplInput>
  }

  export type UserCreateNestedOneWithoutRecoveryAgentInput = {
    create?: XOR<UserCreateWithoutRecoveryAgentInput, UserUncheckedCreateWithoutRecoveryAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryAgentInput
    connect?: UserWhereUniqueInput
  }

  export type RecoveryRecordCreateNestedManyWithoutAgentInput = {
    create?: XOR<RecoveryRecordCreateWithoutAgentInput, RecoveryRecordUncheckedCreateWithoutAgentInput> | RecoveryRecordCreateWithoutAgentInput[] | RecoveryRecordUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutAgentInput | RecoveryRecordCreateOrConnectWithoutAgentInput[]
    createMany?: RecoveryRecordCreateManyAgentInputEnvelope
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
  }

  export type RecoveryRecordUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<RecoveryRecordCreateWithoutAgentInput, RecoveryRecordUncheckedCreateWithoutAgentInput> | RecoveryRecordCreateWithoutAgentInput[] | RecoveryRecordUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutAgentInput | RecoveryRecordCreateOrConnectWithoutAgentInput[]
    createMany?: RecoveryRecordCreateManyAgentInputEnvelope
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutRecoveryAgentNestedInput = {
    create?: XOR<UserCreateWithoutRecoveryAgentInput, UserUncheckedCreateWithoutRecoveryAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryAgentInput
    upsert?: UserUpsertWithoutRecoveryAgentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecoveryAgentInput, UserUpdateWithoutRecoveryAgentInput>, UserUncheckedUpdateWithoutRecoveryAgentInput>
  }

  export type RecoveryRecordUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RecoveryRecordCreateWithoutAgentInput, RecoveryRecordUncheckedCreateWithoutAgentInput> | RecoveryRecordCreateWithoutAgentInput[] | RecoveryRecordUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutAgentInput | RecoveryRecordCreateOrConnectWithoutAgentInput[]
    upsert?: RecoveryRecordUpsertWithWhereUniqueWithoutAgentInput | RecoveryRecordUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RecoveryRecordCreateManyAgentInputEnvelope
    set?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    disconnect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    delete?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    update?: RecoveryRecordUpdateWithWhereUniqueWithoutAgentInput | RecoveryRecordUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RecoveryRecordUpdateManyWithWhereWithoutAgentInput | RecoveryRecordUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RecoveryRecordScalarWhereInput | RecoveryRecordScalarWhereInput[]
  }

  export type RecoveryRecordUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RecoveryRecordCreateWithoutAgentInput, RecoveryRecordUncheckedCreateWithoutAgentInput> | RecoveryRecordCreateWithoutAgentInput[] | RecoveryRecordUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RecoveryRecordCreateOrConnectWithoutAgentInput | RecoveryRecordCreateOrConnectWithoutAgentInput[]
    upsert?: RecoveryRecordUpsertWithWhereUniqueWithoutAgentInput | RecoveryRecordUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RecoveryRecordCreateManyAgentInputEnvelope
    set?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    disconnect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    delete?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    connect?: RecoveryRecordWhereUniqueInput | RecoveryRecordWhereUniqueInput[]
    update?: RecoveryRecordUpdateWithWhereUniqueWithoutAgentInput | RecoveryRecordUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RecoveryRecordUpdateManyWithWhereWithoutAgentInput | RecoveryRecordUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RecoveryRecordScalarWhereInput | RecoveryRecordScalarWhereInput[]
  }

  export type RecoveryAgentCreateNestedOneWithoutRecordsInput = {
    create?: XOR<RecoveryAgentCreateWithoutRecordsInput, RecoveryAgentUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: RecoveryAgentCreateOrConnectWithoutRecordsInput
    connect?: RecoveryAgentWhereUniqueInput
  }

  export type LoanApplicationCreateNestedOneWithoutRecoveryRecordsInput = {
    create?: XOR<LoanApplicationCreateWithoutRecoveryRecordsInput, LoanApplicationUncheckedCreateWithoutRecoveryRecordsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutRecoveryRecordsInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type RecoveryAgentUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<RecoveryAgentCreateWithoutRecordsInput, RecoveryAgentUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: RecoveryAgentCreateOrConnectWithoutRecordsInput
    upsert?: RecoveryAgentUpsertWithoutRecordsInput
    connect?: RecoveryAgentWhereUniqueInput
    update?: XOR<XOR<RecoveryAgentUpdateToOneWithWhereWithoutRecordsInput, RecoveryAgentUpdateWithoutRecordsInput>, RecoveryAgentUncheckedUpdateWithoutRecordsInput>
  }

  export type LoanApplicationUpdateOneRequiredWithoutRecoveryRecordsNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutRecoveryRecordsInput, LoanApplicationUncheckedCreateWithoutRecoveryRecordsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutRecoveryRecordsInput
    upsert?: LoanApplicationUpsertWithoutRecoveryRecordsInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutRecoveryRecordsInput, LoanApplicationUpdateWithoutRecoveryRecordsInput>, LoanApplicationUncheckedUpdateWithoutRecoveryRecordsInput>
  }

  export type InvestorAllocationCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorAllocationCreateWithoutInvestorInput, InvestorAllocationUncheckedCreateWithoutInvestorInput> | InvestorAllocationCreateWithoutInvestorInput[] | InvestorAllocationUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutInvestorInput | InvestorAllocationCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorAllocationCreateManyInvestorInputEnvelope
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
  }

  export type InvestorPayoutCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorPayoutCreateWithoutInvestorInput, InvestorPayoutUncheckedCreateWithoutInvestorInput> | InvestorPayoutCreateWithoutInvestorInput[] | InvestorPayoutUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorPayoutCreateOrConnectWithoutInvestorInput | InvestorPayoutCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorPayoutCreateManyInvestorInputEnvelope
    connect?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutInvestorInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    connect?: UserWhereUniqueInput
  }

  export type InvestorAllocationUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorAllocationCreateWithoutInvestorInput, InvestorAllocationUncheckedCreateWithoutInvestorInput> | InvestorAllocationCreateWithoutInvestorInput[] | InvestorAllocationUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutInvestorInput | InvestorAllocationCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorAllocationCreateManyInvestorInputEnvelope
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
  }

  export type InvestorPayoutUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorPayoutCreateWithoutInvestorInput, InvestorPayoutUncheckedCreateWithoutInvestorInput> | InvestorPayoutCreateWithoutInvestorInput[] | InvestorPayoutUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorPayoutCreateOrConnectWithoutInvestorInput | InvestorPayoutCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorPayoutCreateManyInvestorInputEnvelope
    connect?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
  }

  export type InvestorAllocationUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorAllocationCreateWithoutInvestorInput, InvestorAllocationUncheckedCreateWithoutInvestorInput> | InvestorAllocationCreateWithoutInvestorInput[] | InvestorAllocationUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutInvestorInput | InvestorAllocationCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorAllocationUpsertWithWhereUniqueWithoutInvestorInput | InvestorAllocationUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorAllocationCreateManyInvestorInputEnvelope
    set?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    disconnect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    delete?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    update?: InvestorAllocationUpdateWithWhereUniqueWithoutInvestorInput | InvestorAllocationUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorAllocationUpdateManyWithWhereWithoutInvestorInput | InvestorAllocationUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorAllocationScalarWhereInput | InvestorAllocationScalarWhereInput[]
  }

  export type InvestorPayoutUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorPayoutCreateWithoutInvestorInput, InvestorPayoutUncheckedCreateWithoutInvestorInput> | InvestorPayoutCreateWithoutInvestorInput[] | InvestorPayoutUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorPayoutCreateOrConnectWithoutInvestorInput | InvestorPayoutCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorPayoutUpsertWithWhereUniqueWithoutInvestorInput | InvestorPayoutUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorPayoutCreateManyInvestorInputEnvelope
    set?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    disconnect?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    delete?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    connect?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    update?: InvestorPayoutUpdateWithWhereUniqueWithoutInvestorInput | InvestorPayoutUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorPayoutUpdateManyWithWhereWithoutInvestorInput | InvestorPayoutUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorPayoutScalarWhereInput | InvestorPayoutScalarWhereInput[]
  }

  export type UserUpdateOneWithoutInvestorNestedInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    upsert?: UserUpsertWithoutInvestorInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorInput, UserUpdateWithoutInvestorInput>, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type InvestorAllocationUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorAllocationCreateWithoutInvestorInput, InvestorAllocationUncheckedCreateWithoutInvestorInput> | InvestorAllocationCreateWithoutInvestorInput[] | InvestorAllocationUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorAllocationCreateOrConnectWithoutInvestorInput | InvestorAllocationCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorAllocationUpsertWithWhereUniqueWithoutInvestorInput | InvestorAllocationUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorAllocationCreateManyInvestorInputEnvelope
    set?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    disconnect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    delete?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    connect?: InvestorAllocationWhereUniqueInput | InvestorAllocationWhereUniqueInput[]
    update?: InvestorAllocationUpdateWithWhereUniqueWithoutInvestorInput | InvestorAllocationUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorAllocationUpdateManyWithWhereWithoutInvestorInput | InvestorAllocationUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorAllocationScalarWhereInput | InvestorAllocationScalarWhereInput[]
  }

  export type InvestorPayoutUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorPayoutCreateWithoutInvestorInput, InvestorPayoutUncheckedCreateWithoutInvestorInput> | InvestorPayoutCreateWithoutInvestorInput[] | InvestorPayoutUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorPayoutCreateOrConnectWithoutInvestorInput | InvestorPayoutCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorPayoutUpsertWithWhereUniqueWithoutInvestorInput | InvestorPayoutUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorPayoutCreateManyInvestorInputEnvelope
    set?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    disconnect?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    delete?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    connect?: InvestorPayoutWhereUniqueInput | InvestorPayoutWhereUniqueInput[]
    update?: InvestorPayoutUpdateWithWhereUniqueWithoutInvestorInput | InvestorPayoutUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorPayoutUpdateManyWithWhereWithoutInvestorInput | InvestorPayoutUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorPayoutScalarWhereInput | InvestorPayoutScalarWhereInput[]
  }

  export type InvestorCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<InvestorCreateWithoutAllocationsInput, InvestorUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutAllocationsInput
    connect?: InvestorWhereUniqueInput
  }

  export type LoanApplicationCreateNestedOneWithoutInvestorAllocationsInput = {
    create?: XOR<LoanApplicationCreateWithoutInvestorAllocationsInput, LoanApplicationUncheckedCreateWithoutInvestorAllocationsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutInvestorAllocationsInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type InvestorUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<InvestorCreateWithoutAllocationsInput, InvestorUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutAllocationsInput
    upsert?: InvestorUpsertWithoutAllocationsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutAllocationsInput, InvestorUpdateWithoutAllocationsInput>, InvestorUncheckedUpdateWithoutAllocationsInput>
  }

  export type LoanApplicationUpdateOneRequiredWithoutInvestorAllocationsNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutInvestorAllocationsInput, LoanApplicationUncheckedCreateWithoutInvestorAllocationsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutInvestorAllocationsInput
    upsert?: LoanApplicationUpsertWithoutInvestorAllocationsInput
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutInvestorAllocationsInput, LoanApplicationUpdateWithoutInvestorAllocationsInput>, LoanApplicationUncheckedUpdateWithoutInvestorAllocationsInput>
  }

  export type InvestorCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<InvestorCreateWithoutPayoutsInput, InvestorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutPayoutsInput
    connect?: InvestorWhereUniqueInput
  }

  export type InvestorUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<InvestorCreateWithoutPayoutsInput, InvestorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutPayoutsInput
    upsert?: InvestorUpsertWithoutPayoutsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutPayoutsInput, InvestorUpdateWithoutPayoutsInput>, InvestorUncheckedUpdateWithoutPayoutsInput>
  }

  export type ClientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
  }

  export type LoanApplicationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutDocumentsInput
    connect?: LoanApplicationWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    upsert?: ClientUpsertWithoutDocumentsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDocumentsInput, ClientUpdateWithoutDocumentsInput>, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type LoanApplicationUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutDocumentsInput
    upsert?: LoanApplicationUpsertWithoutDocumentsInput
    disconnect?: LoanApplicationWhereInput | boolean
    delete?: LoanApplicationWhereInput | boolean
    connect?: LoanApplicationWhereUniqueInput
    update?: XOR<XOR<LoanApplicationUpdateToOneWithWhereWithoutDocumentsInput, LoanApplicationUpdateWithoutDocumentsInput>, LoanApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type EnumExpenseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseType
  }

  export type EnumSmsPurposeFieldUpdateOperationsInput = {
    set?: $Enums.SmsPurpose
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ChartOfAccountCreateNestedOneWithoutChildAccountsInput = {
    create?: XOR<ChartOfAccountCreateWithoutChildAccountsInput, ChartOfAccountUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutChildAccountsInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type ChartOfAccountCreateNestedManyWithoutParentAccountInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentAccountInput, ChartOfAccountUncheckedCreateWithoutParentAccountInput> | ChartOfAccountCreateWithoutParentAccountInput[] | ChartOfAccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentAccountInput | ChartOfAccountCreateOrConnectWithoutParentAccountInput[]
    createMany?: ChartOfAccountCreateManyParentAccountInputEnvelope
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
  }

  export type ChartOfAccountUncheckedCreateNestedManyWithoutParentAccountInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentAccountInput, ChartOfAccountUncheckedCreateWithoutParentAccountInput> | ChartOfAccountCreateWithoutParentAccountInput[] | ChartOfAccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentAccountInput | ChartOfAccountCreateOrConnectWithoutParentAccountInput[]
    createMany?: ChartOfAccountCreateManyParentAccountInputEnvelope
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type EnumNormalBalanceFieldUpdateOperationsInput = {
    set?: $Enums.NormalBalance
  }

  export type ChartOfAccountUpdateOneWithoutChildAccountsNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutChildAccountsInput, ChartOfAccountUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutChildAccountsInput
    upsert?: ChartOfAccountUpsertWithoutChildAccountsInput
    disconnect?: ChartOfAccountWhereInput | boolean
    delete?: ChartOfAccountWhereInput | boolean
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutChildAccountsInput, ChartOfAccountUpdateWithoutChildAccountsInput>, ChartOfAccountUncheckedUpdateWithoutChildAccountsInput>
  }

  export type ChartOfAccountUpdateManyWithoutParentAccountNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentAccountInput, ChartOfAccountUncheckedCreateWithoutParentAccountInput> | ChartOfAccountCreateWithoutParentAccountInput[] | ChartOfAccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentAccountInput | ChartOfAccountCreateOrConnectWithoutParentAccountInput[]
    upsert?: ChartOfAccountUpsertWithWhereUniqueWithoutParentAccountInput | ChartOfAccountUpsertWithWhereUniqueWithoutParentAccountInput[]
    createMany?: ChartOfAccountCreateManyParentAccountInputEnvelope
    set?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    disconnect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    delete?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    update?: ChartOfAccountUpdateWithWhereUniqueWithoutParentAccountInput | ChartOfAccountUpdateWithWhereUniqueWithoutParentAccountInput[]
    updateMany?: ChartOfAccountUpdateManyWithWhereWithoutParentAccountInput | ChartOfAccountUpdateManyWithWhereWithoutParentAccountInput[]
    deleteMany?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
  }

  export type ChartOfAccountUncheckedUpdateManyWithoutParentAccountNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentAccountInput, ChartOfAccountUncheckedCreateWithoutParentAccountInput> | ChartOfAccountCreateWithoutParentAccountInput[] | ChartOfAccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentAccountInput | ChartOfAccountCreateOrConnectWithoutParentAccountInput[]
    upsert?: ChartOfAccountUpsertWithWhereUniqueWithoutParentAccountInput | ChartOfAccountUpsertWithWhereUniqueWithoutParentAccountInput[]
    createMany?: ChartOfAccountCreateManyParentAccountInputEnvelope
    set?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    disconnect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    delete?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    update?: ChartOfAccountUpdateWithWhereUniqueWithoutParentAccountInput | ChartOfAccountUpdateWithWhereUniqueWithoutParentAccountInput[]
    updateMany?: ChartOfAccountUpdateManyWithWhereWithoutParentAccountInput | ChartOfAccountUpdateManyWithWhereWithoutParentAccountInput[]
    deleteMany?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleFilter<$PrismaModel> | $Enums.Title
  }

  export type NestedEnumMaritalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusFilter<$PrismaModel> | $Enums.MaritalStatus
  }

  export type NestedEnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type NestedEnumTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTitleFilter<$PrismaModel>
    _max?: NestedEnumTitleFilter<$PrismaModel>
  }

  export type NestedEnumMaritalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumQualificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQualificationTypeNullableFilter<$PrismaModel> | $Enums.QualificationType | null
  }

  export type NestedEnumLoanApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanApplicationStatus | EnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanApplicationStatusFilter<$PrismaModel> | $Enums.LoanApplicationStatus
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumQualificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQualificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.QualificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQualificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumQualificationTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLoanApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanApplicationStatus | EnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanApplicationStatus[] | ListEnumLoanApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.LoanApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoanApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumLoanApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumQualificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQualificationTypeFilter<$PrismaModel> | $Enums.QualificationType
  }

  export type NestedEnumQualificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QualificationType | EnumQualificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QualificationType[] | ListEnumQualificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQualificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.QualificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQualificationTypeFilter<$PrismaModel>
    _max?: NestedEnumQualificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumGuarantorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GuarantorStatus | EnumGuarantorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuarantorStatusFilter<$PrismaModel> | $Enums.GuarantorStatus
  }

  export type NestedEnumGuarantorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuarantorStatus | EnumGuarantorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuarantorStatus[] | ListEnumGuarantorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuarantorStatusWithAggregatesFilter<$PrismaModel> | $Enums.GuarantorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuarantorStatusFilter<$PrismaModel>
    _max?: NestedEnumGuarantorStatusFilter<$PrismaModel>
  }

  export type NestedEnumDisbursementMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DisbursementMethod | EnumDisbursementMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDisbursementMethodFilter<$PrismaModel> | $Enums.DisbursementMethod
  }

  export type NestedEnumDisbursementMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisbursementMethod | EnumDisbursementMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisbursementMethod[] | ListEnumDisbursementMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDisbursementMethodWithAggregatesFilter<$PrismaModel> | $Enums.DisbursementMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisbursementMethodFilter<$PrismaModel>
    _max?: NestedEnumDisbursementMethodFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumChargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeFilter<$PrismaModel> | $Enums.ChargeType
  }

  export type NestedEnumChargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChargeTypeFilter<$PrismaModel>
    _max?: NestedEnumChargeTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeFilter<$PrismaModel> | $Enums.ReferenceType
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumReferenceTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumRepaymentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.RepaymentCategory | EnumRepaymentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumRepaymentCategoryFilter<$PrismaModel> | $Enums.RepaymentCategory
  }

  export type NestedEnumRepaymentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RepaymentCategory | EnumRepaymentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepaymentCategory[] | ListEnumRepaymentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumRepaymentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.RepaymentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRepaymentCategoryFilter<$PrismaModel>
    _max?: NestedEnumRepaymentCategoryFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type NestedEnumSmsPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.SmsPurpose | EnumSmsPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumSmsPurposeFilter<$PrismaModel> | $Enums.SmsPurpose
  }

  export type NestedEnumSmsPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SmsPurpose | EnumSmsPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SmsPurpose[] | ListEnumSmsPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumSmsPurposeWithAggregatesFilter<$PrismaModel> | $Enums.SmsPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSmsPurposeFilter<$PrismaModel>
    _max?: NestedEnumSmsPurposeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumNormalBalanceFilter<$PrismaModel = never> = {
    equals?: $Enums.NormalBalance | EnumNormalBalanceFieldRefInput<$PrismaModel>
    in?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    not?: NestedEnumNormalBalanceFilter<$PrismaModel> | $Enums.NormalBalance
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumNormalBalanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NormalBalance | EnumNormalBalanceFieldRefInput<$PrismaModel>
    in?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.NormalBalance[] | ListEnumNormalBalanceFieldRefInput<$PrismaModel>
    not?: NestedEnumNormalBalanceWithAggregatesFilter<$PrismaModel> | $Enums.NormalBalance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNormalBalanceFilter<$PrismaModel>
    _max?: NestedEnumNormalBalanceFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type InvestorCreateWithoutUserInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: InvestorAllocationCreateNestedManyWithoutInvestorInput
    payouts?: InvestorPayoutCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: InvestorAllocationUncheckedCreateNestedManyWithoutInvestorInput
    payouts?: InvestorPayoutUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutUserInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
  }

  export type LoanApplicationCreateWithoutApprovedByInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutApprovedByInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutApprovedByInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutApprovedByInput, LoanApplicationUncheckedCreateWithoutApprovedByInput>
  }

  export type LoanApplicationCreateManyApprovedByInputEnvelope = {
    data: LoanApplicationCreateManyApprovedByInput | LoanApplicationCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type LoanApplicationCreateWithoutReviewedByInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutReviewedByInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutReviewedByInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutReviewedByInput, LoanApplicationUncheckedCreateWithoutReviewedByInput>
  }

  export type LoanApplicationCreateManyReviewedByInputEnvelope = {
    data: LoanApplicationCreateManyReviewedByInput | LoanApplicationCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type RecoveryAgentCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: RecoveryRecordCreateNestedManyWithoutAgentInput
  }

  export type RecoveryAgentUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: RecoveryRecordUncheckedCreateNestedManyWithoutAgentInput
  }

  export type RecoveryAgentCreateOrConnectWithoutUserInput = {
    where: RecoveryAgentWhereUniqueInput
    create: XOR<RecoveryAgentCreateWithoutUserInput, RecoveryAgentUncheckedCreateWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type InvestorUpsertWithoutUserInput = {
    update: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutUserInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: InvestorAllocationUpdateManyWithoutInvestorNestedInput
    payouts?: InvestorPayoutUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: InvestorAllocationUncheckedUpdateManyWithoutInvestorNestedInput
    payouts?: InvestorPayoutUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutApprovedByInput, LoanApplicationUncheckedUpdateWithoutApprovedByInput>
    create: XOR<LoanApplicationCreateWithoutApprovedByInput, LoanApplicationUncheckedCreateWithoutApprovedByInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutApprovedByInput, LoanApplicationUncheckedUpdateWithoutApprovedByInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutApprovedByInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type LoanApplicationScalarWhereInput = {
    AND?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
    OR?: LoanApplicationScalarWhereInput[]
    NOT?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
    id?: StringFilter<"LoanApplication"> | string
    clientId?: StringFilter<"LoanApplication"> | string
    purpose?: StringFilter<"LoanApplication"> | string
    amountRequested?: DecimalFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string | null
    qualificationType?: EnumQualificationTypeNullableFilter<"LoanApplication"> | $Enums.QualificationType | null
    interestRate?: DecimalFilter<"LoanApplication"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    repaymentPeriod?: IntFilter<"LoanApplication"> | number
    status?: EnumLoanApplicationStatusFilter<"LoanApplication"> | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFilter<"LoanApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    reviewedById?: StringNullableFilter<"LoanApplication"> | string | null
    approvedAt?: DateTimeNullableFilter<"LoanApplication"> | Date | string | null
    approvedById?: StringNullableFilter<"LoanApplication"> | string | null
    rejectionReason?: StringNullableFilter<"LoanApplication"> | string | null
    createdAt?: DateTimeFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LoanApplication"> | Date | string
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutReviewedByInput, LoanApplicationUncheckedUpdateWithoutReviewedByInput>
    create: XOR<LoanApplicationCreateWithoutReviewedByInput, LoanApplicationUncheckedCreateWithoutReviewedByInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutReviewedByInput, LoanApplicationUncheckedUpdateWithoutReviewedByInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutReviewedByInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type RecoveryAgentUpsertWithoutUserInput = {
    update: XOR<RecoveryAgentUpdateWithoutUserInput, RecoveryAgentUncheckedUpdateWithoutUserInput>
    create: XOR<RecoveryAgentCreateWithoutUserInput, RecoveryAgentUncheckedCreateWithoutUserInput>
    where?: RecoveryAgentWhereInput
  }

  export type RecoveryAgentUpdateToOneWithWhereWithoutUserInput = {
    where?: RecoveryAgentWhereInput
    data: XOR<RecoveryAgentUpdateWithoutUserInput, RecoveryAgentUncheckedUpdateWithoutUserInput>
  }

  export type RecoveryAgentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: RecoveryRecordUpdateManyWithoutAgentNestedInput
  }

  export type RecoveryAgentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: RecoveryRecordUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type BankDetailCreateWithoutClientInput = {
    id?: string
    bankName: string
    branch: string
    accountName: string
    accountNumber: string
    proofDocument?: string | null
    proofDocumentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUncheckedCreateWithoutClientInput = {
    id?: string
    bankName: string
    branch: string
    accountName: string
    accountNumber: string
    proofDocument?: string | null
    proofDocumentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailCreateOrConnectWithoutClientInput = {
    where: BankDetailWhereUniqueInput
    create: XOR<BankDetailCreateWithoutClientInput, BankDetailUncheckedCreateWithoutClientInput>
  }

  export type BankDetailCreateManyClientInputEnvelope = {
    data: BankDetailCreateManyClientInput | BankDetailCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientAddressCreateWithoutClientInput = {
    id?: string
    postalAddress?: string | null
    postalCode?: string | null
    townCity?: string | null
    residentialAddress?: string | null
    location?: string | null
    estate?: string | null
    building?: string | null
    houseNumber?: string | null
    landmark?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAddressUncheckedCreateWithoutClientInput = {
    id?: string
    postalAddress?: string | null
    postalCode?: string | null
    townCity?: string | null
    residentialAddress?: string | null
    location?: string | null
    estate?: string | null
    building?: string | null
    houseNumber?: string | null
    landmark?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAddressCreateOrConnectWithoutClientInput = {
    where: ClientAddressWhereUniqueInput
    create: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput>
  }

  export type ClientAddressCreateManyClientInputEnvelope = {
    data: ClientAddressCreateManyClientInput | ClientAddressCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type DocumentCreateWithoutClientInput = {
    id?: string
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    loan?: LoanApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutClientInput = {
    id?: string
    loanId?: string | null
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutClientInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentCreateManyClientInputEnvelope = {
    data: DocumentCreateManyClientInput | DocumentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentDetailCreateWithoutClientInput = {
    id?: string
    employerName: string
    jobTitle: string
    department?: string | null
    dateJoined?: Date | string | null
    periodWorked?: string | null
    employmentType: $Enums.EmploymentType
    contractExpiry?: Date | string | null
    onNotice?: boolean
    netSalary: Decimal | DecimalJsLike | number | string
    branchLocation?: string | null
    roadStreet?: string | null
    building?: string | null
    floorOffice?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentDetailUncheckedCreateWithoutClientInput = {
    id?: string
    employerName: string
    jobTitle: string
    department?: string | null
    dateJoined?: Date | string | null
    periodWorked?: string | null
    employmentType: $Enums.EmploymentType
    contractExpiry?: Date | string | null
    onNotice?: boolean
    netSalary: Decimal | DecimalJsLike | number | string
    branchLocation?: string | null
    roadStreet?: string | null
    building?: string | null
    floorOffice?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentDetailCreateOrConnectWithoutClientInput = {
    where: EmploymentDetailWhereUniqueInput
    create: XOR<EmploymentDetailCreateWithoutClientInput, EmploymentDetailUncheckedCreateWithoutClientInput>
  }

  export type EmploymentDetailCreateManyClientInputEnvelope = {
    data: EmploymentDetailCreateManyClientInput | EmploymentDetailCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    invoiceNumber: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    loan: LoanApplicationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    invoiceNumber: string
    loanId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type LoanApplicationCreateWithoutClientInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutClientInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutClientInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutClientInput, LoanApplicationUncheckedCreateWithoutClientInput>
  }

  export type LoanApplicationCreateManyClientInputEnvelope = {
    data: LoanApplicationCreateManyClientInput | LoanApplicationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type RefereeCreateWithoutClientInput = {
    id?: string
    surname: string
    otherNames: string
    relationship: string
    idPassportNo?: string | null
    employerName?: string | null
    locationStation?: string | null
    phoneWork?: string | null
    phoneMobile: string
    isRelative?: boolean
    createdAt?: Date | string
  }

  export type RefereeUncheckedCreateWithoutClientInput = {
    id?: string
    surname: string
    otherNames: string
    relationship: string
    idPassportNo?: string | null
    employerName?: string | null
    locationStation?: string | null
    phoneWork?: string | null
    phoneMobile: string
    isRelative?: boolean
    createdAt?: Date | string
  }

  export type RefereeCreateOrConnectWithoutClientInput = {
    where: RefereeWhereUniqueInput
    create: XOR<RefereeCreateWithoutClientInput, RefereeUncheckedCreateWithoutClientInput>
  }

  export type RefereeCreateManyClientInputEnvelope = {
    data: RefereeCreateManyClientInput | RefereeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type BankDetailUpsertWithWhereUniqueWithoutClientInput = {
    where: BankDetailWhereUniqueInput
    update: XOR<BankDetailUpdateWithoutClientInput, BankDetailUncheckedUpdateWithoutClientInput>
    create: XOR<BankDetailCreateWithoutClientInput, BankDetailUncheckedCreateWithoutClientInput>
  }

  export type BankDetailUpdateWithWhereUniqueWithoutClientInput = {
    where: BankDetailWhereUniqueInput
    data: XOR<BankDetailUpdateWithoutClientInput, BankDetailUncheckedUpdateWithoutClientInput>
  }

  export type BankDetailUpdateManyWithWhereWithoutClientInput = {
    where: BankDetailScalarWhereInput
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyWithoutClientInput>
  }

  export type BankDetailScalarWhereInput = {
    AND?: BankDetailScalarWhereInput | BankDetailScalarWhereInput[]
    OR?: BankDetailScalarWhereInput[]
    NOT?: BankDetailScalarWhereInput | BankDetailScalarWhereInput[]
    id?: StringFilter<"BankDetail"> | string
    clientId?: StringFilter<"BankDetail"> | string
    bankName?: StringFilter<"BankDetail"> | string
    branch?: StringFilter<"BankDetail"> | string
    accountName?: StringFilter<"BankDetail"> | string
    accountNumber?: StringFilter<"BankDetail"> | string
    proofDocument?: StringNullableFilter<"BankDetail"> | string | null
    proofDocumentUrl?: StringNullableFilter<"BankDetail"> | string | null
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
  }

  export type ClientAddressUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientAddressWhereUniqueInput
    update: XOR<ClientAddressUpdateWithoutClientInput, ClientAddressUncheckedUpdateWithoutClientInput>
    create: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput>
  }

  export type ClientAddressUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientAddressWhereUniqueInput
    data: XOR<ClientAddressUpdateWithoutClientInput, ClientAddressUncheckedUpdateWithoutClientInput>
  }

  export type ClientAddressUpdateManyWithWhereWithoutClientInput = {
    where: ClientAddressScalarWhereInput
    data: XOR<ClientAddressUpdateManyMutationInput, ClientAddressUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientAddressScalarWhereInput = {
    AND?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
    OR?: ClientAddressScalarWhereInput[]
    NOT?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
    id?: StringFilter<"ClientAddress"> | string
    clientId?: StringFilter<"ClientAddress"> | string
    postalAddress?: StringNullableFilter<"ClientAddress"> | string | null
    postalCode?: StringNullableFilter<"ClientAddress"> | string | null
    townCity?: StringNullableFilter<"ClientAddress"> | string | null
    residentialAddress?: StringNullableFilter<"ClientAddress"> | string | null
    location?: StringNullableFilter<"ClientAddress"> | string | null
    estate?: StringNullableFilter<"ClientAddress"> | string | null
    building?: StringNullableFilter<"ClientAddress"> | string | null
    houseNumber?: StringNullableFilter<"ClientAddress"> | string | null
    landmark?: StringNullableFilter<"ClientAddress"> | string | null
    createdAt?: DateTimeFilter<"ClientAddress"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAddress"> | Date | string
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClientInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClientInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    clientId?: StringNullableFilter<"Document"> | string | null
    loanId?: StringNullableFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    filePublicId?: StringFilter<"Document"> | string
    fileUniqueId?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type EmploymentDetailUpsertWithWhereUniqueWithoutClientInput = {
    where: EmploymentDetailWhereUniqueInput
    update: XOR<EmploymentDetailUpdateWithoutClientInput, EmploymentDetailUncheckedUpdateWithoutClientInput>
    create: XOR<EmploymentDetailCreateWithoutClientInput, EmploymentDetailUncheckedCreateWithoutClientInput>
  }

  export type EmploymentDetailUpdateWithWhereUniqueWithoutClientInput = {
    where: EmploymentDetailWhereUniqueInput
    data: XOR<EmploymentDetailUpdateWithoutClientInput, EmploymentDetailUncheckedUpdateWithoutClientInput>
  }

  export type EmploymentDetailUpdateManyWithWhereWithoutClientInput = {
    where: EmploymentDetailScalarWhereInput
    data: XOR<EmploymentDetailUpdateManyMutationInput, EmploymentDetailUncheckedUpdateManyWithoutClientInput>
  }

  export type EmploymentDetailScalarWhereInput = {
    AND?: EmploymentDetailScalarWhereInput | EmploymentDetailScalarWhereInput[]
    OR?: EmploymentDetailScalarWhereInput[]
    NOT?: EmploymentDetailScalarWhereInput | EmploymentDetailScalarWhereInput[]
    id?: StringFilter<"EmploymentDetail"> | string
    clientId?: StringFilter<"EmploymentDetail"> | string
    employerName?: StringFilter<"EmploymentDetail"> | string
    jobTitle?: StringFilter<"EmploymentDetail"> | string
    department?: StringNullableFilter<"EmploymentDetail"> | string | null
    dateJoined?: DateTimeNullableFilter<"EmploymentDetail"> | Date | string | null
    periodWorked?: StringNullableFilter<"EmploymentDetail"> | string | null
    employmentType?: EnumEmploymentTypeFilter<"EmploymentDetail"> | $Enums.EmploymentType
    contractExpiry?: DateTimeNullableFilter<"EmploymentDetail"> | Date | string | null
    onNotice?: BoolFilter<"EmploymentDetail"> | boolean
    netSalary?: DecimalFilter<"EmploymentDetail"> | Decimal | DecimalJsLike | number | string
    branchLocation?: StringNullableFilter<"EmploymentDetail"> | string | null
    roadStreet?: StringNullableFilter<"EmploymentDetail"> | string | null
    building?: StringNullableFilter<"EmploymentDetail"> | string | null
    floorOffice?: StringNullableFilter<"EmploymentDetail"> | string | null
    telephone?: StringNullableFilter<"EmploymentDetail"> | string | null
    createdAt?: DateTimeFilter<"EmploymentDetail"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentDetail"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    loanId?: StringFilter<"Invoice"> | string
    invoiceType?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedBy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutClientInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutClientInput, LoanApplicationUncheckedUpdateWithoutClientInput>
    create: XOR<LoanApplicationCreateWithoutClientInput, LoanApplicationUncheckedCreateWithoutClientInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutClientInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutClientInput, LoanApplicationUncheckedUpdateWithoutClientInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutClientInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutClientInput>
  }

  export type RefereeUpsertWithWhereUniqueWithoutClientInput = {
    where: RefereeWhereUniqueInput
    update: XOR<RefereeUpdateWithoutClientInput, RefereeUncheckedUpdateWithoutClientInput>
    create: XOR<RefereeCreateWithoutClientInput, RefereeUncheckedCreateWithoutClientInput>
  }

  export type RefereeUpdateWithWhereUniqueWithoutClientInput = {
    where: RefereeWhereUniqueInput
    data: XOR<RefereeUpdateWithoutClientInput, RefereeUncheckedUpdateWithoutClientInput>
  }

  export type RefereeUpdateManyWithWhereWithoutClientInput = {
    where: RefereeScalarWhereInput
    data: XOR<RefereeUpdateManyMutationInput, RefereeUncheckedUpdateManyWithoutClientInput>
  }

  export type RefereeScalarWhereInput = {
    AND?: RefereeScalarWhereInput | RefereeScalarWhereInput[]
    OR?: RefereeScalarWhereInput[]
    NOT?: RefereeScalarWhereInput | RefereeScalarWhereInput[]
    id?: StringFilter<"Referee"> | string
    clientId?: StringFilter<"Referee"> | string
    surname?: StringFilter<"Referee"> | string
    otherNames?: StringFilter<"Referee"> | string
    relationship?: StringFilter<"Referee"> | string
    idPassportNo?: StringNullableFilter<"Referee"> | string | null
    employerName?: StringNullableFilter<"Referee"> | string | null
    locationStation?: StringNullableFilter<"Referee"> | string | null
    phoneWork?: StringNullableFilter<"Referee"> | string | null
    phoneMobile?: StringFilter<"Referee"> | string
    isRelative?: BoolFilter<"Referee"> | boolean
    createdAt?: DateTimeFilter<"Referee"> | Date | string
  }

  export type ClientCreateWithoutAddressesInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAddressesInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAddressesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
  }

  export type ClientUpsertWithoutAddressesInput = {
    update: XOR<ClientUpdateWithoutAddressesInput, ClientUncheckedUpdateWithoutAddressesInput>
    create: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAddressesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAddressesInput, ClientUncheckedUpdateWithoutAddressesInput>
  }

  export type ClientUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutEmploymentDetailsInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutEmploymentDetailsInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutEmploymentDetailsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutEmploymentDetailsInput, ClientUncheckedCreateWithoutEmploymentDetailsInput>
  }

  export type ClientUpsertWithoutEmploymentDetailsInput = {
    update: XOR<ClientUpdateWithoutEmploymentDetailsInput, ClientUncheckedUpdateWithoutEmploymentDetailsInput>
    create: XOR<ClientCreateWithoutEmploymentDetailsInput, ClientUncheckedCreateWithoutEmploymentDetailsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutEmploymentDetailsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutEmploymentDetailsInput, ClientUncheckedUpdateWithoutEmploymentDetailsInput>
  }

  export type ClientUpdateWithoutEmploymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutEmploymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutRefereesInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutRefereesInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutRefereesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRefereesInput, ClientUncheckedCreateWithoutRefereesInput>
  }

  export type ClientUpsertWithoutRefereesInput = {
    update: XOR<ClientUpdateWithoutRefereesInput, ClientUncheckedUpdateWithoutRefereesInput>
    create: XOR<ClientCreateWithoutRefereesInput, ClientUncheckedCreateWithoutRefereesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutRefereesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutRefereesInput, ClientUncheckedUpdateWithoutRefereesInput>
  }

  export type ClientUpdateWithoutRefereesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutRefereesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutBankDetailsInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutBankDetailsInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutBankDetailsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutBankDetailsInput, ClientUncheckedCreateWithoutBankDetailsInput>
  }

  export type ClientUpsertWithoutBankDetailsInput = {
    update: XOR<ClientUpdateWithoutBankDetailsInput, ClientUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<ClientCreateWithoutBankDetailsInput, ClientUncheckedCreateWithoutBankDetailsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutBankDetailsInput, ClientUncheckedUpdateWithoutBankDetailsInput>
  }

  export type ClientUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DocumentCreateWithoutLoanInput = {
    id?: string
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    client?: ClientCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutLoanInput = {
    id?: string
    clientId?: string | null
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutLoanInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutLoanInput, DocumentUncheckedCreateWithoutLoanInput>
  }

  export type DocumentCreateManyLoanInputEnvelope = {
    data: DocumentCreateManyLoanInput | DocumentCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type GuarantorCreateWithoutLoanInput = {
    id?: string
    fullName: string
    phone: string
    email?: string | null
    idNumber?: string | null
    relationship?: string | null
    confirmationStatus?: $Enums.GuarantorStatus
    confirmedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GuarantorUncheckedCreateWithoutLoanInput = {
    id?: string
    fullName: string
    phone: string
    email?: string | null
    idNumber?: string | null
    relationship?: string | null
    confirmationStatus?: $Enums.GuarantorStatus
    confirmedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GuarantorCreateOrConnectWithoutLoanInput = {
    where: GuarantorWhereUniqueInput
    create: XOR<GuarantorCreateWithoutLoanInput, GuarantorUncheckedCreateWithoutLoanInput>
  }

  export type GuarantorCreateManyLoanInputEnvelope = {
    data: GuarantorCreateManyLoanInput | GuarantorCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type InvestorAllocationCreateWithoutLoanInput = {
    id?: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutAllocationsInput
  }

  export type InvestorAllocationUncheckedCreateWithoutLoanInput = {
    id?: string
    investorId: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorAllocationCreateOrConnectWithoutLoanInput = {
    where: InvestorAllocationWhereUniqueInput
    create: XOR<InvestorAllocationCreateWithoutLoanInput, InvestorAllocationUncheckedCreateWithoutLoanInput>
  }

  export type InvestorAllocationCreateManyLoanInputEnvelope = {
    data: InvestorAllocationCreateManyLoanInput | InvestorAllocationCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutLoanInput = {
    id?: string
    invoiceNumber: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    client: ClientCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutLoanInput = {
    id?: string
    invoiceNumber: string
    clientId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLoanInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLoanInput, InvoiceUncheckedCreateWithoutLoanInput>
  }

  export type InvoiceCreateManyLoanInputEnvelope = {
    data: InvoiceCreateManyLoanInput | InvoiceCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutApprovedLoansInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovedLoansInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovedLoansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedLoansInput, UserUncheckedCreateWithoutApprovedLoansInput>
  }

  export type ClientCreateWithoutLoanApplicationsInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutLoanApplicationsInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutLoanApplicationsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutLoanApplicationsInput, ClientUncheckedCreateWithoutLoanApplicationsInput>
  }

  export type UserCreateWithoutReviewedLoansInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewedLoansInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewedLoansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedLoansInput, UserUncheckedCreateWithoutReviewedLoansInput>
  }

  export type LoanDisbursementCreateWithoutLoanInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.DisbursementMethod
    reference?: string | null
    disbursedAt: Date | string
    createdAt?: Date | string
  }

  export type LoanDisbursementUncheckedCreateWithoutLoanInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.DisbursementMethod
    reference?: string | null
    disbursedAt: Date | string
    createdAt?: Date | string
  }

  export type LoanDisbursementCreateOrConnectWithoutLoanInput = {
    where: LoanDisbursementWhereUniqueInput
    create: XOR<LoanDisbursementCreateWithoutLoanInput, LoanDisbursementUncheckedCreateWithoutLoanInput>
  }

  export type LoanFinancialCreateWithoutLoanInput = {
    id?: string
    processingFee: Decimal | DecimalJsLike | number | string
    legalFee?: Decimal | DecimalJsLike | number | string
    penaltyFee?: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanFinancialUncheckedCreateWithoutLoanInput = {
    id?: string
    processingFee: Decimal | DecimalJsLike | number | string
    legalFee?: Decimal | DecimalJsLike | number | string
    penaltyFee?: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanFinancialCreateOrConnectWithoutLoanInput = {
    where: LoanFinancialWhereUniqueInput
    create: XOR<LoanFinancialCreateWithoutLoanInput, LoanFinancialUncheckedCreateWithoutLoanInput>
  }

  export type LoanQualificationCreateWithoutLoanInput = {
    id?: string
    avgIncome: Decimal | DecimalJsLike | number | string
    eligibilityAmount: Decimal | DecimalJsLike | number | string
    ruleApplied: $Enums.QualificationType
    createdAt?: Date | string
  }

  export type LoanQualificationUncheckedCreateWithoutLoanInput = {
    id?: string
    avgIncome: Decimal | DecimalJsLike | number | string
    eligibilityAmount: Decimal | DecimalJsLike | number | string
    ruleApplied: $Enums.QualificationType
    createdAt?: Date | string
  }

  export type LoanQualificationCreateOrConnectWithoutLoanInput = {
    where: LoanQualificationWhereUniqueInput
    create: XOR<LoanQualificationCreateWithoutLoanInput, LoanQualificationUncheckedCreateWithoutLoanInput>
  }

  export type LoanSecurityCreateWithoutLoanInput = {
    id?: string
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanSecurityUncheckedCreateWithoutLoanInput = {
    id?: string
    idCopy?: boolean
    passportPhoto?: boolean
    appointmentLetter?: boolean
    payslips?: boolean
    bankStatement?: boolean
    chequeLeafNo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanSecurityCreateOrConnectWithoutLoanInput = {
    where: LoanSecurityWhereUniqueInput
    create: XOR<LoanSecurityCreateWithoutLoanInput, LoanSecurityUncheckedCreateWithoutLoanInput>
  }

  export type NonPerformingLoanCreateWithoutLoanInput = {
    id?: string
    capitalizedAmount: Decimal | DecimalJsLike | number | string
    flaggedAt: Date | string
    createdAt?: Date | string
  }

  export type NonPerformingLoanUncheckedCreateWithoutLoanInput = {
    id?: string
    capitalizedAmount: Decimal | DecimalJsLike | number | string
    flaggedAt: Date | string
    createdAt?: Date | string
  }

  export type NonPerformingLoanCreateOrConnectWithoutLoanInput = {
    where: NonPerformingLoanWhereUniqueInput
    create: XOR<NonPerformingLoanCreateWithoutLoanInput, NonPerformingLoanUncheckedCreateWithoutLoanInput>
  }

  export type RecoveryRecordCreateWithoutLoanInput = {
    id?: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
    agent: RecoveryAgentCreateNestedOneWithoutRecordsInput
  }

  export type RecoveryRecordUncheckedCreateWithoutLoanInput = {
    id?: string
    agentId: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
  }

  export type RecoveryRecordCreateOrConnectWithoutLoanInput = {
    where: RecoveryRecordWhereUniqueInput
    create: XOR<RecoveryRecordCreateWithoutLoanInput, RecoveryRecordUncheckedCreateWithoutLoanInput>
  }

  export type RecoveryRecordCreateManyLoanInputEnvelope = {
    data: RecoveryRecordCreateManyLoanInput | RecoveryRecordCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type RepaymentCreateWithoutLoanInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    category: $Enums.RepaymentCategory
    reference?: string | null
    createdAt?: Date | string
  }

  export type RepaymentUncheckedCreateWithoutLoanInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    category: $Enums.RepaymentCategory
    reference?: string | null
    createdAt?: Date | string
  }

  export type RepaymentCreateOrConnectWithoutLoanInput = {
    where: RepaymentWhereUniqueInput
    create: XOR<RepaymentCreateWithoutLoanInput, RepaymentUncheckedCreateWithoutLoanInput>
  }

  export type RepaymentCreateManyLoanInputEnvelope = {
    data: RepaymentCreateManyLoanInput | RepaymentCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type VehicleSecurityCreateWithoutLoanInput = {
    id?: string
    registrationNumber: string
    chassisNumber: string
    engineNumber: string
    yearOfManufacture: number
    make: string
    model: string
    bodyColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleSecurityUncheckedCreateWithoutLoanInput = {
    id?: string
    registrationNumber: string
    chassisNumber: string
    engineNumber: string
    yearOfManufacture: number
    make: string
    model: string
    bodyColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleSecurityCreateOrConnectWithoutLoanInput = {
    where: VehicleSecurityWhereUniqueInput
    create: XOR<VehicleSecurityCreateWithoutLoanInput, VehicleSecurityUncheckedCreateWithoutLoanInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutLoanInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutLoanInput, DocumentUncheckedUpdateWithoutLoanInput>
    create: XOR<DocumentCreateWithoutLoanInput, DocumentUncheckedCreateWithoutLoanInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutLoanInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutLoanInput, DocumentUncheckedUpdateWithoutLoanInput>
  }

  export type DocumentUpdateManyWithWhereWithoutLoanInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutLoanInput>
  }

  export type GuarantorUpsertWithWhereUniqueWithoutLoanInput = {
    where: GuarantorWhereUniqueInput
    update: XOR<GuarantorUpdateWithoutLoanInput, GuarantorUncheckedUpdateWithoutLoanInput>
    create: XOR<GuarantorCreateWithoutLoanInput, GuarantorUncheckedCreateWithoutLoanInput>
  }

  export type GuarantorUpdateWithWhereUniqueWithoutLoanInput = {
    where: GuarantorWhereUniqueInput
    data: XOR<GuarantorUpdateWithoutLoanInput, GuarantorUncheckedUpdateWithoutLoanInput>
  }

  export type GuarantorUpdateManyWithWhereWithoutLoanInput = {
    where: GuarantorScalarWhereInput
    data: XOR<GuarantorUpdateManyMutationInput, GuarantorUncheckedUpdateManyWithoutLoanInput>
  }

  export type GuarantorScalarWhereInput = {
    AND?: GuarantorScalarWhereInput | GuarantorScalarWhereInput[]
    OR?: GuarantorScalarWhereInput[]
    NOT?: GuarantorScalarWhereInput | GuarantorScalarWhereInput[]
    id?: StringFilter<"Guarantor"> | string
    loanId?: StringFilter<"Guarantor"> | string
    fullName?: StringFilter<"Guarantor"> | string
    phone?: StringFilter<"Guarantor"> | string
    email?: StringNullableFilter<"Guarantor"> | string | null
    idNumber?: StringNullableFilter<"Guarantor"> | string | null
    relationship?: StringNullableFilter<"Guarantor"> | string | null
    confirmationStatus?: EnumGuarantorStatusFilter<"Guarantor"> | $Enums.GuarantorStatus
    confirmedAt?: DateTimeNullableFilter<"Guarantor"> | Date | string | null
    createdAt?: DateTimeFilter<"Guarantor"> | Date | string
  }

  export type InvestorAllocationUpsertWithWhereUniqueWithoutLoanInput = {
    where: InvestorAllocationWhereUniqueInput
    update: XOR<InvestorAllocationUpdateWithoutLoanInput, InvestorAllocationUncheckedUpdateWithoutLoanInput>
    create: XOR<InvestorAllocationCreateWithoutLoanInput, InvestorAllocationUncheckedCreateWithoutLoanInput>
  }

  export type InvestorAllocationUpdateWithWhereUniqueWithoutLoanInput = {
    where: InvestorAllocationWhereUniqueInput
    data: XOR<InvestorAllocationUpdateWithoutLoanInput, InvestorAllocationUncheckedUpdateWithoutLoanInput>
  }

  export type InvestorAllocationUpdateManyWithWhereWithoutLoanInput = {
    where: InvestorAllocationScalarWhereInput
    data: XOR<InvestorAllocationUpdateManyMutationInput, InvestorAllocationUncheckedUpdateManyWithoutLoanInput>
  }

  export type InvestorAllocationScalarWhereInput = {
    AND?: InvestorAllocationScalarWhereInput | InvestorAllocationScalarWhereInput[]
    OR?: InvestorAllocationScalarWhereInput[]
    NOT?: InvestorAllocationScalarWhereInput | InvestorAllocationScalarWhereInput[]
    id?: StringFilter<"InvestorAllocation"> | string
    investorId?: StringFilter<"InvestorAllocation"> | string
    loanId?: StringFilter<"InvestorAllocation"> | string
    allocatedAmount?: DecimalFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    expectedReturn?: DecimalNullableFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFilter<"InvestorAllocation"> | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFilter<"InvestorAllocation"> | Date | string
    createdAt?: DateTimeFilter<"InvestorAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorAllocation"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutLoanInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutLoanInput, InvoiceUncheckedUpdateWithoutLoanInput>
    create: XOR<InvoiceCreateWithoutLoanInput, InvoiceUncheckedCreateWithoutLoanInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutLoanInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutLoanInput, InvoiceUncheckedUpdateWithoutLoanInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutLoanInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutLoanInput>
  }

  export type UserUpsertWithoutApprovedLoansInput = {
    update: XOR<UserUpdateWithoutApprovedLoansInput, UserUncheckedUpdateWithoutApprovedLoansInput>
    create: XOR<UserCreateWithoutApprovedLoansInput, UserUncheckedCreateWithoutApprovedLoansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedLoansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedLoansInput, UserUncheckedUpdateWithoutApprovedLoansInput>
  }

  export type UserUpdateWithoutApprovedLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ClientUpsertWithoutLoanApplicationsInput = {
    update: XOR<ClientUpdateWithoutLoanApplicationsInput, ClientUncheckedUpdateWithoutLoanApplicationsInput>
    create: XOR<ClientCreateWithoutLoanApplicationsInput, ClientUncheckedCreateWithoutLoanApplicationsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutLoanApplicationsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutLoanApplicationsInput, ClientUncheckedUpdateWithoutLoanApplicationsInput>
  }

  export type ClientUpdateWithoutLoanApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutLoanApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutReviewedLoansInput = {
    update: XOR<UserUpdateWithoutReviewedLoansInput, UserUncheckedUpdateWithoutReviewedLoansInput>
    create: XOR<UserCreateWithoutReviewedLoansInput, UserUncheckedCreateWithoutReviewedLoansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedLoansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedLoansInput, UserUncheckedUpdateWithoutReviewedLoansInput>
  }

  export type UserUpdateWithoutReviewedLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LoanDisbursementUpsertWithoutLoanInput = {
    update: XOR<LoanDisbursementUpdateWithoutLoanInput, LoanDisbursementUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanDisbursementCreateWithoutLoanInput, LoanDisbursementUncheckedCreateWithoutLoanInput>
    where?: LoanDisbursementWhereInput
  }

  export type LoanDisbursementUpdateToOneWithWhereWithoutLoanInput = {
    where?: LoanDisbursementWhereInput
    data: XOR<LoanDisbursementUpdateWithoutLoanInput, LoanDisbursementUncheckedUpdateWithoutLoanInput>
  }

  export type LoanDisbursementUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFieldUpdateOperationsInput | $Enums.DisbursementMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    disbursedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanDisbursementUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumDisbursementMethodFieldUpdateOperationsInput | $Enums.DisbursementMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    disbursedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanFinancialUpsertWithoutLoanInput = {
    update: XOR<LoanFinancialUpdateWithoutLoanInput, LoanFinancialUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanFinancialCreateWithoutLoanInput, LoanFinancialUncheckedCreateWithoutLoanInput>
    where?: LoanFinancialWhereInput
  }

  export type LoanFinancialUpdateToOneWithWhereWithoutLoanInput = {
    where?: LoanFinancialWhereInput
    data: XOR<LoanFinancialUpdateWithoutLoanInput, LoanFinancialUncheckedUpdateWithoutLoanInput>
  }

  export type LoanFinancialUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanFinancialUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    legalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    penaltyFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanQualificationUpsertWithoutLoanInput = {
    update: XOR<LoanQualificationUpdateWithoutLoanInput, LoanQualificationUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanQualificationCreateWithoutLoanInput, LoanQualificationUncheckedCreateWithoutLoanInput>
    where?: LoanQualificationWhereInput
  }

  export type LoanQualificationUpdateToOneWithWhereWithoutLoanInput = {
    where?: LoanQualificationWhereInput
    data: XOR<LoanQualificationUpdateWithoutLoanInput, LoanQualificationUncheckedUpdateWithoutLoanInput>
  }

  export type LoanQualificationUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    avgIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanQualificationUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    avgIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eligibilityAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ruleApplied?: EnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanSecurityUpsertWithoutLoanInput = {
    update: XOR<LoanSecurityUpdateWithoutLoanInput, LoanSecurityUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanSecurityCreateWithoutLoanInput, LoanSecurityUncheckedCreateWithoutLoanInput>
    where?: LoanSecurityWhereInput
  }

  export type LoanSecurityUpdateToOneWithWhereWithoutLoanInput = {
    where?: LoanSecurityWhereInput
    data: XOR<LoanSecurityUpdateWithoutLoanInput, LoanSecurityUncheckedUpdateWithoutLoanInput>
  }

  export type LoanSecurityUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCopy?: BoolFieldUpdateOperationsInput | boolean
    passportPhoto?: BoolFieldUpdateOperationsInput | boolean
    appointmentLetter?: BoolFieldUpdateOperationsInput | boolean
    payslips?: BoolFieldUpdateOperationsInput | boolean
    bankStatement?: BoolFieldUpdateOperationsInput | boolean
    chequeLeafNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanSecurityUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCopy?: BoolFieldUpdateOperationsInput | boolean
    passportPhoto?: BoolFieldUpdateOperationsInput | boolean
    appointmentLetter?: BoolFieldUpdateOperationsInput | boolean
    payslips?: BoolFieldUpdateOperationsInput | boolean
    bankStatement?: BoolFieldUpdateOperationsInput | boolean
    chequeLeafNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonPerformingLoanUpsertWithoutLoanInput = {
    update: XOR<NonPerformingLoanUpdateWithoutLoanInput, NonPerformingLoanUncheckedUpdateWithoutLoanInput>
    create: XOR<NonPerformingLoanCreateWithoutLoanInput, NonPerformingLoanUncheckedCreateWithoutLoanInput>
    where?: NonPerformingLoanWhereInput
  }

  export type NonPerformingLoanUpdateToOneWithWhereWithoutLoanInput = {
    where?: NonPerformingLoanWhereInput
    data: XOR<NonPerformingLoanUpdateWithoutLoanInput, NonPerformingLoanUncheckedUpdateWithoutLoanInput>
  }

  export type NonPerformingLoanUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    capitalizedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NonPerformingLoanUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    capitalizedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordUpsertWithWhereUniqueWithoutLoanInput = {
    where: RecoveryRecordWhereUniqueInput
    update: XOR<RecoveryRecordUpdateWithoutLoanInput, RecoveryRecordUncheckedUpdateWithoutLoanInput>
    create: XOR<RecoveryRecordCreateWithoutLoanInput, RecoveryRecordUncheckedCreateWithoutLoanInput>
  }

  export type RecoveryRecordUpdateWithWhereUniqueWithoutLoanInput = {
    where: RecoveryRecordWhereUniqueInput
    data: XOR<RecoveryRecordUpdateWithoutLoanInput, RecoveryRecordUncheckedUpdateWithoutLoanInput>
  }

  export type RecoveryRecordUpdateManyWithWhereWithoutLoanInput = {
    where: RecoveryRecordScalarWhereInput
    data: XOR<RecoveryRecordUpdateManyMutationInput, RecoveryRecordUncheckedUpdateManyWithoutLoanInput>
  }

  export type RecoveryRecordScalarWhereInput = {
    AND?: RecoveryRecordScalarWhereInput | RecoveryRecordScalarWhereInput[]
    OR?: RecoveryRecordScalarWhereInput[]
    NOT?: RecoveryRecordScalarWhereInput | RecoveryRecordScalarWhereInput[]
    id?: StringFilter<"RecoveryRecord"> | string
    loanId?: StringFilter<"RecoveryRecord"> | string
    agentId?: StringFilter<"RecoveryRecord"> | string
    actionTaken?: StringFilter<"RecoveryRecord"> | string
    outcome?: StringNullableFilter<"RecoveryRecord"> | string | null
    recordedAt?: DateTimeFilter<"RecoveryRecord"> | Date | string
    createdAt?: DateTimeFilter<"RecoveryRecord"> | Date | string
  }

  export type RepaymentUpsertWithWhereUniqueWithoutLoanInput = {
    where: RepaymentWhereUniqueInput
    update: XOR<RepaymentUpdateWithoutLoanInput, RepaymentUncheckedUpdateWithoutLoanInput>
    create: XOR<RepaymentCreateWithoutLoanInput, RepaymentUncheckedCreateWithoutLoanInput>
  }

  export type RepaymentUpdateWithWhereUniqueWithoutLoanInput = {
    where: RepaymentWhereUniqueInput
    data: XOR<RepaymentUpdateWithoutLoanInput, RepaymentUncheckedUpdateWithoutLoanInput>
  }

  export type RepaymentUpdateManyWithWhereWithoutLoanInput = {
    where: RepaymentScalarWhereInput
    data: XOR<RepaymentUpdateManyMutationInput, RepaymentUncheckedUpdateManyWithoutLoanInput>
  }

  export type RepaymentScalarWhereInput = {
    AND?: RepaymentScalarWhereInput | RepaymentScalarWhereInput[]
    OR?: RepaymentScalarWhereInput[]
    NOT?: RepaymentScalarWhereInput | RepaymentScalarWhereInput[]
    id?: StringFilter<"Repayment"> | string
    loanId?: StringFilter<"Repayment"> | string
    amount?: DecimalFilter<"Repayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Repayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"Repayment"> | Date | string
    category?: EnumRepaymentCategoryFilter<"Repayment"> | $Enums.RepaymentCategory
    reference?: StringNullableFilter<"Repayment"> | string | null
    createdAt?: DateTimeFilter<"Repayment"> | Date | string
  }

  export type VehicleSecurityUpsertWithoutLoanInput = {
    update: XOR<VehicleSecurityUpdateWithoutLoanInput, VehicleSecurityUncheckedUpdateWithoutLoanInput>
    create: XOR<VehicleSecurityCreateWithoutLoanInput, VehicleSecurityUncheckedCreateWithoutLoanInput>
    where?: VehicleSecurityWhereInput
  }

  export type VehicleSecurityUpdateToOneWithWhereWithoutLoanInput = {
    where?: VehicleSecurityWhereInput
    data: XOR<VehicleSecurityUpdateWithoutLoanInput, VehicleSecurityUncheckedUpdateWithoutLoanInput>
  }

  export type VehicleSecurityUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    chassisNumber?: StringFieldUpdateOperationsInput | string
    engineNumber?: StringFieldUpdateOperationsInput | string
    yearOfManufacture?: IntFieldUpdateOperationsInput | number
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    bodyColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleSecurityUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    chassisNumber?: StringFieldUpdateOperationsInput | string
    engineNumber?: StringFieldUpdateOperationsInput | string
    yearOfManufacture?: IntFieldUpdateOperationsInput | number
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    bodyColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationCreateWithoutQualificationInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutQualificationInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutQualificationInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutQualificationInput, LoanApplicationUncheckedCreateWithoutQualificationInput>
  }

  export type LoanApplicationUpsertWithoutQualificationInput = {
    update: XOR<LoanApplicationUpdateWithoutQualificationInput, LoanApplicationUncheckedUpdateWithoutQualificationInput>
    create: XOR<LoanApplicationCreateWithoutQualificationInput, LoanApplicationUncheckedCreateWithoutQualificationInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutQualificationInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutQualificationInput, LoanApplicationUncheckedUpdateWithoutQualificationInput>
  }

  export type LoanApplicationUpdateWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationCreateWithoutSecurityInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutSecurityInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutSecurityInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutSecurityInput, LoanApplicationUncheckedCreateWithoutSecurityInput>
  }

  export type LoanApplicationUpsertWithoutSecurityInput = {
    update: XOR<LoanApplicationUpdateWithoutSecurityInput, LoanApplicationUncheckedUpdateWithoutSecurityInput>
    create: XOR<LoanApplicationCreateWithoutSecurityInput, LoanApplicationUncheckedCreateWithoutSecurityInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutSecurityInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutSecurityInput, LoanApplicationUncheckedUpdateWithoutSecurityInput>
  }

  export type LoanApplicationUpdateWithoutSecurityInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutSecurityInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationCreateWithoutVehicleSecurityInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutVehicleSecurityInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutVehicleSecurityInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutVehicleSecurityInput, LoanApplicationUncheckedCreateWithoutVehicleSecurityInput>
  }

  export type LoanApplicationUpsertWithoutVehicleSecurityInput = {
    update: XOR<LoanApplicationUpdateWithoutVehicleSecurityInput, LoanApplicationUncheckedUpdateWithoutVehicleSecurityInput>
    create: XOR<LoanApplicationCreateWithoutVehicleSecurityInput, LoanApplicationUncheckedCreateWithoutVehicleSecurityInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutVehicleSecurityInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutVehicleSecurityInput, LoanApplicationUncheckedUpdateWithoutVehicleSecurityInput>
  }

  export type LoanApplicationUpdateWithoutVehicleSecurityInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutVehicleSecurityInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoanApplicationCreateWithoutGuarantorsInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutGuarantorsInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutGuarantorsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutGuarantorsInput, LoanApplicationUncheckedCreateWithoutGuarantorsInput>
  }

  export type LoanApplicationUpsertWithoutGuarantorsInput = {
    update: XOR<LoanApplicationUpdateWithoutGuarantorsInput, LoanApplicationUncheckedUpdateWithoutGuarantorsInput>
    create: XOR<LoanApplicationCreateWithoutGuarantorsInput, LoanApplicationUncheckedCreateWithoutGuarantorsInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutGuarantorsInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutGuarantorsInput, LoanApplicationUncheckedUpdateWithoutGuarantorsInput>
  }

  export type LoanApplicationUpdateWithoutGuarantorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutGuarantorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationCreateWithoutDisbursementInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutDisbursementInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutDisbursementInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutDisbursementInput, LoanApplicationUncheckedCreateWithoutDisbursementInput>
  }

  export type LoanApplicationUpsertWithoutDisbursementInput = {
    update: XOR<LoanApplicationUpdateWithoutDisbursementInput, LoanApplicationUncheckedUpdateWithoutDisbursementInput>
    create: XOR<LoanApplicationCreateWithoutDisbursementInput, LoanApplicationUncheckedCreateWithoutDisbursementInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutDisbursementInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutDisbursementInput, LoanApplicationUncheckedUpdateWithoutDisbursementInput>
  }

  export type LoanApplicationUpdateWithoutDisbursementInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutDisbursementInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationCreateWithoutFinancialsInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutFinancialsInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutFinancialsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutFinancialsInput, LoanApplicationUncheckedCreateWithoutFinancialsInput>
  }

  export type LoanApplicationUpsertWithoutFinancialsInput = {
    update: XOR<LoanApplicationUpdateWithoutFinancialsInput, LoanApplicationUncheckedUpdateWithoutFinancialsInput>
    create: XOR<LoanApplicationCreateWithoutFinancialsInput, LoanApplicationUncheckedCreateWithoutFinancialsInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutFinancialsInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutFinancialsInput, LoanApplicationUncheckedUpdateWithoutFinancialsInput>
  }

  export type LoanApplicationUpdateWithoutFinancialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutFinancialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    chargeType: $Enums.ChargeType
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    glAccount?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    chargeType: $Enums.ChargeType
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    glAccount?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoicePaymentCreateWithoutInvoiceInput = {
    id?: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    transaction?: TransactionCreateNestedOneWithoutInvoicePaymentsInput
  }

  export type InvoicePaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    transactionId?: string | null
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
  }

  export type InvoicePaymentCreateOrConnectWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    create: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoicePaymentCreateManyInvoiceInputEnvelope = {
    data: InvoicePaymentCreateManyInvoiceInput | InvoicePaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutInvoicesInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutInvoicesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
  }

  export type LoanApplicationCreateWithoutInvoicesInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutInvoicesInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutInvoicesInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutInvoicesInput, LoanApplicationUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    chargeType?: EnumChargeTypeFilter<"InvoiceItem"> | $Enums.ChargeType
    description?: StringNullableFilter<"InvoiceItem"> | string | null
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    glAccount?: StringNullableFilter<"InvoiceItem"> | string | null
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
  }

  export type InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    update: XOR<InvoicePaymentUpdateWithoutInvoiceInput, InvoicePaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    data: XOR<InvoicePaymentUpdateWithoutInvoiceInput, InvoicePaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoicePaymentScalarWhereInput
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoicePaymentScalarWhereInput = {
    AND?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
    OR?: InvoicePaymentScalarWhereInput[]
    NOT?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
    id?: StringFilter<"InvoicePayment"> | string
    invoiceId?: StringFilter<"InvoicePayment"> | string
    transactionId?: StringNullableFilter<"InvoicePayment"> | string | null
    amountPaid?: DecimalFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"InvoicePayment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"InvoicePayment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
  }

  export type ClientUpsertWithoutInvoicesInput = {
    update: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LoanApplicationUpsertWithoutInvoicesInput = {
    update: XOR<LoanApplicationUpdateWithoutInvoicesInput, LoanApplicationUncheckedUpdateWithoutInvoicesInput>
    create: XOR<LoanApplicationCreateWithoutInvoicesInput, LoanApplicationUncheckedCreateWithoutInvoicesInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutInvoicesInput, LoanApplicationUncheckedUpdateWithoutInvoicesInput>
  }

  export type LoanApplicationUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    loan: LoanApplicationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    clientId: string
    loanId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    loan?: LoanApplicationUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    loan: LoanApplicationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    clientId: string
    loanId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type TransactionCreateWithoutInvoicePaymentsInput = {
    id?: string
    transactionCode: string
    transactionType: $Enums.TransactionType
    referenceType: $Enums.ReferenceType
    referenceId: string
    amount: Decimal | DecimalJsLike | number | string
    debitAccount: string
    creditAccount: string
    paymentMethod?: $Enums.PaymentMethod | null
    transactionDate: Date | string
    description?: string | null
    status?: $Enums.TransactionStatus
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutInvoicePaymentsInput = {
    id?: string
    transactionCode: string
    transactionType: $Enums.TransactionType
    referenceType: $Enums.ReferenceType
    referenceId: string
    amount: Decimal | DecimalJsLike | number | string
    debitAccount: string
    creditAccount: string
    paymentMethod?: $Enums.PaymentMethod | null
    transactionDate: Date | string
    description?: string | null
    status?: $Enums.TransactionStatus
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutInvoicePaymentsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutInvoicePaymentsInput, TransactionUncheckedCreateWithoutInvoicePaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    loan?: LoanApplicationUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type TransactionUpsertWithoutInvoicePaymentsInput = {
    update: XOR<TransactionUpdateWithoutInvoicePaymentsInput, TransactionUncheckedUpdateWithoutInvoicePaymentsInput>
    create: XOR<TransactionCreateWithoutInvoicePaymentsInput, TransactionUncheckedCreateWithoutInvoicePaymentsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutInvoicePaymentsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutInvoicePaymentsInput, TransactionUncheckedUpdateWithoutInvoicePaymentsInput>
  }

  export type TransactionUpdateWithoutInvoicePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionCode?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    referenceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFieldUpdateOperationsInput | string
    creditAccount?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutInvoicePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionCode?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    referenceType?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    referenceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debitAccount?: StringFieldUpdateOperationsInput | string
    creditAccount?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentCreateWithoutTransactionInput = {
    id?: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type InvoicePaymentUncheckedCreateWithoutTransactionInput = {
    id?: string
    invoiceId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
  }

  export type InvoicePaymentCreateOrConnectWithoutTransactionInput = {
    where: InvoicePaymentWhereUniqueInput
    create: XOR<InvoicePaymentCreateWithoutTransactionInput, InvoicePaymentUncheckedCreateWithoutTransactionInput>
  }

  export type InvoicePaymentCreateManyTransactionInputEnvelope = {
    data: InvoicePaymentCreateManyTransactionInput | InvoicePaymentCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type InvoicePaymentUpsertWithWhereUniqueWithoutTransactionInput = {
    where: InvoicePaymentWhereUniqueInput
    update: XOR<InvoicePaymentUpdateWithoutTransactionInput, InvoicePaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<InvoicePaymentCreateWithoutTransactionInput, InvoicePaymentUncheckedCreateWithoutTransactionInput>
  }

  export type InvoicePaymentUpdateWithWhereUniqueWithoutTransactionInput = {
    where: InvoicePaymentWhereUniqueInput
    data: XOR<InvoicePaymentUpdateWithoutTransactionInput, InvoicePaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type InvoicePaymentUpdateManyWithWhereWithoutTransactionInput = {
    where: InvoicePaymentScalarWhereInput
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyWithoutTransactionInput>
  }

  export type LoanApplicationCreateWithoutRepaymentsInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutRepaymentsInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutRepaymentsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutRepaymentsInput, LoanApplicationUncheckedCreateWithoutRepaymentsInput>
  }

  export type LoanApplicationUpsertWithoutRepaymentsInput = {
    update: XOR<LoanApplicationUpdateWithoutRepaymentsInput, LoanApplicationUncheckedUpdateWithoutRepaymentsInput>
    create: XOR<LoanApplicationCreateWithoutRepaymentsInput, LoanApplicationUncheckedCreateWithoutRepaymentsInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutRepaymentsInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutRepaymentsInput, LoanApplicationUncheckedUpdateWithoutRepaymentsInput>
  }

  export type LoanApplicationUpdateWithoutRepaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutRepaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationCreateWithoutNplInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutNplInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutNplInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutNplInput, LoanApplicationUncheckedCreateWithoutNplInput>
  }

  export type LoanApplicationUpsertWithoutNplInput = {
    update: XOR<LoanApplicationUpdateWithoutNplInput, LoanApplicationUncheckedUpdateWithoutNplInput>
    create: XOR<LoanApplicationCreateWithoutNplInput, LoanApplicationUncheckedCreateWithoutNplInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutNplInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutNplInput, LoanApplicationUncheckedUpdateWithoutNplInput>
  }

  export type LoanApplicationUpdateWithoutNplInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutNplInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type UserCreateWithoutRecoveryAgentInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
  }

  export type UserUncheckedCreateWithoutRecoveryAgentInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
  }

  export type UserCreateOrConnectWithoutRecoveryAgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecoveryAgentInput, UserUncheckedCreateWithoutRecoveryAgentInput>
  }

  export type RecoveryRecordCreateWithoutAgentInput = {
    id?: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutRecoveryRecordsInput
  }

  export type RecoveryRecordUncheckedCreateWithoutAgentInput = {
    id?: string
    loanId: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
  }

  export type RecoveryRecordCreateOrConnectWithoutAgentInput = {
    where: RecoveryRecordWhereUniqueInput
    create: XOR<RecoveryRecordCreateWithoutAgentInput, RecoveryRecordUncheckedCreateWithoutAgentInput>
  }

  export type RecoveryRecordCreateManyAgentInputEnvelope = {
    data: RecoveryRecordCreateManyAgentInput | RecoveryRecordCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecoveryAgentInput = {
    update: XOR<UserUpdateWithoutRecoveryAgentInput, UserUncheckedUpdateWithoutRecoveryAgentInput>
    create: XOR<UserCreateWithoutRecoveryAgentInput, UserUncheckedCreateWithoutRecoveryAgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecoveryAgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecoveryAgentInput, UserUncheckedUpdateWithoutRecoveryAgentInput>
  }

  export type UserUpdateWithoutRecoveryAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecoveryAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
  }

  export type RecoveryRecordUpsertWithWhereUniqueWithoutAgentInput = {
    where: RecoveryRecordWhereUniqueInput
    update: XOR<RecoveryRecordUpdateWithoutAgentInput, RecoveryRecordUncheckedUpdateWithoutAgentInput>
    create: XOR<RecoveryRecordCreateWithoutAgentInput, RecoveryRecordUncheckedCreateWithoutAgentInput>
  }

  export type RecoveryRecordUpdateWithWhereUniqueWithoutAgentInput = {
    where: RecoveryRecordWhereUniqueInput
    data: XOR<RecoveryRecordUpdateWithoutAgentInput, RecoveryRecordUncheckedUpdateWithoutAgentInput>
  }

  export type RecoveryRecordUpdateManyWithWhereWithoutAgentInput = {
    where: RecoveryRecordScalarWhereInput
    data: XOR<RecoveryRecordUpdateManyMutationInput, RecoveryRecordUncheckedUpdateManyWithoutAgentInput>
  }

  export type RecoveryAgentCreateWithoutRecordsInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRecoveryAgentInput
  }

  export type RecoveryAgentUncheckedCreateWithoutRecordsInput = {
    id?: string
    userId?: string | null
    name: string
    phone: string
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecoveryAgentCreateOrConnectWithoutRecordsInput = {
    where: RecoveryAgentWhereUniqueInput
    create: XOR<RecoveryAgentCreateWithoutRecordsInput, RecoveryAgentUncheckedCreateWithoutRecordsInput>
  }

  export type LoanApplicationCreateWithoutRecoveryRecordsInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutRecoveryRecordsInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutRecoveryRecordsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutRecoveryRecordsInput, LoanApplicationUncheckedCreateWithoutRecoveryRecordsInput>
  }

  export type RecoveryAgentUpsertWithoutRecordsInput = {
    update: XOR<RecoveryAgentUpdateWithoutRecordsInput, RecoveryAgentUncheckedUpdateWithoutRecordsInput>
    create: XOR<RecoveryAgentCreateWithoutRecordsInput, RecoveryAgentUncheckedCreateWithoutRecordsInput>
    where?: RecoveryAgentWhereInput
  }

  export type RecoveryAgentUpdateToOneWithWhereWithoutRecordsInput = {
    where?: RecoveryAgentWhereInput
    data: XOR<RecoveryAgentUpdateWithoutRecordsInput, RecoveryAgentUncheckedUpdateWithoutRecordsInput>
  }

  export type RecoveryAgentUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRecoveryAgentNestedInput
  }

  export type RecoveryAgentUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUpsertWithoutRecoveryRecordsInput = {
    update: XOR<LoanApplicationUpdateWithoutRecoveryRecordsInput, LoanApplicationUncheckedUpdateWithoutRecoveryRecordsInput>
    create: XOR<LoanApplicationCreateWithoutRecoveryRecordsInput, LoanApplicationUncheckedCreateWithoutRecoveryRecordsInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutRecoveryRecordsInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutRecoveryRecordsInput, LoanApplicationUncheckedUpdateWithoutRecoveryRecordsInput>
  }

  export type LoanApplicationUpdateWithoutRecoveryRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutRecoveryRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type InvestorAllocationCreateWithoutInvestorInput = {
    id?: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanApplicationCreateNestedOneWithoutInvestorAllocationsInput
  }

  export type InvestorAllocationUncheckedCreateWithoutInvestorInput = {
    id?: string
    loanId: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorAllocationCreateOrConnectWithoutInvestorInput = {
    where: InvestorAllocationWhereUniqueInput
    create: XOR<InvestorAllocationCreateWithoutInvestorInput, InvestorAllocationUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorAllocationCreateManyInvestorInputEnvelope = {
    data: InvestorAllocationCreateManyInvestorInput | InvestorAllocationCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type InvestorPayoutCreateWithoutInvestorInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payoutDate: Date | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type InvestorPayoutUncheckedCreateWithoutInvestorInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payoutDate: Date | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type InvestorPayoutCreateOrConnectWithoutInvestorInput = {
    where: InvestorPayoutWhereUniqueInput
    create: XOR<InvestorPayoutCreateWithoutInvestorInput, InvestorPayoutUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorPayoutCreateManyInvestorInputEnvelope = {
    data: InvestorPayoutCreateManyInvestorInput | InvestorPayoutCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutInvestorInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestorInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorAllocationUpsertWithWhereUniqueWithoutInvestorInput = {
    where: InvestorAllocationWhereUniqueInput
    update: XOR<InvestorAllocationUpdateWithoutInvestorInput, InvestorAllocationUncheckedUpdateWithoutInvestorInput>
    create: XOR<InvestorAllocationCreateWithoutInvestorInput, InvestorAllocationUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorAllocationUpdateWithWhereUniqueWithoutInvestorInput = {
    where: InvestorAllocationWhereUniqueInput
    data: XOR<InvestorAllocationUpdateWithoutInvestorInput, InvestorAllocationUncheckedUpdateWithoutInvestorInput>
  }

  export type InvestorAllocationUpdateManyWithWhereWithoutInvestorInput = {
    where: InvestorAllocationScalarWhereInput
    data: XOR<InvestorAllocationUpdateManyMutationInput, InvestorAllocationUncheckedUpdateManyWithoutInvestorInput>
  }

  export type InvestorPayoutUpsertWithWhereUniqueWithoutInvestorInput = {
    where: InvestorPayoutWhereUniqueInput
    update: XOR<InvestorPayoutUpdateWithoutInvestorInput, InvestorPayoutUncheckedUpdateWithoutInvestorInput>
    create: XOR<InvestorPayoutCreateWithoutInvestorInput, InvestorPayoutUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorPayoutUpdateWithWhereUniqueWithoutInvestorInput = {
    where: InvestorPayoutWhereUniqueInput
    data: XOR<InvestorPayoutUpdateWithoutInvestorInput, InvestorPayoutUncheckedUpdateWithoutInvestorInput>
  }

  export type InvestorPayoutUpdateManyWithWhereWithoutInvestorInput = {
    where: InvestorPayoutScalarWhereInput
    data: XOR<InvestorPayoutUpdateManyMutationInput, InvestorPayoutUncheckedUpdateManyWithoutInvestorInput>
  }

  export type InvestorPayoutScalarWhereInput = {
    AND?: InvestorPayoutScalarWhereInput | InvestorPayoutScalarWhereInput[]
    OR?: InvestorPayoutScalarWhereInput[]
    NOT?: InvestorPayoutScalarWhereInput | InvestorPayoutScalarWhereInput[]
    id?: StringFilter<"InvestorPayout"> | string
    investorId?: StringFilter<"InvestorPayout"> | string
    amount?: DecimalFilter<"InvestorPayout"> | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFilter<"InvestorPayout"> | Date | string
    reference?: StringNullableFilter<"InvestorPayout"> | string | null
    createdAt?: DateTimeFilter<"InvestorPayout"> | Date | string
  }

  export type UserUpsertWithoutInvestorInput = {
    update: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type UserUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type InvestorCreateWithoutAllocationsInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payouts?: InvestorPayoutCreateNestedManyWithoutInvestorInput
    user?: UserCreateNestedOneWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutAllocationsInput = {
    id?: string
    userId?: string | null
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payouts?: InvestorPayoutUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutAllocationsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutAllocationsInput, InvestorUncheckedCreateWithoutAllocationsInput>
  }

  export type LoanApplicationCreateWithoutInvestorAllocationsInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutInvestorAllocationsInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLoanInput
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutInvestorAllocationsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutInvestorAllocationsInput, LoanApplicationUncheckedCreateWithoutInvestorAllocationsInput>
  }

  export type InvestorUpsertWithoutAllocationsInput = {
    update: XOR<InvestorUpdateWithoutAllocationsInput, InvestorUncheckedUpdateWithoutAllocationsInput>
    create: XOR<InvestorCreateWithoutAllocationsInput, InvestorUncheckedCreateWithoutAllocationsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutAllocationsInput, InvestorUncheckedUpdateWithoutAllocationsInput>
  }

  export type InvestorUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: InvestorPayoutUpdateManyWithoutInvestorNestedInput
    user?: UserUpdateOneWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: InvestorPayoutUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type LoanApplicationUpsertWithoutInvestorAllocationsInput = {
    update: XOR<LoanApplicationUpdateWithoutInvestorAllocationsInput, LoanApplicationUncheckedUpdateWithoutInvestorAllocationsInput>
    create: XOR<LoanApplicationCreateWithoutInvestorAllocationsInput, LoanApplicationUncheckedCreateWithoutInvestorAllocationsInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutInvestorAllocationsInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutInvestorAllocationsInput, LoanApplicationUncheckedUpdateWithoutInvestorAllocationsInput>
  }

  export type LoanApplicationUpdateWithoutInvestorAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutInvestorAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type InvestorCreateWithoutPayoutsInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: InvestorAllocationCreateNestedManyWithoutInvestorInput
    user?: UserCreateNestedOneWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutPayoutsInput = {
    id?: string
    userId?: string | null
    name: string
    contact: string
    email?: string | null
    investedAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: InvestorAllocationUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutPayoutsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutPayoutsInput, InvestorUncheckedCreateWithoutPayoutsInput>
  }

  export type InvestorUpsertWithoutPayoutsInput = {
    update: XOR<InvestorUpdateWithoutPayoutsInput, InvestorUncheckedUpdateWithoutPayoutsInput>
    create: XOR<InvestorCreateWithoutPayoutsInput, InvestorUncheckedCreateWithoutPayoutsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutPayoutsInput, InvestorUncheckedUpdateWithoutPayoutsInput>
  }

  export type InvestorUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: InvestorAllocationUpdateManyWithoutInvestorNestedInput
    user?: UserUpdateOneWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    investedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: InvestorAllocationUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type ClientCreateWithoutDocumentsInput = {
    id?: string
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    user?: UserCreateNestedOneWithoutClientInput
    employmentDetails?: EmploymentDetailCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutClientInput
    referees?: RefereeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId?: string | null
    title: $Enums.Title
    surname: string
    otherNames: string
    dateOfBirth: Date | string
    maritalStatus: $Enums.MaritalStatus
    nationality: string
    dependents?: number
    idPassportNo: string
    kraPin?: string | null
    phoneWork?: string | null
    phoneMobile: string
    phoneAlternative?: string | null
    emailPersonal?: string | null
    emailOfficial?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetails?: BankDetailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    employmentDetails?: EmploymentDetailUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutClientInput
    referees?: RefereeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDocumentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
  }

  export type LoanApplicationCreateWithoutDocumentsInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guarantors?: GuarantorCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationCreateNestedManyWithoutLoanInput
    invoices?: InvoiceCreateNestedManyWithoutLoanInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLoansInput
    client: ClientCreateNestedOneWithoutLoanApplicationsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedLoansInput
    disbursement?: LoanDisbursementCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationCreateNestedOneWithoutLoanInput
    security?: LoanSecurityCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordCreateNestedManyWithoutLoanInput
    repayments?: RepaymentCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guarantors?: GuarantorUncheckedCreateNestedManyWithoutLoanInput
    investorAllocations?: InvestorAllocationUncheckedCreateNestedManyWithoutLoanInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLoanInput
    disbursement?: LoanDisbursementUncheckedCreateNestedOneWithoutLoanInput
    financials?: LoanFinancialUncheckedCreateNestedOneWithoutLoanInput
    qualification?: LoanQualificationUncheckedCreateNestedOneWithoutLoanInput
    security?: LoanSecurityUncheckedCreateNestedOneWithoutLoanInput
    npl?: NonPerformingLoanUncheckedCreateNestedOneWithoutLoanInput
    recoveryRecords?: RecoveryRecordUncheckedCreateNestedManyWithoutLoanInput
    repayments?: RepaymentUncheckedCreateNestedManyWithoutLoanInput
    vehicleSecurity?: VehicleSecurityUncheckedCreateNestedOneWithoutLoanInput
  }

  export type LoanApplicationCreateOrConnectWithoutDocumentsInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
  }

  export type ClientUpsertWithoutDocumentsInput = {
    update: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutClientNestedInput
    referees?: RefereeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    nationality?: StringFieldUpdateOperationsInput | string
    dependents?: IntFieldUpdateOperationsInput | number
    idPassportNo?: StringFieldUpdateOperationsInput | string
    kraPin?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    phoneAlternative?: NullableStringFieldUpdateOperationsInput | string | null
    emailPersonal?: NullableStringFieldUpdateOperationsInput | string | null
    emailOfficial?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetails?: BankDetailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    employmentDetails?: EmploymentDetailUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutClientNestedInput
    referees?: RefereeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LoanApplicationUpsertWithoutDocumentsInput = {
    update: XOR<LoanApplicationUpdateWithoutDocumentsInput, LoanApplicationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LoanApplicationCreateWithoutDocumentsInput, LoanApplicationUncheckedCreateWithoutDocumentsInput>
    where?: LoanApplicationWhereInput
  }

  export type LoanApplicationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: LoanApplicationWhereInput
    data: XOR<LoanApplicationUpdateWithoutDocumentsInput, LoanApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type LoanApplicationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ChartOfAccountCreateWithoutChildAccountsInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentAccount?: ChartOfAccountCreateNestedOneWithoutChildAccountsInput
  }

  export type ChartOfAccountUncheckedCreateWithoutChildAccountsInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    parentAccountId?: string | null
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChartOfAccountCreateOrConnectWithoutChildAccountsInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutChildAccountsInput, ChartOfAccountUncheckedCreateWithoutChildAccountsInput>
  }

  export type ChartOfAccountCreateWithoutParentAccountInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    childAccounts?: ChartOfAccountCreateNestedManyWithoutParentAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutParentAccountInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    childAccounts?: ChartOfAccountUncheckedCreateNestedManyWithoutParentAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutParentAccountInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutParentAccountInput, ChartOfAccountUncheckedCreateWithoutParentAccountInput>
  }

  export type ChartOfAccountCreateManyParentAccountInputEnvelope = {
    data: ChartOfAccountCreateManyParentAccountInput | ChartOfAccountCreateManyParentAccountInput[]
    skipDuplicates?: boolean
  }

  export type ChartOfAccountUpsertWithoutChildAccountsInput = {
    update: XOR<ChartOfAccountUpdateWithoutChildAccountsInput, ChartOfAccountUncheckedUpdateWithoutChildAccountsInput>
    create: XOR<ChartOfAccountCreateWithoutChildAccountsInput, ChartOfAccountUncheckedCreateWithoutChildAccountsInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutChildAccountsInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutChildAccountsInput, ChartOfAccountUncheckedUpdateWithoutChildAccountsInput>
  }

  export type ChartOfAccountUpdateWithoutChildAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentAccount?: ChartOfAccountUpdateOneWithoutChildAccountsNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutChildAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartOfAccountUpsertWithWhereUniqueWithoutParentAccountInput = {
    where: ChartOfAccountWhereUniqueInput
    update: XOR<ChartOfAccountUpdateWithoutParentAccountInput, ChartOfAccountUncheckedUpdateWithoutParentAccountInput>
    create: XOR<ChartOfAccountCreateWithoutParentAccountInput, ChartOfAccountUncheckedCreateWithoutParentAccountInput>
  }

  export type ChartOfAccountUpdateWithWhereUniqueWithoutParentAccountInput = {
    where: ChartOfAccountWhereUniqueInput
    data: XOR<ChartOfAccountUpdateWithoutParentAccountInput, ChartOfAccountUncheckedUpdateWithoutParentAccountInput>
  }

  export type ChartOfAccountUpdateManyWithWhereWithoutParentAccountInput = {
    where: ChartOfAccountScalarWhereInput
    data: XOR<ChartOfAccountUpdateManyMutationInput, ChartOfAccountUncheckedUpdateManyWithoutParentAccountInput>
  }

  export type ChartOfAccountScalarWhereInput = {
    AND?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
    OR?: ChartOfAccountScalarWhereInput[]
    NOT?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
    id?: StringFilter<"ChartOfAccount"> | string
    accountCode?: StringFilter<"ChartOfAccount"> | string
    accountName?: StringFilter<"ChartOfAccount"> | string
    accountType?: EnumAccountTypeFilter<"ChartOfAccount"> | $Enums.AccountType
    parentAccountId?: StringNullableFilter<"ChartOfAccount"> | string | null
    normalBalance?: EnumNormalBalanceFilter<"ChartOfAccount"> | $Enums.NormalBalance
    isActive?: BoolFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    emailVerified?: boolean | null
    name: string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    approvedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedLoans?: LoanApplicationUncheckedCreateNestedManyWithoutReviewedByInput
    recoveryAgent?: RecoveryAgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    approvedLoans?: LoanApplicationUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedLoans?: LoanApplicationUncheckedUpdateManyWithoutReviewedByNestedInput
    recoveryAgent?: RecoveryAgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type LoanApplicationCreateManyApprovedByInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationCreateManyReviewedByInput = {
    id?: string
    clientId: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    client?: ClientUpdateOneRequiredWithoutLoanApplicationsNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateManyWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailCreateManyClientInput = {
    id?: string
    bankName: string
    branch: string
    accountName: string
    accountNumber: string
    proofDocument?: string | null
    proofDocumentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAddressCreateManyClientInput = {
    id?: string
    postalAddress?: string | null
    postalCode?: string | null
    townCity?: string | null
    residentialAddress?: string | null
    location?: string | null
    estate?: string | null
    building?: string | null
    houseNumber?: string | null
    landmark?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyClientInput = {
    id?: string
    loanId?: string | null
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type EmploymentDetailCreateManyClientInput = {
    id?: string
    employerName: string
    jobTitle: string
    department?: string | null
    dateJoined?: Date | string | null
    periodWorked?: string | null
    employmentType: $Enums.EmploymentType
    contractExpiry?: Date | string | null
    onNotice?: boolean
    netSalary: Decimal | DecimalJsLike | number | string
    branchLocation?: string | null
    roadStreet?: string | null
    building?: string | null
    floorOffice?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    invoiceNumber: string
    loanId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationCreateManyClientInput = {
    id?: string
    purpose: string
    amountRequested: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    qualificationType?: $Enums.QualificationType | null
    interestRate?: Decimal | DecimalJsLike | number | string
    startDate?: Date | string | null
    repaymentPeriod: number
    status?: $Enums.LoanApplicationStatus
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedById?: string | null
    approvedAt?: Date | string | null
    approvedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefereeCreateManyClientInput = {
    id?: string
    surname: string
    otherNames: string
    relationship: string
    idPassportNo?: string | null
    employerName?: string | null
    locationStation?: string | null
    phoneWork?: string | null
    phoneMobile: string
    isRelative?: boolean
    createdAt?: Date | string
  }

  export type BankDetailUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    townCity?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    estate?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    townCity?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    estate?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    postalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    townCity?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    estate?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodWorked?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    contractExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onNotice?: BoolFieldUpdateOperationsInput | boolean
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchLocation?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    floorOffice?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodWorked?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    contractExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onNotice?: BoolFieldUpdateOperationsInput | boolean
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchLocation?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    floorOffice?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodWorked?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    contractExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onNotice?: BoolFieldUpdateOperationsInput | boolean
    netSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchLocation?: NullableStringFieldUpdateOperationsInput | string | null
    roadStreet?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    floorOffice?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    loan?: LoanApplicationUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUpdateManyWithoutLoanNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLoansNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedLoansNestedInput
    disbursement?: LoanDisbursementUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLoanNestedInput
    guarantors?: GuarantorUncheckedUpdateManyWithoutLoanNestedInput
    investorAllocations?: InvestorAllocationUncheckedUpdateManyWithoutLoanNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLoanNestedInput
    disbursement?: LoanDisbursementUncheckedUpdateOneWithoutLoanNestedInput
    financials?: LoanFinancialUncheckedUpdateOneWithoutLoanNestedInput
    qualification?: LoanQualificationUncheckedUpdateOneWithoutLoanNestedInput
    security?: LoanSecurityUncheckedUpdateOneWithoutLoanNestedInput
    npl?: NonPerformingLoanUncheckedUpdateOneWithoutLoanNestedInput
    recoveryRecords?: RecoveryRecordUncheckedUpdateManyWithoutLoanNestedInput
    repayments?: RepaymentUncheckedUpdateManyWithoutLoanNestedInput
    vehicleSecurity?: VehicleSecurityUncheckedUpdateOneWithoutLoanNestedInput
  }

  export type LoanApplicationUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    amountRequested?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualificationType?: NullableEnumQualificationTypeFieldUpdateOperationsInput | $Enums.QualificationType | null
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repaymentPeriod?: IntFieldUpdateOperationsInput | number
    status?: EnumLoanApplicationStatusFieldUpdateOperationsInput | $Enums.LoanApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefereeUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    idPassportNo?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    locationStation?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    isRelative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefereeUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    idPassportNo?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    locationStation?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    isRelative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefereeUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    otherNames?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    idPassportNo?: NullableStringFieldUpdateOperationsInput | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    locationStation?: NullableStringFieldUpdateOperationsInput | string | null
    phoneWork?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    isRelative?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyLoanInput = {
    id?: string
    clientId?: string | null
    documentType: $Enums.DocumentType
    filePublicId: string
    fileUniqueId: string
    fileName: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type GuarantorCreateManyLoanInput = {
    id?: string
    fullName: string
    phone: string
    email?: string | null
    idNumber?: string | null
    relationship?: string | null
    confirmationStatus?: $Enums.GuarantorStatus
    confirmedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvestorAllocationCreateManyLoanInput = {
    id?: string
    investorId: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyLoanInput = {
    id?: string
    invoiceNumber: string
    clientId: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date | string
    dueDate: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    issuedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecoveryRecordCreateManyLoanInput = {
    id?: string
    agentId: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
  }

  export type RepaymentCreateManyLoanInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    category: $Enums.RepaymentCategory
    reference?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    filePublicId?: StringFieldUpdateOperationsInput | string
    fileUniqueId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuarantorUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationStatus?: EnumGuarantorStatusFieldUpdateOperationsInput | $Enums.GuarantorStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuarantorUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationStatus?: EnumGuarantorStatusFieldUpdateOperationsInput | $Enums.GuarantorStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuarantorUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationStatus?: EnumGuarantorStatusFieldUpdateOperationsInput | $Enums.GuarantorStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorAllocationUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutAllocationsNestedInput
  }

  export type InvestorAllocationUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorAllocationUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: RecoveryAgentUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type RecoveryRecordUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepaymentUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumRepaymentCategoryFieldUpdateOperationsInput | $Enums.RepaymentCategory
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepaymentUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumRepaymentCategoryFieldUpdateOperationsInput | $Enums.RepaymentCategory
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepaymentUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumRepaymentCategoryFieldUpdateOperationsInput | $Enums.RepaymentCategory
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    chargeType: $Enums.ChargeType
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    glAccount?: string | null
    createdAt?: Date | string
  }

  export type InvoicePaymentCreateManyInvoiceInput = {
    id?: string
    transactionId?: string | null
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeType?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAccount?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeType?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAccount?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    chargeType?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAccount?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneWithoutInvoicePaymentsNestedInput
  }

  export type InvoicePaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentCreateManyTransactionInput = {
    id?: string
    invoiceId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
  }

  export type InvoicePaymentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type InvoicePaymentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordCreateManyAgentInput = {
    id?: string
    loanId: string
    actionTaken: string
    outcome?: string | null
    recordedAt: Date | string
    createdAt?: Date | string
  }

  export type RecoveryRecordUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutRecoveryRecordsNestedInput
  }

  export type RecoveryRecordUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRecordUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    actionTaken?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorAllocationCreateManyInvestorInput = {
    id?: string
    loanId: string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    expectedReturn?: Decimal | DecimalJsLike | number | string | null
    actualReturn?: Decimal | DecimalJsLike | number | string
    allocationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorPayoutCreateManyInvestorInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payoutDate: Date | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type InvestorAllocationUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanApplicationUpdateOneRequiredWithoutInvestorAllocationsNestedInput
  }

  export type InvestorAllocationUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorAllocationUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorPayoutUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorPayoutUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorPayoutUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartOfAccountCreateManyParentAccountInput = {
    id?: string
    accountCode: string
    accountName: string
    accountType: $Enums.AccountType
    normalBalance: $Enums.NormalBalance
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChartOfAccountUpdateWithoutParentAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childAccounts?: ChartOfAccountUpdateManyWithoutParentAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutParentAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childAccounts?: ChartOfAccountUncheckedUpdateManyWithoutParentAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateManyWithoutParentAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    normalBalance?: EnumNormalBalanceFieldUpdateOperationsInput | $Enums.NormalBalance
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}